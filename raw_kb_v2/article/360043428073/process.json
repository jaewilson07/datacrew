{"file_path": "../../raw_kb_v2\\article\\360043428073\\index.html", "content": {"Title": "Archiving Historical Data Using a DataFlow", "Article Body": "Intro\n                       \n\n\n                         Let's say you\n                         \n                          put your\u00a0information into a year-to-date DataSet that\u2019s one month behind, starting by loading January\u2019s data in February. Because this is a year-to-date DataSet, once February rolls around the next year, the data from the previous year disappears from the DataSet to make way for the new current year\u2019s data. What if you wanted to archive the data into another DataSet once\u00a0December\u2019s data is loaded in the year-to-date file? As it turns out, there are a couple of ways to accomplish that. They can be done both in MySQL and Magic\n                         \n                         ETL\n                         \n                          .\n                         \n\n\n\n\n\n                          This process applies to any DataSet containing any year-to-date data. Once it hits a year mark, you can archive it for historical purposes.\n                         \n\n\n\n                        Method #1\n                       \n\n                        Method #1 Using a MySQL DataFlow\n                       \n\n\n\n                          This can be done using a stored procedure. This is the most flexible method and can be adapted to account for any extra logic that might need to be applied.\n                         \n\n\n\n\n\n                          The code in this stored procedure assumes a few things:\n                         \n\n\n\n\n\n\n\n\n                             The current year-to-date data will be appended to a historical archive via a recursive DataFlow.\n                            \n\n\n\n\n\n\n\n\n\n                             This recursive DataFlow has already been created.\n                            \n\n\n\n\n\n\n\n\n\n                             The DataFlow has been set up to automatically run when the year-to-date DataSet updates.\n                            \n\n\n\n\n\n\n\n\n                          In the below example, the data will be coming from a DataSet called\n                         \n\n\n\n\n                           ytd_premium_data\n                          \n\n\n\n\n                          , and the historical archive will be called\n                         \n\n\n\n\n                           move_to_historical_method_1\n                          \n\n\n\n\n                          .\n                          \n\n\n\n\n\n\n\n\n\n\n\n\n                          Below is the code for the stored procedure:\n                         \n\n\n\n\n\n\n\n                            CREATE PROCEDURE archive()\n                           \n\n\n\n\n\n\n\n\n\n                            BEGIN\n                           \n\n\n\n\n\n\n\n\n\n                            -- Get the max date from the premium data\n                           \n\n\n\n\n\n\n\n\n\n                            SELECT @maxDataDate := MAX(`Date`)\n                           \n\n\n\n\n\n\n\n\n\n                            FROM\u00a0\u00a0 ytd_premium_data;\n                           \n\n\n\n\n\n\n\n\n\n                            -- Get the max date from the archived data\n                           \n\n\n\n\n\n\n\n\n\n                            SELECT @maxArchiveDate := MAX(`Date`)\n                           \n\n\n\n\n\n\n\n\n\n                            FROM\u00a0\u00a0 move_to_historical_method_1;\n                           \n\n\n\n\n\n\n\n\n\n                            -- We will use these two dates later to determine whether or not the\n                           \n\n\n\n\n\n\n\n\n\n                            -- current year-to-date data has already been added to the historical\n                           \n\n\n\n\n\n\n\n\n\n                            -- archive\n                           \n\n\n\n\n\n\n\n\n\n                            -- The following is a shortcut to dynamically create a table structure\n                           \n\n\n\n\n\n\n\n\n\n                            -- that's identical to another table, but leave it with no data in it.\n                           \n\n\n\n\n\n\n\n\n\n                            -- We\u2019re going to use this trick to create a table with the same\n                           \n\n\n\n\n\n\n\n\n\n                            -- structure as the year-to-date-data\n                           \n\n\n\n\n\n\n\n\n\n                            -- Create a table by selecting only one row from the premium data\n                           \n\n\n\n\n\n\n\n\n\n                            CREATE TABLE archive_data\n                           \n\n\n\n\n\n\n\n\n\n                            SELECT\u00a0\u00a0\u00a0\u00a0 *\n                           \n\n\n\n\n\n\n\n\n\n                            FROM\u00a0\u00a0\u00a0 ytd_premium_data LIMIT 1;\n                           \n\n\n\n\n\n\n\n\n\n                            -- Get rid of all rows from the newly created table\n                           \n\n\n\n\n\n\n\n\n\n                            TRUNCATE TABLE archive_data;\n                           \n\n\n\n\n\n\n\n\n\n                            -- If the conditions are met to archive the year-to-date data, this\n                           \n\n\n\n\n\n\n\n\n\n                            -- new table will be populated with the year-to-date data and appended\n                           \n\n\n\n\n\n\n\n\n\n                            -- to the historical DataSet. If the conditions are not met, the table\n                           \n\n\n\n\n\n\n\n\n\n                            -- will remain empty, and an empty table will be appended to the\n                           \n\n\n\n\n\n\n\n\n\n                            -- historical DataSet.\n                           \n\n\n\n\n\n\n\n\n\n                            -- The year of data to be archived is last year's data. Remember that\n                           \n\n\n\n\n\n\n\n\n\n                            -- the year-to-date data is a month behind, so December\u2019s data won\u2019t\n                           \n\n\n\n\n\n\n\n\n\n                            -- be loaded until January of the next year.\n                           \n\n\n\n\n\n\n\n\n\n                            IF YEAR(CURRENT_DATE()) - 1 = YEAR(@maxDataDate)\n                           \n\n\n\n\n\n\n\n\n\n                            -- It's January, which means we should have December's data\n                           \n\n\n\n\n\n\n\n\n\n                            AND MONTH(CURRENT_DATE()) = 1\n                           \n\n\n\n\n\n\n\n\n\n                            -- The data to be archived contains December's data\n                           \n\n\n\n\n\n\n\n\n\n                            AND MONTH(@maxDataDate) = 12\n                           \n\n\n\n\n\n\n\n\n\n                            -- The data from the year-to-date has not already been added to the\n                           \n\n\n\n\n\n\n\n\n\n                            -- archive\n                           \n\n\n\n\n\n\n\n\n\n                            AND @maxDataDate != @maxArchiveDate\n                           \n\n\n\n\n\n\n\n\n\n                            -- If every condition checks out, then insert the year-to-date data to\n                           \n\n\n\n\n\n\n\n\n\n                            -- be archived into the archive_data table for unioning to the\n                           \n\n\n\n\n\n\n\n\n\n                            -- historical data. Because of the date checks in the previous step,\n                           \n\n\n\n\n\n\n\n\n\n                            -- the following code will only ever be executed once.\n                           \n\n\n\n\n\n\n\n\n\n                            THEN INSERT INTO archive_data\n                           \n\n\n\n\n\n\n\n\n\n                            SELECT\u00a0\u00a0\u00a0\u00a0 *\n                           \n\n\n\n\n\n\n\n\n\n                            FROM ytd_premium_data;\n                           \n\n\n\n\n\n\n\n\n\n                            END IF;\n                           \n\n\n\n\n\n\n\n\n\n                            END;\n                           \n\n\n\n\n\n\n\n                          To call\u00a0the stored procedure...\n                         \n\n\n\n\n\n\n\n                            CALL archive();\n                           \n\n\n\n\n\n\n\n                          Appending year-to-date data (if it\u2019s ready to archive) to historical archive data\u00a0(step name is\n                          \n                           DataFlow_output\n                          \n                          )...\n                         \n\n\n\n\n\n\n\n                            -- Union whatever's in archive_data to thie historical table. If the coniditons for moving the data weren't met, archive_data will be empty.\n                           \n\n\n\n\n\n\n                         SELECT\u00a0\u00a0\u00a0\u00a0 *\n                        \n\n\n\n\n\n\n                            FROM move_to_historical_method_1\n                           \n\n\n\n\n\n\n\n\n\n                            UNION ALL\n                           \n\n\n\n\n\n\n\n\n\n                            SELECT\u00a0\u00a0\u00a0\u00a0 *\n                           \n\n\n\n\n\n\n\n\n\n                            FROM archive_data\n                           \n\n\n\n\n\n\n\n                          This compares what\u2019s already in the archived DataSet to what\u2019s being put in. The\n                          \n                           MAX\n                          \n                          dates for the data are matched. Then, we create a table that\u2019s going to hold the data to be archived. We can use a shortcut of\n                          \n                           SELECT *\n                          \n                          from the table with a limit of 1. \u00a0Then you truncate the table. This is a quick way to create the table schema without having to go through the process manually. That way, we don\u2019t have to replicate the table schema; it does it automatically.\n                         \n\n\n\n\n\n                          Run a couple of checks:\n                         \n\n\n\n\n\n\n\n                            Is it the right year?\n                           \n\n\n\n\n\n\n\n                            Is it January? (If so, December's DataSet\u00a0will be loaded.)\n                           \n\n\n\n\n\n\n\n                            Is the month to be archived December?\n                           \n\n\n\n\n\n\n\n                          Then the last piece of code checks to make sure that the data to be archived hasn\u2019t already been archived. Once it\u2019s archived you don\u2019t want it to archive it again.\n                         \n\n\n\n\n\n                          I\n                         \n\n\n\n                          f it passes, it will be put in the archive data table that was created above. Then, later, all you need to do is just a simple union all with the rest of the archived data. This puts everything together. The process only archives it the one time.\n                         \n\n\n\n\n\n                          Method #1 Using Magic\n                         \n\n\n\n\n\n                          This method is not as straightforward as using MySQL, but the DataFlow uses the same logic.\n                         \n\n\n\n\n\n\n\n                            To get the\n                            \n                             MAX\n                            \n                            date in Magic, you have to do a\n                            \n                             Group By\n                            \n                            transform on a column that is identical in every row. So the first step is to add a column with a constant value using the\n                            \n                             Add Constant\n                            \n                            transform. In this case, I\u2019ve given it a numerical value of 1 and named it \"One.\" This is done twice\u2014once for the year-to-date premium data and once for the historical archive data.\n                            \n\n\n\n\n\n\n\n\n\n\n\n                            Insert a\n                            \n                             Group By\n                            \n                            transform and group by the column we just created (\"One\"), create a new column for each grouping, and select\n                            \n                             Maximum\n                            \n                            for the \"Date\" column. This step will also be done twice\u2014once for the year-to-date premium data and once for the historical archive data. But you need to give different names to each new aggregated column.\n                            \n\n\n\n\n\n\n\n\n\n\n\n\n\n                            Use a\n                            \n                             Join\n                            \n                            transform to join the two DataSets in Step 2 together on column \"One.\"\n                            \n\n\n\n\n\n\n\n\n                            Your results will contain the maximum date in the year-to-date data, the maximum date in the historical archive data, and two columns containing \"One.\"\n                           \n\n\n\n\n\n\n\n\n\n\n                            Use an\n                            \n                             Add Constant\n                            \n                            to add today\u2019s date to the other dates in the DataSet.\n                            \n\n\n\n\n\n\n\n\n\n\n\n                            Insert a\n                            \n                             Date Operations\n                            \n                            transform and create the columns\u00a0\"Current Month\" and \"Current Year\" from the column \"Today\" and \"Data Month\" and \"Data Year\" from the column \"MaxDataDate.\"\n                            \n\n\n\n\n\n\n\n\n\n\n\n                          Your data will now look something like this:\n                          \n\n\n\n\n\n\n\n\n\n                          You now have all the dates and information you need to determine whether or not to append year-to-date data to the historical archive data.\n                         \n\n\n\n\n\n\n\n                            To ensure every row in the year-to-date DataSet contains the data just created, insert a\n                            \n                             Join Data\n                            \n                            transform to an inner join on both DataSets and join on the column \"One.\"\n                            \n\n\n\n\n\n\n\n\n\n\n\n                            Using the\n                            \n                             Calculator\n                            \n                            transform, subtract 1 from \"Current Year\" to determine \"Prior Year.\"\n                            \n\n\n\n\n\n\n\n\n\n\n\n                            Add a\n                            \n                             Filter Rows\n                            \n                            transform to apply the logic to determine whether or not the year-to-date DataSet contains data from December and whether or not it has already been added to the historical data archive.\n                            \n\n\n\n\n\n\n\n\n\n\n\n                          If this step passes all the checks, it will contain all the data from the year-to-date DataSet. If not, it will contain nothing.\n                          \n\n\n\n\n\n\n\n\n\n\n\n                            Use a\n                            \n                             Select Columns\n                            \n                            transform to get rid of all the extra columns we created to make the schema match what\u2019s in the historical data archive.\n                            \n\n\n\n\n\n\n\n\n\n\n\n                            Add an\n                            \n                             Append Rows\n                            \n                            transform to append the year-to-date DataSet (if applicable) to the historical archive DataSet. Be sure to select\n                            \n                             Include all columns\n                            \n                            from the dropdown. If you\u2019ve done everything correctly, a\u00a0\u201cNo changes\u201d message will appear beside each input DataSet.\n                           \n\n\n\n\n\n\n\n\n\n\n                            Under\n                            \n                             Settings\n                            \n                            , check the box to make sure the transform will run whenever the year-to-date DataSet gets updated.\n                            \n\n\n\n\n\n\n\n\n\n\n\n                          Method #2\n                         \n\n\n\n\n\n                          Method #2 Using MySQL\n                         \n\n\n\n\n\n                          If there are no complex requirements for determining whether or not to archive the year-to-date data, and you know that the year-to-date DataSet will be complete by a certain date, then you can create a DataFlow that does nothing but archive the data, and then you can use a trick to schedule to run it on a certain date every year.\n                         \n\n\n\n\n\n                          For our purposes, let\u2019s suppose that we know the year-to-date DataSet will be complete and final by January 20 every year. The first thing we will need to do is create a CSV DataSet and schedule it to update every year on January 20.\n                         \n\n\n\n\n\n\n\n                            Navigate to https://\n                            \n                             yourinstancename\n                            \n                            .\n                            \n                             domo.com/connectors\n                            \n                            /com.domo.connector.csv.easy.\n                           \n\n\n\n\n\n\n\n                            Put anything that makes sense into the box. Here we create a column called \"Date\" with a value of\n                            \n                             1800-01-01\n                            \n                            .\n                            \n\n\n\n\n\n\n\n\n\n\n\n                            Click\n                            \n                             Next\n                            \n                            to\u00a0bring\u00a0up the\n                            \n                             Scheduling\n                            \n                            section.\n                            \n\n\n\n\n\n\n\n\n\n\n\n                            Click the\n                            \n                             Advanced Scheduling\n                            \n                            tab.\n                            \n\n\n\n\n\n\n\n\n\n\n\n                            Check the appropriate\n                            \n                             Month\n                            \n                            (s) and\n                            \n                             Days of Month\n                            \n                            .\n                           \n\n\n\n\n\n\n\n                            Click the\n                            \n                             Time\n                            \n                            tab and choose a time for the job to run.\n                           \n\n\n\n\n\n\n\n                            Click\n                            \n                             Next\n                            \n                            .\n                           \n\n\n\n\n\n\n\n                            Give the CSV DataSet a meaningful name and click\n                            \n                             Save\n                            \n                            .\n                           \n\n\n\n\n\n\n\n                          Now that we have a DataSet that automatically updatex every January 20, we just need a MySQL DataFlow that appends the year-to-date data to the archive DataSet. We will add this CSV DataSet to the DataSets in the DataFlow, and change the settings so that the DataFlow will run once that DataSet gets updated. Because the DataSet only gets update every January 20, then this has the effect of creating a scheduled DataFlow.\n                          \n\n\n\n\n\n\n\n\n\n                          Here is the SQL used in the\n                          \n                           DataFlow Output\n                          \n                          transform:\n                         \n\n\n\n\n\n\n\n\n                            -- This DataFlow won't automatically trigger until the scheduled\n                           \n\n\n\n\n\n\n\n\n\n                            -- update file gets updated. When that happens, it will append last\n                           \n\n\n\n\n\n\n\n\n\n                            -- year's data to historical data.\n                           \n\n\n\n\n\n\n\n\n\n                            SELECT\u00a0\u00a0\u00a0\u00a0 *\n                           \n\n\n\n\n\n\n\n\n\n                            FROM move_to_historical_method_2\n                           \n\n\n\n\n\n\n\n\n\n                            UNION ALL\n                           \n\n\n\n\n\n\n\n\n\n                            SELECT\u00a0\u00a0\u00a0\u00a0 *\n                           \n\n\n\n\n\n\n\n\n\n                            FROM ytd_premium_data\n                           \n\n\n\n\n\n\n\n\n                          Finally, save, but\n                          \n                           do not run the DataFlow!\n                          \n                          Otherwise\u00a0it immediately archives the year-to-date data.\n                         \n\n\n\n\n\n                          Method #2 Using\n                         \n\n\n\n                          Magic ETL\n                         \n\n\n\n\n\n                          The automatically scheduled Magic ETL simply appends year-to-date data to historical archive data. To add the automatic scheduling, you have to add the Auto Update DataSet and check the setting to run the transform whenever it updates. Unlike with a MySQL DataFlow, with Magic ETL, you can\u2019t just add an input DataSet and not incorporate it into a transform because Magic will error out if you try. So you have do a couple of things to incorporate it into the DataFlow, but make sure it doesn\u2019t actually do anything to the data.\n                          \n\n\n\n\n\n\n\n\n\n\n\n                            Add the \"Auto Update\" DataSet as an\n                            \n                             Input Dataset\n                            \n                            .\n                           \n\n\n\n\n\n\n\n                            Insert a\n                            \n                             Filter\n                            \n                            transform. Since one of the columns in this DataSet is a date, set the filter to select only the records where the \"Date\" IS NULL. This will result in no rows of data, which is good\u00a0because we will later append it to the rest of the data, and because there are no rows, there will be zero effect on anything.\n                            \n\n\n\n\n                            Because the CSV file adds two columns when it updates,\u00a0\"_BATCH_ID_\" and \"_BATCH_LAST_RUN_,\" we need to eliminate them from the data.\n                           \n\n\n\n\n\n\n\n                            Insert a\n                            \n                             Select Columns\n                            \n                            transform and select only \"Date.\"\n                           \n\n\n\n\n\n\n\n\n\n\n                            Insert an\n                            \n                             Append\n                            \n                            transform in which you select\n                            \n                             Include All Columns\n                            \n                            in the first dropdown.\n                            \n\n\n\n\n\n\n\n\n\n\n\n                            Save, but\n                            \n                             do not run the DataFlow\n                            \n                            ! If you run this DataFlow, it will append whatever\u2019s currently in the year-to-date DataSet to the archived data DataSet.", "Preview Article": "Click here to preview", "URL Name": "360043428073", "Summary\n                     \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Briefly describe the article. The summary is used in search results to help users find relevant articles. You can improve the accuracy of search results by including phrases that your customers use to describe this issue or topic.": "", "Article Number": "000004608", "Archived Date": "", "Language": "English", "Primary Version": "Archiving Historical Data Using a DataFlow", "Article Total View Count": "4,987", "": "", "Article Created Date": "10/24/2022, 10:16 PM", "First Published Date": "10/24/2022, 10:41 PM"}, "title": "\n              Archiving Historical Data Using a DataFlow\n             ", "breadcrumbs": [{"text": "\n\n               Domo\n              \n", "url": "/s/knowledge-base/"}, {"text": "\n\n               Transforming Data In Domo\n              \n", "url": "/s/topic/0TO5w000000ZamzGAC"}, {"text": "\n\n               Transformation Tips And Tricks\n              \n", "url": "/s/topic/0TO5w000000ZaoJGAS"}]}