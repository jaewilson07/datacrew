{"file_path": "../../raw_kb_v2\\article\\360042923014\\index.html", "content": {"Title": "Optimizing a SQL DataFlow", "Article Body": "Intro\n                       \n\n                        You can optimize your\u00a0DataFlows by creating indices in the DataFlows and limiting your data. Doing so will help eliminate \"Timed Out\" errors by allowing your DataFlows to run more efficiently.\n                       \n\n                        Optimizing Using Indexes\n                       \n\n                        Indexes are used to find rows with specific column values quickly. Without an index, MySQL begins with the first row and reads sequentially to find the relevant data. See\n                        \n                         How MySQL Uses Indexes\n                        \n                        for more detailed information on the best use cases to optimize using indexes.\n                       \n\n                        Joining data and using a WHERE statement in MySQL are the most common reasons for using indexes. When\u00a0you are performing a join or using a WHERE clause, you should index the columns on which you are joining or filtering.\n                       \n\n                        For example, here is a SELECT statement where we are joining two tables together:\n                       \n\n\n                         Select\n                        \n\n\n\n                         a.`column1`,\n                        \n\n\n\n                         a.`column2`,\n                        \n\n\n\n                         b.`column3`,\n                        \n\n\n\n                         b.`column4`\n                        \n\n\n\n                         FROM input_dataset_1 a\n                        \n\n\n\n                         LEFT JOIN input_dataset_2 b\n                        \n\n\n\n                         ON a.`column1` = b.`column3`\n                        \n\n\n                        You should index the two columns in the\n                        \n                         ON\n                        \n                        statement. There are two ways you can accomplish this.\n                       \n\n\n                         Adding a new SQL type transform BEFORE the transform where the join is happening.\n                        \n\n\n                          Using\n                          \n                           Easy\n                           \n                            Indexing\n                           \n\n                          you can quickly add an index on one or more columns right in your\u00a0Table Transform\u00a0without the use of SQL.\n                         \n\n\n\n                        See\n                        \n                         Understanding Transforms\n                        \n                        for more information on the different transform types.\n                       \n\n\n\n                          Create an Easy Index\u00a0by\n                         \n\n                        ,\n                       \n\n\n\n                          Adding a new transform.\n                         \n\n\n\n                          Select Table as the transform type.\n                         \n\n\n\n                          Then, select\u00a0the\n                          \n\n                            Indexing\n                           \n\n                          tab.\n                          \n\n\n\n\n\n\n                          Choose your\n                          \n\n                            Index Type\n                           \n\n                          .\n                         \n\n\n\n                          Select which column to apply the index.\n                         \n\n\n\n                          Click\n                          \n\n                            Done\n                           \n\n                          .\n                         \n\n\n\n                        See\n                        \n                         Understanding Transforms\n                        \n                        for more information on the different transform types.\n                       \n\n                        Other Optimizations\n                       \n\n                        Indexing\u00a0in MySQL does not always optimize the DataFlow to the full extent needed.\u00a0Here are additional things you\u00a0can do to optimize your DataFlow:\n                       \n\n\n\n                          Filter the columns being brought into the DataFlow.\u00a0Some larger DataSets have a large number of columns, not all of which\u00a0are needed.\u00a0You can click on the Dataset in the\n                          \n                           Input Datasets\n                          \n                          section to limit what columns are being brought into the DataFlow.\n                         \n\n\n\n                          Filter your data. The most common way to do this is by using a data filter. For example:\n                          \n\n\n                           SELECT `date`, `value`, `series`\n                           \n                           FROM input_dataset_1\n                           \n\n                            WHERE YEAR(`date`) = YEAR(CURRENT_DATE())\n                           \n\n\n\n\n\n\n                          Take advantage of the\n                          \n                           GROUP BY\n                          \n                          function. When filtering data, you sometimes end up with duplicate rows because they were broken out by another column in the original data. If you aggregate value columns then apply a\n                          \n                           GROUP BY\n                          \n                          to the remaining columns, you can condense the number of rows. The most common aggregation is\n                          \n                           SUM.\n                          \n                          Here is an example:\n                          \n\n\n                           SELECT `Date`, `Series`, SUM(`value`) AS \u2018value\u2019\n                           \n                           FROM input_dataset_1\n                           \n                           GROUP BY `Date`, `Series`\n                          \n\n\n\n\n\n                          If you have a transform with multiple\n                          \n                           JOIN\n                          \n                          s, you can break them up into multiple transforms. For example:\n                          \n\n\n                           SELECT a.`column`,a.`column4`, b.`column2`,b.`column5`,c.`column6`, c.`column3`\n                           \n                           FROM input_dataset_1\n                           \n                           LEFT JOIN input_dataset_2 b\n                           \n                           ON a.`column4` = b.`column2`\n                           \n                           LEFT JOIN input_dataset_3 c\n                           \n                           ON b.`column5` = c.`column3`\n                          \n\n\n\n\n                          You can also split a transform into two transforms. For example:\n                          \n\n                          Transform 1\n                          \n\n\n                           SELECT a.`column`,a.`column4`, b.`column2`,b.`column5`\n                           \n                           FROM input_dataset_1\n                           \n                           LEFT JOIN input_dataset_2 b\n                           \n                           ON a.`column4` = b.`column2`\n                          \n\n\n                          Transform 2\n                          \n\n\n                           SELECT a.`column`,a.`column4`, a.`column2`,a.`column5`,c.`column6`, c.`column3`\n                           \n                           FROM transform_data_1 a\n                           \n                           LEFT JOIN input_dataset_3 c\n                           \n                           ON a.`column5` = c.`column3`\n                          \n\n\n\n\n                        Make sure that if you are using MySQL, you index the columns from transform_data_1 before doing the join, as well as any additional indexing you didn't create.\n                       \n\n                        If none of these methods helps optimize your data, please reach out to\n                        \n                         Domo Support\n                        \n                        .", "Preview Article": "Click here to preview", "URL Name": "360042923014", "Summary\n                     \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Briefly describe the article. The summary is used in search results to help users find relevant articles. You can improve the accuracy of search results by including phrases that your customers use to describe this issue or topic.": "", "Article Number": "000004595", "Archived Date": "", "Language": "English", "Primary Version": "Optimizing a SQL DataFlow", "Article Total View Count": "2,951", "": "", "Article Created Date": "10/24/2022, 10:15 PM", "First Published Date": "10/24/2022, 10:41 PM"}, "title": "\n              Optimizing a SQL DataFlow\n             ", "breadcrumbs": [{"text": "\n\n               Domo\n              \n", "url": "/s/knowledge-base/"}, {"text": "\n\n               Transforming Data In Domo\n              \n", "url": "/s/topic/0TO5w000000ZamzGAC"}, {"text": "\n\n               SQL DataFlows\n              \n", "url": "/s/topic/0TO5w000000Zao9GAC"}]}