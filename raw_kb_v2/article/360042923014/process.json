{"file_path": "../../raw_kb_v2\\article\\360042923014\\index.html", "content": {"title": "\n\n\n Optimizing a SQL DataFlow\n\n\n", "article_body": "\n\nIntro\n-------\n\nYou can optimize your\u00a0DataFlows by creating indices in the DataFlows and limiting your data. Doing so will help eliminate \"Timed Out\" errors by allowing your DataFlows to run more efficiently.\n\n\n Optimizing Using Indexes\n--------------------------\n\nIndexes are used to find rows with specific column values quickly. Without an index, MySQL begins with the first row and reads sequentially to find the relevant data. See\n\nHow MySQL Uses Indexes\n\nfor more detailed information on the best use cases to optimize using indexes.\n\n\n Joining data and using a WHERE statement in MySQL are the most common reasons for using indexes. When\u00a0you are performing a join or using a WHERE clause, you should index the columns on which you are joining or filtering.\n\n\n For example, here is a SELECT statement where we are joining two tables together:\n\n\n`Select`\n\n\n`a.`column1`,`\n\n\n`a.`column2`,`\n\n\n`b.`column3`,`\n\n\n`b.`column4``\n\n\n`FROM input_dataset_1 a`\n\n\n`LEFT JOIN input_dataset_2 b`\n\n\n`ON a.`column1` = b.`column3``\n\n\n You should index the two columns in the\n\nON\n\nstatement. There are two ways you can accomplish this.\n\n. Adding a new SQL type transform BEFORE the transform where the join is happening.\n2. Using\n **Easy\n **Indexing****\n you can quickly add an index on one or more columns right in your\u00a0Table Transform\u00a0without the use of SQL.\n\nSee\n\nUnderstanding Transforms\n\nfor more information on the different transform types.\n\n\n****Create an Easy Index\u00a0by****\n ,\n\n. Adding a new transform.\n2. Select Table as the transform type.\n3. Then, select\u00a0the\n ****Indexing****\n tab.\n4. Choose your\n ****Index Type****\n .\n5. Select which column to apply the index.\n6. Click\n ****Done****\n .\n\nSee\n\nUnderstanding Transforms\n\nfor more information on the different transform types.\n\n\n Other Optimizations\n---------------------\n\nIndexing\u00a0in MySQL does not always optimize the DataFlow to the full extent needed.\u00a0Here are additional things you\u00a0can do to optimize your DataFlow:\n\n Filter the columns being brought into the DataFlow.\u00a0Some larger DataSets have a large number of columns, not all of which\u00a0are needed.\u00a0You can click on the Dataset in the\n **Input Datasets**\n section to limit what columns are being brought into the DataFlow.\n* Filter your data. The most common way to do this is by using a data filter. For example:\n\n\n`SELECT `date`, `value`, `series`\n\n\n FROM input_dataset_1\n\n\n*WHERE YEAR(`date`) = YEAR(CURRENT\\_DATE())*`\n* Take advantage of the\n\nGROUP BY\n\nfunction. When filtering data, you sometimes end up with duplicate rows because they were broken out by another column in the original data. If you aggregate value columns then apply a\n\nGROUP BY\n\nto the remaining columns, you can condense the number of rows. The most common aggregation is\n\nSUM.\n\nHere is an example:\n\n\n`SELECT `Date`, `Series`, SUM(`value`) AS \u2018value\u2019\n\n\n FROM input_dataset_1\n\n\n GROUP BY `Date`, `Series``\n* If you have a transform with multiple\n\nJOIN\n\ns, you can break them up into multiple transforms. For example:\n\n\n`SELECT a.`column`,a.`column4`, b.`column2`,b.`column5`,c.`column6`, c.`column3`\n\n\n FROM input_dataset_1\n\n\n LEFT JOIN input_dataset_2 b\n\n\n ON a.`column4` = b.`column2`\n\n\n LEFT JOIN input_dataset_3 c\n\n\n ON b.`column5` = c.`column3``\n* You can also split a transform into two transforms. For example:\n\n\n Transform 1\n\n\n`SELECT a.`column`,a.`column4`, b.`column2`,b.`column5`\n\n\n FROM input_dataset_1\n\n\n LEFT JOIN input_dataset_2 b\n\n\n ON a.`column4` = b.`column2``\n\n\n Transform 2\n\n\n`SELECT a.`column`,a.`column4`, a.`column2`,a.`column5`,c.`column6`, c.`column3`\n\n\n FROM transform_data_1 a\n\n\n LEFT JOIN input_dataset_3 c\n\n\n ON a.`column5` = c.`column3``\n\nMake sure that if you are using MySQL, you index the columns from transform\\_data\\_1 before doing the join, as well as any additional indexing you didn't create.\n\n\n If none of these methods helps optimize your data, please reach out to\n\nDomo Support\n\n.\n\n", "preview_article": "\n\nClick here to preview\n\n", "url_name": "\n\n\n 360042923014\n\n\n", "summary____________________________________________briefly_describe_the_article_the_summary_is_used_in_search_results_to_help_users_find_relevant_articles_you_can_improve_the_accuracy_of_search_results_by_including_phrases_that_your_customers_use_to_describe_this_issue_or_topic": "\n\n", "article_number": "\n\n\n 000004595\n\n\n", "archived_date": "\n\n\n", "language": "\n\n\n English\n\n\n", "primary_version": "\n\nOptimizing a SQL DataFlow\n\n", "article_total_view_count": "\n\n\n 2,951\n\n\n", "": "\n\n", "article_created_date": "\n\n\n 10/24/2022, 10:15 PM\n\n\n", "first_published_date": "\n\n\n 10/24/2022, 10:41 PM\n\n\n"}, "title": "optimizing_a_sql_dataflow", "breadcrumbs": [{"text": "domo", "url": "/s/knowledge-base/"}, {"text": "transforming_data_in_domo", "url": "/s/topic/0TO5w000000ZamzGAC"}, {"text": "sql_dataflows", "url": "/s/topic/0TO5w000000Zao9GAC"}]}