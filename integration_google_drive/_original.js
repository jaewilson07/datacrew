function updateSpreadsheet() {
  // Get the active spreadsheet and the first sheet
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  var sheet = spreadsheet.getSheets()[0];

  // Get all rows in the first sheet
  var rows = sheet.getDataRange().getValues();

  // Iterate over each row
  for (var i = 1; i < rows.length; i++) {
    // Get the title from the first column of the row
    var title = rows[i][0];

    // Get the docId from the second column of the row
    var docId = rows[i][1];

    // If the docId is empty, upsert the Google Doc
    if (!docId) {
      docId = upsertGoogleDoc(title);

      // Update the row with the doc ID
      sheet.getRange(i + 1, 2).setValue(docId);
    } else {
      // If the docId is not empty, update the name of the Google Doc
      var file = DriveApp.getFileById(docId);
      file.setName(title);
    }
  }

  updateChildrenColumn(sheet, rows);
  updateGoogleDocs(sheet);
}

function upsertGoogleDoc(title) {
  // Check if a file with the same name already exists
  var files = DriveApp.getFilesByName(title);
  if (files.hasNext()) {
    var file = files.next();
    Logger.log("File with name " + title + " already exists.");
    return file.getId();
  }

  // Create a new Google Doc with the title
  var doc = DocumentApp.create(title);

  // Log the URL of the doc
  Logger.log("Created new Google Doc with URL: " + doc.getUrl());

  // Return the ID of the doc
  return doc.getId();
}

///////////////////////////////////////////////////////////////
// Function to calculate the children
function calculateChildrenColumn(data, parentDocId) {
  var children = data
    .filter((row) => row[2] === parentDocId)
    .map((row) => JSON.stringify({ docId: row[1], docName: row[0] }));

  console.log(children);
  return children;
}

// Function to parse over the spreadsheet and update the docChildren column
function updateChildrenColumn(sheet, data) {
  // Write the docChildren results to the 4th column
  for (var i = 1; i < data.length; i++) {
    var row = data[i];
    var docId = row[1]; // Assuming DocId is in the second column
    var children = calculateChildrenColumn(data, docId);
    sheet.getRange(i + 1, 4).setValue("[" + children.join(", ") + "]"); // Assuming the new column is the fourth column
  }
}

function updateGoogleDocs(sheet) {
  var rows = sheet.getDataRange().getValues();

  // Skip the header row
  for (var i = 1; i < rows.length; i++) {
    var row = rows[i];

    var docId = row[1];
    var childrenJson = JSON.parse(row[3]);

    var children = childrenJson.map(function (child) {
      return [child.docId, child.docName];
    });

    updateDocumentLinksSection(docId, children);
  }
}

function replaceSectionInGoogleDoc(
  docId,
  headerName,
  headerType,
  replacementContent
) {
  console.log(replacementContent);

  var doc = DocumentApp.openById(docId);
  var body = doc.getBody();
  var paragraphs = body.getParagraphs();

  var inSection = false;
  var paragraphsToRemove = [];
  var sectionIndex = -1;
  for (var ppt_idx = 0; ppt_idx < paragraphs.length; ppt_idx++) {
    var paragraph = paragraphs[ppt_idx];
    var heading = paragraph.getHeading();

    // Check if we're at the specified heading
    if (heading === headerType && paragraph.getText() === headerName) {
      inSection = true;
      sectionIndex = ppt_idx;
      continue;
    }

    // If we're in the section and we reach another heading or the end of the document, stop
    if (
      inSection &&
      (heading !== DocumentApp.ParagraphHeading.NORMAL ||
        ppt_idx === paragraphs.length - 1)
    ) {
      break;
    }

    // If we're in the section, mark the paragraph for removal
    if (inSection) {
      paragraphsToRemove.push(paragraph);
    }
  }

  // Remove the marked paragraphs
  for (var rm_idx = 0; rm_idx < paragraphsToRemove.length; rm_idx++) {
    body.removeChild(paragraphsToRemove[rm_idx]);
  }

  // Add the new content under the specified heading
  if (inSection) {
    body.insertParagraph(sectionIndex + 1, replacementContent);
  } else {
    // If the section was not found, add the heading and content at the end of the document
    body.appendParagraph(headerName).setHeading(headerType);
    body.appendParagraph(replacementContent);
  }
}

function generateLinkText(docId, docName) {
  // Create the URL to the document
  var docUrl = "https://docs.google.com/document/d/" + docId;

  // Create the link text
  var linkText = "[" + docName + "](" + docUrl + ")\n";

  return linkText;
}

function generateAutoGenerateLine() {
  // Initialize the links body
  var now = new Date();
  var date = now.toLocaleDateString();
  var time = now.toLocaleTimeString();

  // Initialize the body with the first line
  return "<<Autogenerated " + date + " " + time + ">>\n\n";
}

function generateLinksStr(docList) {
  linkStr = "";

  // Add a new line for each child
  docList.forEach(function (doc) {
    // Get the child docId and title
    var cDocId = doc[0];
    var cDocTitle = doc[1];

    // Generate the link text
    var linkText = generateLinkText(cDocId, cDocTitle);

    // Add the link text to the links body
    linkStr += linkText + "\n";
  });

  return linkStr;
}

function convertMarkdownUrls(docId) {
  var doc = DocumentApp.openById(docId);
  var body = doc.getBody();
  var numElements = body.getNumChildren();

  for (var elementIndex = 0; elementIndex < numElements; elementIndex++) {
    var element = body.getChild(elementIndex);

    if (element.getType() === DocumentApp.ElementType.PARAGRAPH) {
      var paragraph = element.asParagraph();
      var text = paragraph.editAsText();
      var textStr = text.getText();

      var match;
      var regex = /\[(.*?)\]\((.*?)\)/g;

      while ((match = regex.exec(textStr)) !== null) {
        var docName = match[1];
        var docUrl = match[2];

        // Find the start and end indices of the markdown URL in the text
        var start = match.index;
        var end = start + docName.length;

        // Set the URL of the link in the text
        text.setLinkUrl(start, end, docUrl);

        // Remove the markdown URL syntax
        text.deleteText(end + 2, end + 2 + docUrl.length); // Delete URL and closing parenthesis
        text.deleteText(start, start); // Delete opening bracket
        text.deleteText(end + 1, end + 1); // Delete closing bracket
        text.deleteText(end, end); // Delete opening parenthesis

        // Update the text string to match the current state of the text

        textStr = text.getText();
        regex = /\[(.*?)\]\((.*?)\)/g; // Create a new RegExp object
      }
    }
  }
}

function updateDocumentLinksSection(docId, childrenTuplesList) {
  linksBody = generateAutoGenerateLine();

  baseContent = "No links associated with this document\n\n";

  if (childrenTuplesList.length != 0) {
    baseContent = generateLinksStr(
      // [['123', 'my favorite doc'], ['234ab','good stuff my friend']]
      childrenTuplesList
    );
  }

  linksBody += baseContent;

  replaceSectionInGoogleDoc(
    (docId = docId),
    (headerName = "Links"),
    (headerType = DocumentApp.ParagraphHeading.HEADING1),
    (replacementContent = linksBody)
  );

  convertMarkdownUrls((docId = docId));
}
