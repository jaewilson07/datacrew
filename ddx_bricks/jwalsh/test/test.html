<!DOCTYPE html>
<html>
<head>
<title>my domolibrary documentation</title>
</head>
<body>

        <div class ="packageHeading" >
        <h1>Python Package Detail:</h1>
        <p><strong>Python Package Name:</strong> " + self.package_name + "</p>
        <p><strong>Version:</strong> " + self.package_name + "</p>
        <p><strong>PyPI:</strong> <a href='https://libraries.io/pypi/domolibrary' target='_blank'>https://libraries.io/pypi/domolibrary</a></p>
        <p><strong>Pip Install:</strong> " + self.pip_install_str + "</p>
        <p><strong>Jupyter Pip Install:</strong> !pip install "domolibrary"</p>
        <p><strong>Location Detail:</strong> "C:\Users\jwilson1\AppData\Roaming\Python\Python310\site-packages\domolibrary"</p>
'
        <hr>
        </div>
        <div class = "packageStructure">
        <h2>domolibrary package structure:</h2>
        <ul>
        <li><a href='#domolibrary\classes\DomoAccessToken.py' target='_blank'>domolibrary\classes\DomoAccessToken.py</a></li>
<li><a href='#domolibrary\classes\DomoAccount.py' target='_blank'>domolibrary\classes\DomoAccount.py</a></li>
<li><a href='#domolibrary\classes\DomoAccount_Config.py' target='_blank'>domolibrary\classes\DomoAccount_Config.py</a></li>
<li><a href='#domolibrary\classes\DomoActivityLog.py' target='_blank'>domolibrary\classes\DomoActivityLog.py</a></li>
<li><a href='#domolibrary\classes\DomoApplication.py' target='_blank'>domolibrary\classes\DomoApplication.py</a></li>
<li><a href='#domolibrary\classes\DomoApplication_Job.py' target='_blank'>domolibrary\classes\DomoApplication_Job.py</a></li>
<li><a href='#domolibrary\classes\DomoBootstrap.py' target='_blank'>domolibrary\classes\DomoBootstrap.py</a></li>
<li><a href='#domolibrary\classes\DomoCard.py' target='_blank'>domolibrary\classes\DomoCard.py</a></li>
<li><a href='#domolibrary\classes\DomoCertification.py' target='_blank'>domolibrary\classes\DomoCertification.py</a></li>
<li><a href='#domolibrary\classes\DomoCodeEngine.py' target='_blank'>domolibrary\classes\DomoCodeEngine.py</a></li>
<li><a href='#domolibrary\classes\DomoDatacenter.py' target='_blank'>domolibrary\classes\DomoDatacenter.py</a></li>
<li><a href='#domolibrary\classes\DomoDataflow.py' target='_blank'>domolibrary\classes\DomoDataflow.py</a></li>
<li><a href='#domolibrary\classes\DomoDataflow_Action.py' target='_blank'>domolibrary\classes\DomoDataflow_Action.py</a></li>
<li><a href='#domolibrary\classes\DomoDataflow_History.py' target='_blank'>domolibrary\classes\DomoDataflow_History.py</a></li>
<li><a href='#domolibrary\classes\DomoDataset.py' target='_blank'>domolibrary\classes\DomoDataset.py</a></li>
<li><a href='#domolibrary\classes\DomoGrant.py' target='_blank'>domolibrary\classes\DomoGrant.py</a></li>
<li><a href='#domolibrary\classes\DomoGroup.py' target='_blank'>domolibrary\classes\DomoGroup.py</a></li>
<li><a href='#domolibrary\classes\DomoGroup_Membership.py' target='_blank'>domolibrary\classes\DomoGroup_Membership.py</a></li>
<li><a href='#domolibrary\classes\DomoInstanceConfig.py' target='_blank'>domolibrary\classes\DomoInstanceConfig.py</a></li>
<li><a href='#domolibrary\classes\DomoInstanceConfig_UserAttribute.py' target='_blank'>domolibrary\classes\DomoInstanceConfig_UserAttribute.py</a></li>
<li><a href='#domolibrary\classes\DomoJupyter.py' target='_blank'>domolibrary\classes\DomoJupyter.py</a></li>
<li><a href='#domolibrary\classes\DomoLineage.py' target='_blank'>domolibrary\classes\DomoLineage.py</a></li>
<li><a href='#domolibrary\classes\DomoPage.py' target='_blank'>domolibrary\classes\DomoPage.py</a></li>
<li><a href='#domolibrary\classes\DomoPage_Content.py' target='_blank'>domolibrary\classes\DomoPage_Content.py</a></li>
<li><a href='#domolibrary\classes\DomoPDP.py' target='_blank'>domolibrary\classes\DomoPDP.py</a></li>
<li><a href='#domolibrary\classes\DomoPublish.py' target='_blank'>domolibrary\classes\DomoPublish.py</a></li>
<li><a href='#domolibrary\classes\DomoRole.py' target='_blank'>domolibrary\classes\DomoRole.py</a></li>
<li><a href='#domolibrary\classes\DomoSandbox.py' target='_blank'>domolibrary\classes\DomoSandbox.py</a></li>
<li><a href='#domolibrary\classes\DomoStream.py' target='_blank'>domolibrary\classes\DomoStream.py</a></li>
<li><a href='#domolibrary\classes\DomoUser.py' target='_blank'>domolibrary\classes\DomoUser.py</a></li>
<li><a href='#domolibrary\client\DomoAuth.py' target='_blank'>domolibrary\client\DomoAuth.py</a></li>
<li><a href='#domolibrary\client\DomoError.py' target='_blank'>domolibrary\client\DomoError.py</a></li>
<li><a href='#domolibrary\client\get_data.py' target='_blank'>domolibrary\client\get_data.py</a></li>
<li><a href='#domolibrary\client\Logger.py' target='_blank'>domolibrary\client\Logger.py</a></li>
<li><a href='#domolibrary\client\ResponseGetData.py' target='_blank'>domolibrary\client\ResponseGetData.py</a></li>
<li><a href='#domolibrary\integrations\Automation.py' target='_blank'>domolibrary\integrations\Automation.py</a></li>
<li><a href='#domolibrary\integrations\DomoJupyter.py' target='_blank'>domolibrary\integrations\DomoJupyter.py</a></li>
<li><a href='#domolibrary\integrations\MonitDataset.py' target='_blank'>domolibrary\integrations\MonitDataset.py</a></li>
<li><a href='#domolibrary\integrations\RoleHierarchy.py' target='_blank'>domolibrary\integrations\RoleHierarchy.py</a></li>
<li><a href='#domolibrary\routes\access_token.py' target='_blank'>domolibrary\routes\access_token.py</a></li>
<li><a href='#domolibrary\routes\account.py' target='_blank'>domolibrary\routes\account.py</a></li>
<li><a href='#domolibrary\routes\activity_log.py' target='_blank'>domolibrary\routes\activity_log.py</a></li>
<li><a href='#domolibrary\routes\application.py' target='_blank'>domolibrary\routes\application.py</a></li>
<li><a href='#domolibrary\routes\auth.py' target='_blank'>domolibrary\routes\auth.py</a></li>
<li><a href='#domolibrary\routes\bootstrap.py' target='_blank'>domolibrary\routes\bootstrap.py</a></li>
<li><a href='#domolibrary\routes\card.py' target='_blank'>domolibrary\routes\card.py</a></li>
<li><a href='#domolibrary\routes\codeengine.py' target='_blank'>domolibrary\routes\codeengine.py</a></li>
<li><a href='#domolibrary\routes\datacenter.py' target='_blank'>domolibrary\routes\datacenter.py</a></li>
<li><a href='#domolibrary\routes\dataflow.py' target='_blank'>domolibrary\routes\dataflow.py</a></li>
<li><a href='#domolibrary\routes\dataset.py' target='_blank'>domolibrary\routes\dataset.py</a></li>
<li><a href='#domolibrary\routes\grant.py' target='_blank'>domolibrary\routes\grant.py</a></li>
<li><a href='#domolibrary\routes\group.py' target='_blank'>domolibrary\routes\group.py</a></li>
<li><a href='#domolibrary\routes\instance_config.py' target='_blank'>domolibrary\routes\instance_config.py</a></li>
<li><a href='#domolibrary\routes\jupyter.py' target='_blank'>domolibrary\routes\jupyter.py</a></li>
<li><a href='#domolibrary\routes\page.py' target='_blank'>domolibrary\routes\page.py</a></li>
<li><a href='#domolibrary\routes\pdp.py' target='_blank'>domolibrary\routes\pdp.py</a></li>
<li><a href='#domolibrary\routes\publish.py' target='_blank'>domolibrary\routes\publish.py</a></li>
<li><a href='#domolibrary\routes\role.py' target='_blank'>domolibrary\routes\role.py</a></li>
<li><a href='#domolibrary\routes\sandbox.py' target='_blank'>domolibrary\routes\sandbox.py</a></li>
<li><a href='#domolibrary\routes\stream.py' target='_blank'>domolibrary\routes\stream.py</a></li>
<li><a href='#domolibrary\routes\user.py' target='_blank'>domolibrary\routes\user.py</a></li>
<li><a href='#domolibrary\routes\user_attributes.py' target='_blank'>domolibrary\routes\user_attributes.py</a></li>
<li><a href='#domolibrary\utils\chunk_execution.py' target='_blank'>domolibrary\utils\chunk_execution.py</a></li>
<li><a href='#domolibrary\utils\convert.py' target='_blank'>domolibrary\utils\convert.py</a></li>
<li><a href='#domolibrary\utils\DictDot.py' target='_blank'>domolibrary\utils\DictDot.py</a></li>
<li><a href='#domolibrary\utils\files.py' target='_blank'>domolibrary\utils\files.py</a></li>
<li><a href='#domolibrary\utils\Image.py' target='_blank'>domolibrary\utils\Image.py</a></li>
<li><a href='#domolibrary\utils\read_creds_from_dotenv.py' target='_blank'>domolibrary\utils\read_creds_from_dotenv.py</a></li>
<li><a href='#domolibrary\utils\upload_data.py' target='_blank'>domolibrary\utils\upload_data.py</a></li>
</ul><hr></div>
        <div class = "fileStructure">
            <h2>PY file structure and details:</h2>
        <a name='domolibrary\classes\DomoAccessToken.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoAccessToken.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoAccessToken.ipynb.

# %% auto 0
__all__ = ['DomoAccessToken', 'get_access_tokens']

# %% ../../nbs/classes/50_DomoAccessToken.ipynb 2
import httpx
import datetime as dt
from nbdev.showdoc import patch_to

from dataclasses import dataclass, field, asdict

import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de
import domolibrary.utils.chunk_execution as ce

import domolibrary.routes.access_token as access_token_routes

# %% ../../nbs/classes/50_DomoAccessToken.ipynb 5
@dataclass
class DomoAccessToken:
    id: int
    name: str
    owner: None
    expiration_date: dt.datetime
    token: str = field(repr=False)

    auth: dmda.DomoAuth = field(repr=False)

    def __eq__(self, other):
        if not isinstance(other, DomoAccessToken):
            return False

        return self.id == other.id

    @classmethod
    async def _from_json(cls, obj, auth):
        import domolibrary.classes.DomoUser as dmu

        owner = await dmu.DomoUser.get_by_id(user_id=obj["ownerId"], auth=auth)

        return cls(
            id=obj["id"],
            name=obj["name"],
            owner=owner,
            expiration_date=obj["expires"],
            auth=auth,
            token=obj.get("token"),
        )

# %% ../../nbs/classes/50_DomoAccessToken.ipynb 6
async def get_access_tokens(
    auth: dmda.DomoAuth = None,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: httpx.AsyncClient = None,
    parent_class=None,
):
    res = await access_token_routes.get_access_tokens(
        auth=auth,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    return await ce.gather_with_concurrency(
        *[DomoAccessToken._from_json(obj=obj, auth=auth) for obj in res.response], n=10
    )

# %% ../../nbs/classes/50_DomoAccessToken.ipynb 8
@patch_to(DomoAccessToken, cls_method=True)
async def generate(
    cls: DomoAccessToken,
    duration_in_days: int,
    token_name: str,
    auth: dmda.DomoAuth,
    owner: None,  # DomoUser
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop: int = 2,
    return_raw: bool = False,
    parent_class: str = None,
):

    res = await access_token_routes.generate_access_token(
        user_id=owner.id,
        token_name=token_name,
        duration_in_days=duration_in_days,
        auth=auth,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class or cls.__name__,
    )

    if return_raw:
        return res

    return await cls._from_json(obj=res.response, auth=auth)

# %% ../../nbs/classes/50_DomoAccessToken.ipynb 9
@patch_to(DomoAccessToken)
async def revoke(
    self,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop: int = 2,
):
    return await access_token_routes.revoke_access_token(
        auth=self.auth,
        access_token_id=self.id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
        session=session,
    )

# %% ../../nbs/classes/50_DomoAccessToken.ipynb 11
@patch_to(DomoAccessToken)
async def regenerate(
    self,
    session: httpx.AsyncClient = None,
    duration_in_days: int = 90,
    debug_api: bool = False,
    return_raw: bool = False,
    debug_num_stacks_to_drop: int = 2,
):

    await self.revoke()

    return await self.generate(
        duration_in_days=duration_in_days,
        token_name=self.name,
        auth=self.auth,
        owner=self.owner,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        return_raw=return_raw,
        parent_class=self.__class__.__name__,
    )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoAccount.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoAccount.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoAccount.ipynb.

# %% auto 0
__all__ = ['Account_CanIModify', 'UpsertAccount_MatchCriteria', 'DomoAccount', 'DomoAccounConfig_MissingFields', 'DomoAccounts',
           'Account_Accesslist_Share', 'Account_Accesslist']

# %% ../../nbs/classes/50_DomoAccount.ipynb 3
from domolibrary.routes.account import (
    ShareAccount_V1_AccessLevel,
    ShareAccount_V2_AccessLevel,
    ShareAccount,
    GetAccount_NoMatch,
    ShareAccount_Error,
    ShareAccount_Error_AlreadyShared,
    DeleteAccount_Error,
)

from domolibrary.classes.DomoAccount_Config import (
    AccountConfig_UsesOauth,
    AccountConfig_ProviderTypeNotDefined,
    DomoAccount_Config,
    AccountConfig,
)

# %% ../../nbs/classes/50_DomoAccount.ipynb 4
from dataclasses import dataclass, field
from typing import Any, List

import httpx
import datetime as dt

from nbdev.showdoc import patch_to

import domolibrary.utils.convert as cd
import domolibrary.utils.DictDot as util_dd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de
import domolibrary.routes.account as account_routes

import domolibrary.utils.chunk_execution as ce

# %% ../../nbs/classes/50_DomoAccount.ipynb 6
class Account_CanIModify(de.DomoError):
    def __init__(self, account_id, domo_instance):
        super().__init__(
            message=f"`DomoAccount.is_admin_summary` must be `False` to proceed.  Either set the value explicity, or retrieve the account instance using `DomoAccount.get_by_id()`",
            domo_instance=domo_instance,
            entity_id=account_id,
        )


class UpsertAccount_MatchCriteria(de.DomoError):
    def __init__(self, domo_instance):
        super().__init__(
            message="must pass an account_id or account_name to UPSERT",
            domo_instance=domo_instance,
        )

# %% ../../nbs/classes/50_DomoAccount.ipynb 8
@dataclass
class DomoAccount:
    id: int
    auth: dmda.DomoAuth = field(repr=False)

    name: str = None
    data_provider_type: str = None

    created_dt: dt.datetime = None
    modified_dt: dt.datetime = None

    config: DomoAccount_Config = None

    owners: List[Any] = None  # DomoUser or DomoGroup

    is_admin_summary: bool = True

    @classmethod
    def _from_json(
        cls,
        obj: dict,
        is_admin_summary: bool = True,
        auth: dmda.DomoAuth = None,
    ):
        """converts data_v1_accounts API response into an accounts class object"""

        dd = util_dd.DictDot(obj)

        return cls(
            id=dd.id or dd.databaseId,
            name=dd.displayName,
            data_provider_type=dd.dataProviderId or dd.dataProviderType,
            created_dt=cd.convert_epoch_millisecond_to_datetime(
                dd.createdAt or dd.createDate
            ),
            modified_dt=cd.convert_epoch_millisecond_to_datetime(
                dd.modifiedAt or dd.lastModified
            ),
            auth=auth,
            is_admin_summary=is_admin_summary,
            owners=dd.owners,
        )

# %% ../../nbs/classes/50_DomoAccount.ipynb 10
class DomoAccounConfig_MissingFields(de.DomoError):
    def __init__(self, domo_instance, missing_keys, account_id):
        super().__init__(
            domo_instance=domo_instance,
            message=f"{account_id} config class definition is missing the following keys - {', '.join(missing_keys)} extend the AccountConfig",
        )


@patch_to(DomoAccount)
def _test_missing_keys(self, res_obj, config_obj):
    return [r_key for r_key in res_obj.keys() if r_key not in config_obj.keys()]


@patch_to(DomoAccount)
async def _get_config(
    self: DomoAccount,
    session=None,
    return_raw: bool = False,
    debug_api: bool = None,
    auth: dmda.DomoAuth = None,
    debug_num_stacks_to_drop=2,
    is_suppress_no_config: bool = False,  # can be used to suppress cases where the config is not defined, either because the account_config is OAuth, and therefore not stored in Domo OR because the AccountConfig class doesn't cover the data_type
):
    if not self.data_provider_type:
        res = await account_routes.get_account_from_id(
            auth=self.auth,
            account_id=self.id,
            session=session,
            debug_api=debug_api,
            parent_class=self.__class__.__name__,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        )

        self.data_provider_type = res.response["dataProviderType"]

    res = await account_routes.get_account_config(
        auth=auth or self.auth,
        account_id=self.id,
        session=session,
        debug_api=debug_api,
        data_provider_type=self.data_provider_type,
        parent_class=self.__class__.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    config_fn = AccountConfig(self.data_provider_type).value

    if not is_suppress_no_config and not config_fn.is_defined_config:
        raise config_fn._associated_exception(self.data_provider_type)

    self.config = config_fn._from_json(res.response)

    if self.config and self.config.to_json() != {}:
        if not res.response:
            print(self.data_provider_type, "no response")

        if not self.config.to_json():
            print(
                self.id,
                self.data_provider_type,
                "no config",
                self.config.to_json(),
                res.response,
            )

        self._test_missing_keys(res_obj=res.response, config_obj=self.config.to_json())

    return self.config

# %% ../../nbs/classes/50_DomoAccount.ipynb 13
@patch_to(DomoAccount, cls_method=True)
async def get_by_id(
    cls,
    auth: dmda.DomoAuth,
    account_id: int,
    is_suppress_no_config: bool = True,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
):
    """retrieves account metadata and attempts to retrieve config"""

    res = await account_routes.get_account_from_id(
        auth=auth,
        account_id=account_id,
        session=session,
        debug_api=debug_api,
        parent_class=cls.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    acc = cls._from_json(obj=res.response, auth=auth, is_admin_summary=False)

    await acc._get_config(
        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop + 1,
        is_suppress_no_config=is_suppress_no_config,
    )

    return acc

# %% ../../nbs/classes/50_DomoAccount.ipynb 20
@patch_to(DomoAccount, cls_method=True)
async def create_account(
    cls: DomoAccount,
    account_name: str,
    config: DomoAccount_Config,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
):
    body = account_routes.generate_create_body(account_name=account_name, config=config)

    res = await account_routes.create_account(
        auth=auth, config_body=body, debug_api=debug_api, session=session
    )

    if return_raw:
        return res

    return await cls.get_by_id(auth=auth, account_id=res.response.get("id"))

# %% ../../nbs/classes/50_DomoAccount.ipynb 22
@patch_to(DomoAccount)
async def update_config(
    self: DomoAccount,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    config: DomoAccount_Config = None,
    is_suppress_no_config=False,
    debug_num_stacks_to_drop=2,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    auth = auth or self.auth
    config = config or self.config

    res = await account_routes.update_account_config(
        auth=auth,
        account_id=self.id,
        config_body=config.to_json(),
        debug_api=debug_api,
        session=session,
    )

    if return_raw:
        return res

    if not res.is_success and self.is_admin_summary:
        raise Account_CanIModify(account_id=self.id, domo_instance=auth.domo_instance)

    await self._get_config(
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop + 1,
        is_suppress_no_config=is_suppress_no_config,
    )

    return self

# %% ../../nbs/classes/50_DomoAccount.ipynb 27
@patch_to(DomoAccount)
async def update_name(
    self: DomoAccount,
    account_name: str = None,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    auth = auth or self.auth

    res = await account_routes.update_account_name(
        auth=auth,
        account_id=self.id,
        account_name=account_name or self.name,
        debug_api=debug_api,
        session=session,
    )

    if return_raw:
        return res

    if not res.is_success and self.is_admin_summary:
        raise Account_CanIModify(account_id=self.id, domo_instance=auth.domo_instance)

    await self.get_by_id(auth=auth, account_id=self.id)

    return self

# %% ../../nbs/classes/50_DomoAccount.ipynb 32
@patch_to(DomoAccount)
async def delete_account(
    self: DomoAccount,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=2,
    parent_class=None,
):
    auth = auth or self.auth

    res = await account_routes.delete_account(
        auth=auth,
        account_id=self.id,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success and self.is_admin_summary:
        raise Account_CanIModify(account_id=self.id, domo_instance=auth.domo_instance)

    return res

# %% ../../nbs/classes/50_DomoAccount.ipynb 34
@patch_to(DomoAccount)
async def is_feature_accountsv2_enabled(
    self: DomoAccount, auth: dmda.DomoFullAuth = None, return_raw: bool = False
):
    """uses bootstrap class to test if the auth object refers to an instancce that has the account-v2 feature switch enabled"""
    import domolibrary.classes.DomoBootstrap as dmbs

    auth = auth or self.auth

    domo_bsr = dmbs.DomoBootstrap(auth=auth)

    try:
        is_v2 = await domo_bsr.is_feature_accountsv2_enabled()
        return 1 if is_v2 else 0

    except dmbs.InvalidAuthTypeError as e:
        print(
            f"Warning - unable to test if accounts_v2 feature is enabled in {auth.domo_instance}, recommend pass FullAuth"
        )
        return -1

# %% ../../nbs/classes/50_DomoAccount.ipynb 37
@patch_to(DomoAccount)
async def _share_v2(
    self: DomoAccount,
    auth: dmda.DomoAuth = None,
    user_id=None,
    group_id=None,
    access_level: ShareAccount = ShareAccount_V2_AccessLevel.CAN_VIEW,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
    is_suppress_already_shared: bool = True,
):
    auth = auth or self.auth

    is_v2 = await self.is_feature_accountsv2_enabled(auth=auth)

    if is_v2 == 0:
        raise account_routes.ShareAccount_Error(
            account_id=self.id,
            response="accounts_v2 feature not enabled, use v1 share method",
            domo_instance=auth.domo_instance,
            function_name="_share_v2",
            parent_class=self.__class__.__name__,
            status=None,
        )

    share_payload = account_routes.generate_share_account_payload_v2(
        user_id=user_id,
        group_id=group_id,
        access_level=access_level,
    )
    try:
        res = await account_routes.share_account_v2(
            auth=auth,
            account_id=self.id,
            share_payload=share_payload,
            debug_api=debug_api,
            session=session,
            parent_class=self.__class__.__name__,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        )

        if return_raw:
            return res

        return f"shared {self.id} - {self.name} with {group_id or user_id}"

    except ShareAccount_Error_AlreadyShared as e:
        if not is_suppress_already_shared:
            raise e

        return f"already shared {self.id} - {self.name} with {group_id or user_id}"

# %% ../../nbs/classes/50_DomoAccount.ipynb 40
@patch_to(DomoAccount)
async def _share_v1(
    self: DomoAccount,
    auth: dmda.DomoAuth = None,
    user_id=None,
    access_level: ShareAccount = ShareAccount_V1_AccessLevel.CAN_VIEW,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
    is_suppress_already_shared: bool = True,
):
    auth = auth or self.auth

    is_v2 = await self.is_feature_accountsv2_enabled(auth=auth)

    if is_v2 == 1:
        raise account_routes.ShareAccount_Error(
            account_id=self.id,
            response="accounts_v2 feature enabled, use v2 share method",
            domo_instance=auth.domo_instance,
            function_name="_share_v2",
            parent_class=self.__class__.__name__,
            status=None,
        )

    share_payload = account_routes.generate_share_account_payload_v1(
        user_id=user_id,
        access_level=access_level,
    )
    try:
        res = await account_routes.share_account_v1(
            auth=auth,
            account_id=self.id,
            share_payload=share_payload,
            debug_api=debug_api,
            session=session,
            parent_class=self.__class__.__name__,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        )

        if return_raw:
            return res

        return f"shared {self.id} - {self.name} with { user_id}"

    except ShareAccount_Error_AlreadyShared as e:
        if is_suppress_already_shared:
            return f"already shared {self.id} - {self.name} with { user_id}"

        else:
            raise e

# %% ../../nbs/classes/50_DomoAccount.ipynb 43
@patch_to(DomoAccount)
async def share(
    self: DomoAccount,
    user_id=None,
    group_id=None,
    domo_user=None,
    domo_group=None,
    auth: dmda.DomoAuth = None,
    access_level: ShareAccount = None,  # will default to Read
    is_suppress_already_shared: bool = True,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 3,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    auth = auth or self.auth
    is_v2 = await self.is_feature_accountsv2_enabled(auth=auth)

    user_id = user_id or (domo_user and domo_user.id)

    debug = {"is_accounts_v2": is_v2}

    res = None

    if is_v2 == 1:
        group_id = group_id or (domo_group and domo_group.id)

        debug.update(
            {
                "user_id*": user_id,
                "group_id": group_id,
            }
        )

        if debug_prn:
            print(debug)

        res = await self._share_v2(
            auth=auth,
            user_id=user_id,
            group_id=group_id,
            debug_api=debug_api,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            session=session,
            is_suppress_already_shared=is_suppress_already_shared,
        )

    elif is_v2 == 0:
        user_ids = [user_id]

        if group_id:
            import domolibrary.classes.DomoGroup as dmdg

            domo_group = await dmdg.DomoGroup.get_by_id(group_id=group_id, auth=auth)

        group_id = group_id or domo_group.id
        domo_users = await domo_group.Membership.get_members()
        user_ids = [domo_user.id for domo_user in domo_users]

        debug.update({"group_id": group_id, "user_ids": user_ids})

        if debug_prn:
            print(debug)

        res = await ce.gather_with_concurrency(
            *[
                self._share_v1(
                    auth=auth,
                    user_id=user_id,
                    debug_api=debug_api,
                    debug_num_stacks_to_drop=debug_num_stacks_to_drop,
                    session=session,
                    is_suppress_already_shared=is_suppress_already_shared,
                )
                for user_id in user_ids
            ],
            n=10,
        )

    return res

# %% ../../nbs/classes/50_DomoAccount.ipynb 47
@dataclass
class DomoAccounts:
    auth: dmda.DomoAuth

# %% ../../nbs/classes/50_DomoAccount.ipynb 48
@staticmethod
@patch_to(DomoAccounts)
async def _get_accounts_accountsapi(
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    res = await account_routes.get_accounts(
        auth=auth, debug_api=debug_api, session=session
    )

    if return_raw:
        return res

    if len(res.response) == 0:
        return []

    return await ce.gather_with_concurrency(
        n=60,
        *[
            DomoAccount.get_by_id(
                account_id=json_obj.get("id"),
                debug_api=debug_api,
                session=session,
                auth=auth,
            )
            for json_obj in res.response
        ],
    )


@patch_to(DomoAccounts, cls_method=True)
async def _get_accounts_queryapi(
    cls: DomoAccounts,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    additional_filters_ls=None,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    """v2 api for works with group_account_v2 beta"""

    import domolibrary.routes.datacenter as datacenter_routes

    res = await datacenter_routes.search_datacenter(
        auth=auth,
        entity_type=datacenter_routes.Datacenter_Enum.ACCOUNT.value,
        additional_filters_ls=additional_filters_ls,
        session=session,
        debug_api=debug_api,
    )

    if return_raw:
        return res

    if len(res.response) == 0:
        return []

    return [
        DomoAccount._from_json(account_obj, auth=auth) for account_obj in res.response
    ]


@patch_to(DomoAccounts, cls_method=True)
async def get_accounts(
    cls: DomoAccounts,
    auth: dmda.DomoAuth,
    additional_filters_ls=None,  # datacenter_routes.generate_search_datacenter_filter
    # account string to search for, must be an exact match in spelling.  case insensitive
    # v2 will use the queryAPI as it returns more complete results than the accountsAPI
    is_v2: bool = None,
    is_suppress_undefined_provider_type: bool = False,
    account_name: str = None,
    account_id: str = None,
    account_type: AccountConfig = None,  # to retrieve a specific account type
    account_type_str=None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
    debug_prn: bool = False,
):
    import domolibrary.classes.DomoBootstrap as bsr
    import domolibrary.routes.datacenter as datacenter_routes

    if isinstance(auth, dmda.DomoFullAuth) and is_v2 is None:
        instance_bsr = bsr.DomoBootstrap(auth=auth)

        is_v2 = await instance_bsr.is_feature_accountsv2_enabled(auth)

        if debug_prn:
            print(
                f"{auth.domo_instance} {'is' if is_v2 else 'is not'} using the v2 beta"
            )

    if is_v2:
        try:
            domo_accounts = await cls._get_accounts_queryapi(
                auth=auth,
                debug_api=debug_api,
                additional_filters_ls=additional_filters_ls,
                session=session,
            )
        except datacenter_routes.SearchDatacenter_NoResultsFound as e:
            print(e)
            domo_accounts = []
    else:
        domo_accounts = await cls._get_accounts_accountsapi(
            auth=auth, debug_api=debug_api, session=session
        )

    if return_raw or len(domo_accounts) == 0:
        return domo_accounts

    if account_id:
        domo_account = next(
            (
                domo_account
                for domo_account in domo_accounts
                if int(domo_account.id) == int(account_id)
            ),
            None,
        )

        if not domo_account:
            raise GetAccount_NoMatch(
                account_id=account_id, domo_instance=auth.domo_instance
            )

        return domo_account

    if account_name and isinstance(account_name, str):
        domo_accounts = [
            domo_account
            for domo_account in domo_accounts
            if domo_account.name.lower() == account_name.lower()
        ]

    if account_type:
        return [
            domo_account
            for domo_account in domo_accounts
            if domo_account.data_provider_type == account_type.value.data_provider_type
        ]

    if account_type_str:
        return [
            domo_account
            for domo_account in domo_accounts
            if domo_account.data_provider_type == account_type_str
        ]

    return domo_accounts

# %% ../../nbs/classes/50_DomoAccount.ipynb 51
@dataclass
class Account_Accesslist_Share:
    entity: Any
    access_level: ShareAccount
    auth: dmda.DomoAuth

    @staticmethod
    async def _get_entity(obj, auth: dmda.DomoAuth):
        if obj["type"] == "USER":
            import domolibrary.classes.DomoUser as dmu

            return await dmu.DomoUser.get_by_id(user_id=obj["id"], auth=auth)

        if obj["type"] == "GROUP":
            import domolibrary.classes.DomoGroup as dmg

            return await dmg.DomoGroup.get_by_id(group_id=obj["id"], auth=auth)

        return None

    @staticmethod
    def _get_access_level(access_level, is_v2: int):
        if is_v2 == 1:
            return ShareAccount_V2_AccessLevel[access_level]

        else:
            return ShareAccount_V1_AccessLevel[access_level]

    @classmethod
    async def _from_json(
        cls: ShareAccount, obj, auth: dmda.DomoAuth, is_v2: bool = False
    ):
        return cls(
            entity=await cls._get_entity(obj, auth=auth),
            auth=auth,
            access_level=cls._get_access_level(obj["accessLevel"], is_v2),
        )


@dataclass
class Account_Accesslist:
    account: DomoAccount
    auth: dmda.DomoAuth
    domo_users = None
    domo_groups = None

# %% ../../nbs/classes/50_DomoAccount.ipynb 52
@patch_to(DomoAccount)
async def get_accesslist(
    self: DomoAccount,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
):
    auth = auth or self.auth
    res = await account_routes.get_account_accesslist(
        auth=auth, account_id=self.id, debug_api=debug_api, session=session
    )

    if return_raw:
        return res

    is_v2 = await self.is_feature_accountsv2_enabled()

    self.accesslist = await ce.gather_with_concurrency(
        *[
            Account_Accesslist_Share._from_json(obj=obj, auth=auth, is_v2=is_v2)
            for obj in res.response["list"]
        ],
        n=10,
    )
    return self.accesslist

# %% ../../nbs/classes/50_DomoAccount.ipynb 56
@patch_to(DomoAccounts, cls_method=True)
async def upsert_account(
    cls: DomoAccounts,
    auth: dmda.DomoAuth,
    account_config: AccountConfig = None,
    account_name: str = None,
    account_id: str = None,
    debug_api: bool = False,
    debug_prn: bool = False,
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
):
    """search for an account and upsert it"""

    if not account_name and not account_id:
        raise UpsertAccount_MatchCriteria(domo_instance=auth.domo_instance)

    acc = None
    res = None

    if account_id:
        acc = await DomoAccounts.get_accounts(account_id=account_id, auth=auth)

        if acc and account_name:
            if debug_prn:
                print(f"upsertting {acc.id}:  updating account_name")
            res = await acc.update_name(
                account_name=account_name, debug_api=debug_api, return_raw=return_raw
            )

    if account_name and acc is None:
        acc = await DomoAccounts.get_accounts(
            account_name=account_name,
            auth=auth,
            account_type_str=(account_config and account_config.data_provider_type)
            or None,
            # is_suppress_undefined_provider_type = True
        )

        if isinstance(acc, list) and len(acc) > 0 and isinstance(acc[0], DomoAccount):
            acc = acc[0]

        else:
            acc = None

    if acc and account_config:  # upsert account
        acc.config = account_config

        if debug_prn:
            print(f"upsertting {acc.id}:  updating config")

        res = await acc.update_config(debug_api=debug_api, return_raw=return_raw)

    if return_raw and acc:
        return res

    if not acc:
        if debug_prn:
            print(f"creating account {account_name} in {auth.domo_instance}")

        acc = await DomoAccount.create_account(
            account_name=account_name,
            config=account_config,
            auth=auth,
            debug_api=debug_api,
            return_raw=return_raw,
        )

    return acc

# %% ../../nbs/classes/50_DomoAccount.ipynb 59
@patch_to(DomoAccount)
async def upsert_share_account_user(
    self: DomoAccount,
    domo_user,
    auth: dmda.DomoAuth = None,
    is_v2: bool = None,
    access_level: ShareAccount = None,  # will default to Read
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    auth = auth or self.auth

    ls_share = await account_routes.get_account_accesslist(
        auth=auth, account_id=self.id
    )
    res = None

    if domo_user:
        user_id = domo_user.id
        found_user = next(
            (
                obj
                for obj in ls_share.response["list"]
                if obj["id"] == user_id and obj["type"] == "USER"
            ),
            None,
        )
        if not found_user:
            res = await self.share(
                domo_user=domo_user,
                auth=auth,
                access_level=access_level,
                debug_api=debug_api,
                debug_prn=debug_prn,
                session=session,
            )

    return res


@patch_to(DomoAccount)
async def upsert_share_account_group(
    self: DomoAccount,
    domo_group,
    auth: dmda.DomoAuth = None,
    is_v2: bool = None,
    access_level: ShareAccount = None,  # will default to Read
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    auth = auth or self.auth

    ls_share = await account_routes.get_account_accesslist(
        auth=auth, account_id=self.id
    )
    res = None

    if domo_group:
        group_id = domo_group.id
        found_group = next(
            (
                obj
                for obj in ls_share.response["list"]
                if obj["id"] == group_id and obj["type"] == "GROUP"
            ),
            None,
        )
        if not found_group:
            res = await self.share(
                domo_group=domo_group,
                auth=auth,
                access_level=access_level,
                debug_api=debug_api,
                debug_prn=debug_prn,
                session=session,
            )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoAccount_Config.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoAccount_Config.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoAccount_Config.ipynb.

# %% auto 0
__all__ = ['DomoAccount_Config', 'AccountConfig_UsesOauth', 'AccountConfig_ProviderTypeNotDefined', 'DomoAccount_NoConfig_OAuth',
           'DomoAccount_NoConfig', 'DomoAccount_Config_AbstractCredential', 'DomoAccount_Config_DatasetCopy',
           'DomoAccount_Config_DomoAccessToken', 'DomoAccount_Config_Governance', 'DomoAccount_Config_AmazonS3',
           'DomoAccount_Config_AmazonS3Advanced', 'DomoAccount_Config_AwsAthena',
           'DomoAccount_Config_HighBandwidthConnector', 'DomoAccount_Config_Snowflake',
           'DomoAccount_Config_SnowflakeUnload_V2', 'DomoAccount_Config_SnowflakeUnloadAdvancedPartition',
           'DomoAccount_Config_SnowflakeWriteback', 'DomoAccount_Config_SnowflakeUnload',
           'DomoAccount_Config_SnowflakeFederated', 'DomoAccount_Config_SnowflakeInternalUnload',
           'DomoAccount_Config_SnowflakeKeyPairAuthentication', 'AccountConfig']

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 3
from enum import Enum
from dataclasses import dataclass, field
from abc import ABC, abstractmethod

import domolibrary.utils.DictDot as util_dd

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 5
class DomoAccount_Config(ABC):
    """DomoAccount Config abstract base class"""

    data_provider_type: str
    is_defined_config: bool = True
    _associated_exception = None

    @classmethod
    @abstractmethod
    def _from_json(cls, obj):
        """convert accounts API response into a class object"""

    @abstractmethod
    def to_json(self):
        """convert class object into a format the accounts API expects"""

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 6
class AccountConfig_UsesOauth(Exception):
    def __init__(self, data_provider_type):
        super().__init__(
            f"data provider type {data_provider_type} uses OAuth and therefore wouldn't return a Config object"
        )


class AccountConfig_ProviderTypeNotDefined(Exception):
    def __init__(self, data_provider_type):
        super().__init__(
            f"data provider type {data_provider_type} not defined yet. Extend the AccountConfig class"
        )


@dataclass
class DomoAccount_NoConfig_OAuth(DomoAccount_Config):
    is_oauth: bool = True
    is_defined_config: bool = False
    _associated_exception = AccountConfig_UsesOauth

    @classmethod
    def _from_json(cls, obj):
        return cls()

    def to_json(self):
        return {}


@dataclass
class DomoAccount_NoConfig(DomoAccount_Config):
    is_defined_config: bool = False
    _associated_exception = AccountConfig_ProviderTypeNotDefined

    @classmethod
    def _from_json(cls, obj):
        return cls()

    def to_json(self):
        return {}

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 8
@dataclass
class DomoAccount_Config_AbstractCredential(DomoAccount_Config):
    data_provider_type = "abstract-credential-store"
    credentials: dict

    @classmethod
    def _from_json(cls, obj):
        dd = util_dd.DictDot(obj)

        return cls(
            credentials=dd.credentials,
        )

    def to_json(self):
        return {"credentials": self.credentials}

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 9
@dataclass
class DomoAccount_Config_DatasetCopy(DomoAccount_Config):
    domo_instance: str
    access_token: str = field(repr=False)

    data_provider_type = "dataset-copy"

    @classmethod
    def _from_json(cls, obj):
        dd = util_dd.DictDot(obj)

        return cls(access_token=dd.accessToken, domo_instance=dd.instance)

    def to_json(self):
        return {"accessToken": self.access_token, "instance": self.domo_instance}


@dataclass
class DomoAccount_Config_DomoAccessToken(DomoAccount_Config):
    data_provider_type = "domo-access-token"

    domo_access_token: str = field(repr=False, default=None)
    username: str = None
    password: str = field(repr=False, default=None)

    @classmethod
    def _from_json(cls, obj):
        dd = util_dd.DictDot(obj)

        return cls(
            domo_access_token=dd.domoAccessToken,
            username=dd.username,
            password=dd.password,
        )

    def to_json(self):
        return {
            "domoAccessToken": self.domo_access_token or "",
            "username": self.username or "",
            "password": self.password or "",
        }

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 10
@dataclass
class DomoAccount_Config_Governance(DomoAccount_Config):
    domo_instance: str
    access_token: str = field(repr=False)

    data_provider_type = "domo-governance-d14c2fef-49a8-4898-8ddd-f64998005600"

    @classmethod
    def _from_json(cls, obj):
        dd = util_dd.DictDot(obj)

        return cls(access_token=dd.apikey, domo_instance=dd.customer)

    def to_json(self):
        return {"apikey": self.access_token, "customer": self.domo_instance}

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 12
@dataclass
class DomoAccount_Config_AmazonS3(DomoAccount_Config):
    access_key: str
    secret_key: str = field(repr=False)
    bucket: str
    region: str = "us-west-2"
    data_provider_type = "amazon-s3"

    @classmethod
    def _from_json(cls, obj):
        dd = util_dd.DictDot(obj)

        return cls(
            access_key=dd.accessKey,
            secret_key=dd.secretKey,
            bucket=dd.bucket,
            region=dd.region,
        )

    def to_json(self):
        bucket = self.bucket

        if bucket and bucket.lower().startswith("s3://"):
            bucket = bucket[5:]
            print(
                f"ü§¶‚Äç‚ôÄÔ∏è- Domo bucket expects string without s3:// prefix. Trimming to '{bucket}' for the output"
            )
        return {
            "accessKey": self.access_key,
            "secretKey": self.secret_key,
            "bucket": bucket,
            "region": self.region,
        }

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 13
@dataclass
class DomoAccount_Config_AmazonS3Advanced(DomoAccount_Config):
    access_key: str
    secret_key: str = field(repr=False)
    bucket: str
    region: str = "us-west-2"
    data_provider_type = "amazons3-advanced"

    @classmethod
    def _from_json(cls, obj):
        dd = util_dd.DictDot(obj)

        return cls(
            access_key=dd.accessKey,
            secret_key=dd.secretKey,
            bucket=dd.bucket,
            region=dd.region,
        )

    def to_json(self):
        bucket = self.bucket

        if bucket and bucket.lower().startswith("s3://"):
            bucket = bucket[5:]
            print(
                f"ü§¶‚Äç‚ôÄÔ∏è- Domo bucket expects string without s3:// prefix. Trimming to '{bucket}' for the output"
            )
        return {
            "accessKey": self.access_key,
            "secretKey": self.secret_key,
            "bucket": bucket,
            "region": self.region,
        }

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 14
@dataclass
class DomoAccount_Config_AwsAthena(DomoAccount_Config):
    access_key: str
    secret_key: str = field(repr=False)
    bucket: str
    workgroup: str

    region: str = "us-west-2"
    data_provider_type = "aws-athena"

    @classmethod
    def _from_json(cls, obj):
        dd = util_dd.DictDot(obj)

        return cls(
            access_key=dd.awsAccessKey,
            secret_key=dd.awsSecretKey,
            bucket=dd.s3StagingDir,
            region=dd.region,
            workgroup=dd.workgroup,
        )

    def to_json(self):
        return {
            "awsAccessKey": self.access_key,
            "awsSecretKey": self.secret_key,
            "s3StagingDir": self.bucket,
            "region": self.region,
            "workgroup": self.workgroup,
        }

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 15
@dataclass
class DomoAccount_Config_HighBandwidthConnector(DomoAccount_Config):
    """this connector is not enabled by default contact your CSM / AE"""

    access_key: str
    secret_key: str = field(repr=False)
    bucket: str

    region: str = "us-west-2"
    data_provider_type = "amazon-athena-high-bandwidth"

    @classmethod
    def _from_json(cls, obj):
        dd = util_dd.DictDot(obj)

        return cls(
            access_key=dd.awsAccessKey,
            secret_key=dd.awsSecretKey,
            bucket=dd.s3StagingDir,
            region=dd.region,
        )

    def to_json(self):
        return {
            "awsAccessKey": self.access_key,
            "awsSecretKey": self.secret_key,
            "s3StagingDir": self.bucket,
            "region": self.region,
        }

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 19
@dataclass
class DomoAccount_Config_Snowflake(DomoAccount_Config):
    """this connector is not enabled by default contact your CSM / AE"""

    account: str
    username: str
    password: str = field(repr=False)
    role: str = None

    data_provider_type = "snowflake"

    @classmethod
    def _from_json(cls, obj):
        dd = util_dd.DictDot(obj)

        return cls(
            account=dd.account,
            username=dd.username,
            password=dd.password,
            role=dd.role,
        )

    def to_json(self):
        return {
            "account": self.account,
            "username": self.username,
            "password": self.password,
            "role": self.role,
        }

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 21
@dataclass
class DomoAccount_Config_SnowflakeUnload_V2(DomoAccount_Config):
    """this connector is not enabled by default contact your CSM / AE"""

    account: str
    username: str
    password: str = field(repr=False)

    access_key: str
    secret_key: str = field(repr=False)
    region: str
    bucket: str

    role: str = None

    data_provider_type = "snowflake-unload-v2"

    @classmethod
    def _from_json(cls, obj):
        dd = util_dd.DictDot(obj)

        return cls(
            account=dd.account,
            username=dd.username,
            password=dd.password,
            access_key=dd.accessKey,
            secret_key=dd.secretKey,
            bucket=dd.bucket,
            region=dd.region,
            role=dd.role,
        )

    def to_json(self):
        return {
            "account": self.account,
            "username": self.username,
            "password": self.password,
            "role": self.role,
            "accessKey": self.access_key,
            "secretKey": self.secret_key,
            "bucket": self.bucket,
            "region": self.region,
        }

    def to_bucket(self) -> dict:
        keys = ["region", "bucket", "secret_key", "access_key"]
        return {key: getattr(self, key) for key in keys}

    def to_user(self) -> dict:
        keys = ["account", "username", "password", "role", "data_provider_type"]
        return {key: getattr(self, key) for key in keys}

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 23
@dataclass
class DomoAccount_Config_SnowflakeUnloadAdvancedPartition(DomoAccount_Config):
    password: str = field(repr=False)
    account: str
    username: str
    role: str = None

    data_provider_type = "snowflake-internal-unload-advanced-partition"

    @classmethod
    def _from_json(cls, obj):
        return cls(
            password=obj["password"],
            role=obj.get("role"),
            account=obj["account"],
            username=obj["username"],
        )

    def to_json(self):
        return {
            "password": self.password,
            "role": self.role,
            "account": self.account,
            "username": self.username,
        }

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 24
@dataclass
class DomoAccount_Config_SnowflakeWriteback(DomoAccount_Config):
    domo_client_secret: str = field(repr=False)
    domo_client_id: str
    account: str
    password: str = field(repr=False)
    username: str

    data_provider_type = "snowflake-writeback"

    @classmethod
    def _from_json(cls, obj):
        return cls(
            domo_client_secret=obj["domoClientSecret"],
            domo_client_id=obj["domoClientId"],
            account=obj["account"],
            username=obj["username"],
            password=obj["password"],
        )

    def to_json(self):
        return {
            "domoClientSecret": self.domo_client_secret,
            "password": self.password,
            "domoClientId": self.domo_client_id,
            "account": self.account,
            "username": self.username,
        }

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 25
@dataclass
class DomoAccount_Config_SnowflakeUnload(DomoAccount_Config):
    secret_key: str = field(repr=False)
    access_key: str
    account: str
    password: str = field(repr=False)
    username: str
    bucket: str

    data_provider_type = "snowflake-unload"

    @classmethod
    def _from_json(cls, obj):
        return cls(
            secret_key=obj["secretKey"],
            access_key=obj["accessKey"],
            account=obj["account"],
            username=obj["username"],
            password=obj["password"],
            bucket=obj["bucket"],
        )

    def to_json(self):
        return {
            "bucket": self.bucket,
            "password": self.password,
            "secretKey": self.secret_key,
            "accessKey": self.access_key,
            "account": self.account,
            "username": self.username,
        }

    def to_bucket(self) -> dict:
        keys = ["bucket", "secret_key", "access_key"]
        return {key: getattr(self, key) for key in keys}

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 26
@dataclass
class DomoAccount_Config_SnowflakeFederated(DomoAccount_Config):
    password: str = field(repr=False)
    host: str
    warehouse: str
    username: str
    port: str = None
    role: str = None

    data_provider_type = "snowflake-federated"

    @classmethod
    def _from_json(cls, obj):
        return cls(
            password=obj["password"],
            host=obj["host"],
            warehouse=obj["warehouse"],
            username=obj["user"],
            role=obj.get("role"),
            port=obj.get("port"),
        )

    def to_json(self):
        return {
            "password": self.password,
            "port": self.port,
            "host": self.host,
            "warehouse": self.warehouse,
            "user": self.username,
            "role": self.role,
        }

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 27
@dataclass
class DomoAccount_Config_SnowflakeInternalUnload(DomoAccount_Config):
    password: str = field(repr=False)
    account: str
    username: str
    role: str = None
    data_provider_type = "snowflake-internal-unload"

    @classmethod
    def _from_json(cls, obj):
        return cls(
            password=obj["password"],
            role=obj.get("role"),
            account=obj["account"],
            username=obj["username"],
        )

    def to_json(self):
        return {
            "password": self.password,
            "role": self.role,
            "account": self.account,
            "username": self.username,
        }

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 28
@dataclass
class DomoAccount_Config_SnowflakeKeyPairAuthentication(DomoAccount_Config):
    private_key: str = field(repr=False)
    account: str = field(repr=False)
    passphrase: str = field(repr=False)
    username: str
    role: str = None
    data_provider_type = "snowflakekeypairauthentication"

    @classmethod
    def _from_json(cls, obj):
        return cls(
            private_key=obj["privateKey"],
            role=obj.get("role"),
            account=obj["account"],
            username=obj["username"],
            passphrase=obj["passPhrase"],
        )

    def to_json(self):
        return {
            "privateKey": self.private_key,
            "role": self.role,
            "account": self.account,
            "username": self.username,
            "passPhrase": self.passphrase,
        }

# %% ../../nbs/classes/50_DomoAccount_Config.ipynb 29
class AccountConfig(Enum):
    """
    Enum provides appropriate spelling for data_provider_type and config object.
    The name of the enum should correspond with the data_provider_type with hyphens replaced with underscores.
    """

    abstract_credential_store = DomoAccount_Config_AbstractCredential
    dataset_copy = DomoAccount_Config_DatasetCopy
    domo_access_token = DomoAccount_Config_DomoAccessToken
    domo_governance_d14c2fef_49a8_4898_8ddd_f64998005600 = DomoAccount_Config_Governance
    aws_athena = DomoAccount_Config_AwsAthena
    amazon_athena_high_bandwidth = DomoAccount_Config_HighBandwidthConnector
    amazon_s3 = DomoAccount_Config_AmazonS3
    amazons3_advanced = DomoAccount_Config_AmazonS3Advanced

    snowflake = DomoAccount_Config_Snowflake

    snowflake_unload = DomoAccount_Config_SnowflakeUnload
    snowflake_unload_v2 = DomoAccount_Config_SnowflakeUnload_V2

    snowflake_internal_unload_advanced_partition = (
        DomoAccount_Config_SnowflakeUnloadAdvancedPartition
    )

    snowflake_internal_unload = DomoAccount_Config_SnowflakeInternalUnload

    snowflakekeypairauthentication = DomoAccount_Config_SnowflakeKeyPairAuthentication

    snowflake_writeback = DomoAccount_Config_SnowflakeWriteback
    snowflake_federated = DomoAccount_Config_SnowflakeFederated

    _uses_oauth = ["google_spreadsheets"]

    _config_oauth = DomoAccount_NoConfig_OAuth
    _config_notdefined = DomoAccount_NoConfig

    @classmethod
    def _test_altname_search(cls, raw_value):
        alt_search_str = raw_value.lower().replace("-", "_")

        alt_search = next(
            (member for member in cls if member.name == alt_search_str), None
        )

        ## best case scenario alt_search yields a result
        if alt_search:
            return alt_search

        ## second best case, display_type is an oauth and therefore has mo matching config
        oauth_match = next(
            (
                oauth_str
                for oauth_str in cls._uses_oauth.value
                if oauth_str == alt_search_str
            ),
            None,
        )
        if oauth_match:
            raise AccountConfig_UsesOauth(raw_value)

        ## worst case, unencountered display_type
        raise AccountConfig_ProviderTypeNotDefined(raw_value)

    @classmethod
    def _missing_(cls, value):
        try:
            return cls._test_altname_search(value)

        except AccountConfig_UsesOauth as e:
            print(e)
            return cls._config_oauth

        except AccountConfig_ProviderTypeNotDefined as e:
            print(e)
            return cls._config_notdefined

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoActivityLog.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoActivityLog.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoActivityLog.ipynb.

# %% auto 0
__all__ = ['ActivityLog_ObjectType', 'DomoActivityLog']

# %% ../../nbs/classes/50_DomoActivityLog.ipynb 3
from enum import Enum
from typing import Optional

import datetime as dt

import httpx

import domolibrary.utils.convert as convert
import domolibrary.client.DomoAuth as dmda
import domolibrary.routes.activity_log as activity_log_routes

# %% ../../nbs/classes/50_DomoActivityLog.ipynb 4
class ActivityLog_ObjectType(Enum):
    """enumerates valid object types to pass to activity log api"""

    ACCESS_TOKEN = "ACCESS_TOKEN"
    ACCOUNT = "ACCOUNT"
    ACTIVITY_LOG = "ACTIVITY_LOG"
    ALERT = "ALERT"
    APP = "APP"
    APPDB_COLLECTION = "MAGNUM_COLLECTION"
    APPDB_DATASTORE = "MAGNUM_DATASTORE"
    AUTHORITY = "AUTHORITY"
    BEAST_MODE_FORMULA = "BEAST_MODE_FORMULA"
    BUZZ_CHANNEL = "CHANNEL"
    BUZZ_GROUP_CHAT = "GROUP_CHAT"
    BUZZ_THREAD = "HUDDLE"
    CARD = "CARD"
    CHART_COLOR_PALETTE = "CHART_COLOR_PALETTE"
    COLLECTION = "COLLECTION"
    CUSTOMER = "CUSTOMER"
    CUSTOMER_STATE = "CUSTOMER_STATE"
    CUSTOMER_TIER = "CUSTOMER_TIER"
    DATA_SCIENCE_NOTEBOOK = "DATA_SCIENCE_NOTEBOOK"
    DATAFLOW = "DATAFLOW_TYPE"
    DATASET = "DATA_SOURCE"
    DATASOURCE = "DATASOURCE"
    DEPLOYMENT = "DEPLOYMENT"
    DRILL_VIEW = "DRILL_VIEW"
    EASY_INVITE_LINK = "EASY_INVITE_LINK"
    ENABLED = "ENABLED"
    FILE = "FILE"
    FILE_VERSION = "FILE_REVISION"
    GROUP = "GROUP"
    LICENSE_PAGE = "LICENSE_PAGE"
    LOGIN_SETTINGS = "LOGIN_SETTINGS"
    NAME = "NAME"
    PDP_FILTER = "ADC_FILTER"
    PDP_POLICY = "ADC_POLICY"
    PAGE = "PAGE"
    PAGE_ANALYZER = "PAGE_ANALYZER"
    PAGE_COLLECTION = "PAGE_COLLECTION"
    PROJECT = "PROJECT"
    PROJECT_LIST = "PROJECT_LIST"
    PROJECT_TASK = "PROJECT_TASK"
    PROJECT_TASK_ATTACHMENT = "PROJECT_TASK_ATTACHMENT"
    PROJECT_TASK_OWNER = "PROJECT_TASK_OWNER"
    PROXIER_EMAIL = "PROXIER_EMAIL"
    PUBLIC_EMBED_URL = "PUBLIC_URL"
    PUBLICATION = "PUBLICATION"
    REPOSITORY = "REPOSITORY"
    REPOSITORY_AUTHORIZATION = "REPOSITORY_AUTHORIZATION"
    ROLE = "ROLE"
    SEGMENT = "SEGMENT"
    SSO_PAGE = "SSO_PAGE"
    SUBSCRIBER = "PROXY_USER"
    USER = "USER"
    USER_STATE = "USER_STATE"
    VARIABLE = "VARIABLE"
    VARIABLE_CONTROL = "VARIABLE_CONTROL"
    NOTEBOOK_VIEW = "CONTAINER_VIEW"
    VIEW = "VIEW"
    VIRTUAL_USER = "VIRTUAL_USER"
    WORKBENCH_AGENT = "Workbench_AGENT"
    WORKBENCH_JOB = "Workbench_JOB"
    WORKBENCH_SCHEDULE = "Workbench_SCHEDULE"

# %% ../../nbs/classes/50_DomoActivityLog.ipynb 6
class DomoActivityLog:
    @staticmethod
    def _process_activity_log_row(row):

        if row.get("time"):
            row.update(
                {
                    "time_dt": convert.convert_epoch_millisecond_to_datetime(
                        row.get("time")
                    )
                }
            )

            row.update({"date": row.get("time_dt").date()})

        return row

    @classmethod
    async def get_activity_log(
        cls,
        auth: dmda.DomoAuth,
        start_time: dt.datetime,
        end_time: dt.datetime,
        object_type: Optional[ActivityLog_ObjectType] = None,
        maximum: int = 1000,
        session: Optional[httpx.AsyncClient] = None,
        debug_api: bool = False,
        debug_loop: bool = False,
    ):
        """queries the activity log"""

        start_time_epoch = convert.convert_datetime_to_epoch_millisecond(start_time)
        end_time_epoch = convert.convert_datetime_to_epoch_millisecond(end_time)

        res_activity_log = await activity_log_routes.search_activity_log(
            auth=auth,
            start_time=start_time_epoch,
            end_time=end_time_epoch,
            maximum=maximum,
            object_type=object_type.value,
            session=session,
            debug_api=debug_api,
            debug_loop=debug_loop,
        )

        if res_activity_log.is_success:
            return [
                cls._process_activity_log_row(row) for row in res_activity_log.response
            ]

        return None

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoApplication.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoApplication.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoApplication.ipynb.

# %% auto 0
__all__ = ['DomoJob_Types', 'DomoApplication']

# %% ../../nbs/classes/50_DomoApplication.ipynb 2
import pandas as pd
from dataclasses import dataclass, field
from typing import Optional, List
from enum import Enum
import httpx

from nbdev.showdoc import patch_to

import domolibrary.routes.application as application_routes
import domolibrary.classes.DomoApplication_Job as dmdj
import domolibrary.utils.convert as cc
import domolibrary.utils.DictDot as util_dd
import domolibrary.client.DomoAuth as dmda

# %% ../../nbs/classes/50_DomoApplication.ipynb 5
class DomoJob_Types(Enum):
    REMOTE_DOMO_STATS = dmdj.DomoJob_RemoteDomoStats
    DATA_WATCHDOG = dmdj.DomoJob_Watchdog

    default = dmdj.DomoJob

    @staticmethod
    def _convert_api_name_to_member_name(api_name):
        return (
            cc.convert_str_to_snake_case(api_name, is_only_alphanumeric=True)
            .upper()
            .replace("TOOLKIT_", "")
        )

    @classmethod
    def get_from_api_name(cls, api_name):
        member_name = cls._convert_api_name_to_member_name(api_name)

        if member_name not in cls.__members__:
            return cls["default"].value

        return cls[member_name].value


DomoJob_Types.get_from_api_name("Toolkit: Remote Domo Stat")

# %% ../../nbs/classes/50_DomoApplication.ipynb 7
@dataclass
class DomoApplication:
    auth: dmda.DomoAuth = field(repr=False)
    id: str
    version: str = None
    name: str = None
    customer_id: str = None
    description: str = None
    execution_class: str = None
    grants: List[str] = None
    jobs: List[dmdj.DomoJob] = field(default=None)
    jobs_schedule: List[dmdj.DomoTrigger_Schedule] = field(default=None, repr=False)

    @classmethod
    def _from_json(cls, obj, auth: dmda.DomoFullAuth = None):
        dd = util_dd.DictDot(obj)

        return cls(
            id=dd.applicationId,
            customer_id=dd.customerId,
            name=dd.name,
            description=dd.description,
            version=dd.version,
            execution_class=dd.executionClass,
            grants=dd.authorities,
            auth=auth,
        )

    def _get_job_class(self):
        return DomoJob_Types.get_from_api_name(self.name)

# %% ../../nbs/classes/50_DomoApplication.ipynb 8
@patch_to(DomoApplication, cls_method=True)
async def get_from_id(
    cls,
    auth: dmda.DomoAuth,
    application_id,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=2,
):
    res = await application_routes.get_application_by_id(
        application_id=application_id,
        auth=auth,
        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    return cls._from_json(obj=res.response, auth=auth)

# %% ../../nbs/classes/50_DomoApplication.ipynb 10
@patch_to(DomoApplication)
async def get_jobs(
    self,
    debug_api: bool = False,
    session: Optional[httpx.AsyncClient] = None,
    return_raw: bool = False,
):

    res = await application_routes.get_application_jobs(
        auth=self.auth,
        application_id=self.id,
        debug_api=debug_api,
        session=session,
        parent_class=self.__class__.__name__,
    )

    if return_raw:
        return res

    job_cls = self._get_job_class()

    self.jobs = [job_cls._from_json(job, auth=self.auth) for job in res.response]
    return self.jobs

# %% ../../nbs/classes/50_DomoApplication.ipynb 12
@patch_to(DomoApplication)
async def get_schedules(self) -> pd.DataFrame:
    if not self.jobs:
        await self.get_jobs()

    # return self.jobs

    schedules = pd.DataFrame(
        [
            {
                **trigger.schedule.to_obj(),
                "job_name": job.name,
                "job_id": job.id,
                "description": job.description,
                "remote_instance": job.remote_instance,
                "application": self.name,
            }
            for job in self.jobs
            for trigger in job.triggers
        ]
    )

    # return schedules

    self.jobs_schedule = schedules.sort_values(
        ["hour", "minute"], ascending=True
    ).reset_index(drop=True)
    return self.jobs_schedule

# %% ../../nbs/classes/50_DomoApplication.ipynb 14
@patch_to(DomoApplication)
async def find_next_job_schedule(
    self, return_raw: bool = False
) -> dmdj.DomoTrigger_Schedule:

    await self.get_jobs()
    await self.get_schedules()

    df_all_hours = pd.DataFrame(range(0, 23), columns=["hour"])
    df_all_minutes = pd.DataFrame(range(0, 60), columns=["minute"])

    df_all_hours["tmp"] = 1
    df_all_minutes["tmp"] = 1
    df_all = pd.merge(df_all_hours, df_all_minutes, on="tmp").drop(columns=["tmp"])

    # get the number of occurencies of each hour and minutes
    schedules_grouped = (
        self.jobs_schedule.groupby(["hour", "minute"])
        .size()
        .reset_index(name="cnt_schedule")
    )

    # print(schedules_grouped)
    # print(df_all)

    schedules_interpolated = pd.merge(
        df_all, schedules_grouped, how="left", on=["hour", "minute"]
    )

    schedules_interpolated["cnt_schedule"] = schedules_interpolated[
        "cnt_schedule"
    ].fillna(value=0)
    schedules_interpolated.sort_values(
        ["cnt_schedule", "hour", "minute"], ascending=True, inplace=True
    )

    schedules_interpolated.reset_index(drop=True, inplace=True)

    if return_raw:
        return schedules_interpolated

    return dmdj.DomoTrigger_Schedule(
        hour=int(schedules_interpolated.loc[0].get("hour")),
        minute=int(schedules_interpolated.loc[0].get("minute")),
    )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoApplication_Job.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoApplication_Job.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoApplication_Job.ipynb.

# %% auto 0
__all__ = ['DomoTrigger_Schedule', 'DomoTrigger', 'DomoJob', 'RemoteDomoStats_Config_Policy', 'RemoteDomoStats_Config',
           'DomoJob_RemoteDomoStats', 'Watchdog_Config', 'Watchdog_Config_MaxIndexingTime', 'Watchdog_Config__Variance',
           'Watchdog_Config_RowCountVariance', 'Watchdog_Config_ExecutionVariance', 'Watchdog_Config_ErrorDetection',
           'Watchdog_Config_LastDataUpdated', 'Watchdog_Config_CustomQuery', 'Watchdog_ConfigFactory',
           'DomoJob_Watchdog']

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 3
from dataclasses import dataclass, field
from abc import ABC, abstractmethod

from typing import List, Optional
from enum import Enum

import httpx

from nbdev.showdoc import patch_to

import domolibrary.client.DomoAuth as dmda
import datetime as dt

from pprint import pprint

import domolibrary.routes.application as application_routes

import domolibrary.utils.convert as cc

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 5
@dataclass
class DomoTrigger_Schedule:
    schedule_text: str = None
    schedule_type: str = "scheduleTriggered"

    minute: int = None
    hour: int = None
    minute_str: str = None
    hour_str: str = None

    @classmethod
    def _from_str(cls, s_text, s_type):
        sched = cls(schedule_type=s_type, schedule_text=s_text)

        try:
            parsed_hour = s_text.split(" ")[2]
            parsed_minute = s_text.split(" ")[1]

            if "*" in parsed_hour or "/" in parsed_hour:
                sched.hour_str = parsed_hour
            else:
                sched.hour = int(float(parsed_hour))
            if "*" in parsed_minute:
                sched.minute_str = parsed_minute
            else:
                sched.minute = int(float(parsed_minute))

            return sched

        except Exception as e:
            print(f"unable to parse schedule {s_text}")
            print(e)

    def to_obj(self):
        return {"hour": int(self.hour), "minute": int(self.minute)}

    def to_json(self):
        minute = self.minute_str if self.minute_str is not None else str(self.minute)
        hour = self.hour_str if self.hour_str is not None else str(self.hour)
        return {
            "eventEntity": f"0 {minute} {hour} ? * *",
            # old value on Jan 13
            # "eventEntity": f'0 {minute} {hour} 1/1 * ? *',
            "eventType": self.schedule_type,
        }


@dataclass
class DomoTrigger:
    id: str
    job_id: str
    schedule: List[DomoTrigger_Schedule] = None

    @classmethod
    def _from_json(cls, obj):
        return cls(
            id=obj["triggerId"],
            job_id=obj["jobId"],
            schedule=DomoTrigger_Schedule._from_str(
                s_text=obj.get("eventEntity"), s_type=obj.get("eventType")
            ),
        )

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 7
@dataclass
class DomoJob:
    """
    the base class only captures attributes applicable to all jobs (i.e. does not destructure execution_payload onto the class)
    build Application / Job extensions by creating children of the DomoJob class
    """

    auth: dmda.DomoAuth = field(repr=False)

    name: str
    application_id: str

    logs_dataset_id: str = None
    id: str = None
    user_id: str = None
    execution_timeout: int = 1440

    is_enabled: bool = False  # based on triggers
    customer_id: str = None
    created_dt: dt.datetime = None
    updated_dt: dt.datetime = None

    description: str = None

    execution_payload: dict = field(default_factory=lambda: {})
    share_state: dict = field(default_factory=lambda: {})
    accounts: List[str] = field(default_factory=[])
    triggers: List[DomoTrigger] = field(default_factory=[])

    @staticmethod
    def _format_remote_instance(remote_instance):
        if not remote_instance:
            return remote_instance

        return remote_instance.replace(".domo.com", "")

    @staticmethod
    def _convert_API_res_to_DomoJob_base_obj(obj) -> dict:
        """base class for converting an API response into a dictionary with parameters that DomoJob expects"""

        triggers_ls = obj.get("triggers")
        domo_triggers = (
            [DomoTrigger._from_json(tg) for tg in triggers_ls] if triggers_ls else []
        )

        return {
            "id": obj["jobId"],
            "name": obj["jobName"],
            "user_id": obj["userId"],
            "application_id": obj["applicationId"],
            "customer_id": obj["customerId"],
            "execution_timeout": obj["executionTimeout"],
            "execution_payload": obj["executionPayload"],
            "logs_dataset_id": obj["executionPayload"]["metricsDatasetId"],
            "share_state": obj.get("shareState", {}),
            "created_dt": cc.convert_epoch_millisecond_to_datetime(obj["created"]),
            "updated_dt": cc.convert_epoch_millisecond_to_datetime(obj["updated"]),
            "is_enabled": True if triggers_ls else False,
            "description": obj.get("jobDescription"),
            "accounts": obj.get("accounts"),
            "triggers": domo_triggers,
        }

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 8
@patch_to(DomoJob, cls_method=True)
def _from_json(
    cls,
    obj,
    auth,
):
    """_from_json is a required abstract method.  Each DomoJob implementation must have an instance of _from_json"""

    base_obj = cls._convert_API_res_to_DomoJob_base_obj(obj=obj)

    return cls(
        auth=auth,
        **base_obj,
    )


@patch_to(DomoJob, cls_method=True)
async def _get_by_id(
    cls,
    application_id,
    job_id,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    session: Optional[httpx.AsyncClient] = None,
    debug_num_stacks_to_drop=2,
    new_cls: DomoJob = None,  # pass in a child class which has the mandatory "from_json" function
    return_raw: bool = False,
    parent_class=None,
):
    """
    this function will receive the parent_class as an input_parameter (instead of relying on the actual class DomoJob)
    to call the `new_class._from_json()`

    this process will handle converting the JSON obj into 'the correct' class
    """

    res = await application_routes.get_application_job_by_id(
        auth=auth,
        application_id=application_id,
        job_id=job_id,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    cls = new_cls or cls

    return cls._from_json(
        obj=res.response,
        auth=auth,
    )


@patch_to(DomoJob, cls_method=True)
async def get_by_id(
    cls,
    application_id,
    job_id,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    session: Optional[httpx.AsyncClient] = None,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
):
    """
    stub abstract function that each `DomoJob` will have.
    note we pass the calling functions class into classmethod _get_by_id()
    so that we can call cls._from_json() during code execution
    """

    return await cls._get_by_id(
        application_id=application_id,
        job_id=job_id,
        auth=auth,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        return_raw=return_raw,
        new_cls=cls,
    )

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 9
@patch_to(DomoJob, cls_method=True)
async def get_by_id(
    cls,
    application_id,
    job_id,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    session: Optional[httpx.AsyncClient] = None,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
):
    """
    stub abstract function that each `DomoJob` will have.
    note we pass the calling functions class into classmethod _get_by_id()
    so that we can call cls._from_json() during code execution
    """

    return await cls._get_by_id(
        application_id=application_id,
        job_id=job_id,
        auth=auth,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        return_raw=return_raw,
        new_cls=cls,
    )

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 10
@patch_to(DomoJob)
def _generate_to_json(self) -> dict:
    """returns a base dictionary representation of the DomoJob class"""

    trigger_ls = [self.triggers[0].schedule.to_json()] if len(self.triggers) > 0 else []

    execution_payload = self.execution_payload or {}
    execution_payload.update({"metricsDatasetId": self.logs_dataset_id})

    return {
        "jobId": self.id,
        "jobName": self.name,
        "userId": self.user_id,
        "applicationId": self.application_id,
        "customerId": self.customer_id,
        "executionTimeout": self.execution_timeout,
        "executionPayload": execution_payload,
        "shareState": self.share_state,
        # created / excluded because generated metadata
        # updated / excluded because generated metadata
        "triggers": trigger_ls,
        "jobDescription": self.description,
        "executionTimeout": self.execution_timeout,
        "accounts": self.accounts,
    }


@patch_to(DomoJob)
def to_json(self):
    """this is an abstract method, each DomoJob implementation must define a to_json() function"""
    return self._generate_to_json()

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 13
@dataclass
class RemoteDomoStats_Config_Policy:
    type: str
    dataset_id: str

    def to_json(self):
        return {self.type: self.dataset_id}

    def __eq__(self, other) -> bool:
        if not isinstance(other, RemoteDomoStats_Config_Policy):
            return False

        return self.type == other.type


@dataclass
class RemoteDomoStats_Config:
    policies: List[RemoteDomoStats_Config_Policy] = field(default_factory=lambda: [])

    def _add_policy(self, report_type, dataset_id):
        new_policy = RemoteDomoStats_Config_Policy(
            type=report_type, dataset_id=dataset_id
        )

        if new_policy not in self.policies:
            self.policies.append(new_policy)

        else:
            policy_index = self.policies.index(new_policy)
            self.policies[policy_index] = new_policy

        return self.policies

    @classmethod
    def _from_json(cls, obj):
        domo_policies = cls()
        [
            domo_policies._add_policy(report_type, dataset_id)
            for report_type, dataset_id in obj.items()
        ]
        return domo_policies

    def to_json(self):
        return {
            report_type: dataset_id
            for policy in self.policies
            for report_type, dataset_id in policy.to_json().items()
        }

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 14
@dataclass
class DomoJob_RemoteDomoStats(DomoJob):
    remote_instance: str = None
    subscriber_job_id: str = None

    config: RemoteDomoStats_Config = None

    @classmethod
    def _from_json(cls, obj, auth):

        return cls(
            **cls._convert_API_res_to_DomoJob_base_obj(obj),
            remote_instance=cls._format_remote_instance(
                obj["executionPayload"]["remoteInstance"]
            ),
            subscriber_job_id=obj["executionPayload"]["subscriberJobId"],
            auth=auth,
            config=RemoteDomoStats_Config._from_json(
                obj["executionPayload"]["policies"]
            )
        )

    @classmethod
    async def get_by_id(
        cls,
        application_id,
        job_id,
        auth: dmda.DomoAuth,
        debug_api: bool = False,
        session: Optional[httpx.AsyncClient] = None,
        debug_num_stacks_to_drop=2,
        return_raw: bool = False,
    ):

        return await cls._get_by_id(
            application_id=application_id,
            job_id=job_id,
            auth=auth,
            debug_api=debug_api,
            session=session,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            return_raw=return_raw,
            new_cls=cls,
            parent_class=cls.__name__,
        )

    def to_json(self):

        s = self._generate_to_json()

        s["executionPayload"].update(
            {
                "policies": self.config.to_json(),
                "remoteInstance": self.remote_instance,
                "subscriberJobId": self.subscriber_job_id,
            }
        )

        return s

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 18
@patch_to(DomoJob_RemoteDomoStats, cls_method=True)
async def create(
    cls,
    auth: dmda.DomoAuth,
    name: str,
    config: RemoteDomoStats_Config,
    application_id: str,
    logs_dataset_id: str,
    description: str = f"created via domolibrary f{dt.date.today()}",
    remote_instance: str = None,
    accounts: List[int] = None,
    triggers: List[DomoTrigger_Schedule] = None,
    execution_timeout: int = 1440,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: Optional[httpx.AsyncClient] = None,
):

    triggers_ls = []
    if triggers is not None and len(triggers) > 0:
        triggers_ls = [
            DomoTrigger(id=None, job_id=None, schedule=schedule)
            for schedule in triggers
        ]

    domo_job = cls(
        application_id=application_id,
        auth=auth,
        name=name,
        logs_dataset_id=logs_dataset_id,
        accounts=accounts,
        description=description,
        remote_instance=remote_instance,
        config=config,
        triggers=triggers_ls,
        execution_timeout=execution_timeout,
    )

    body = domo_job.to_json()

    res = await application_routes.create_application_job(
        auth=auth,
        application_id=application_id,
        body=body,
        parent_class=cls.__name__,
        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    return cls._from_json(res.response, auth=auth)

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 21
@dataclass
class Watchdog_Config(ABC):
    entity_ids: List[str]
    entity_type: str  # dataflow or dataset
    watcher_parameters: dict
    report_type: str

    """base class for the different watchdog report types"""

    @classmethod
    def _from_json(cls, watcher_parameters_obj):  # executionPayload

        return cls(
            entity_ids=watcher_parameters_obj["entityIds"],
            entity_type=watcher_parameters_obj["entityType"],
            report_type=watcher_parameters_obj["type"],
            watcher_parameters=watcher_parameters_obj,
        )

    def _to_json(self):
        return {
            "entityIds": self.entity_ids,
            "entityType": self.entity_type,
            "type": self.report_type,
        }

    @abstractmethod
    def to_json(self):
        return self._to_json()

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 22
@dataclass
class Watchdog_Config_MaxIndexingTime(Watchdog_Config):
    report_type = "max_indexing_time"
    max_indexing_time_mins = 30

    def __post_init__(self):
        self.max_indexing_time_mins = self.watcher_parameters[
            "maxIndexingTimeInMinutes"
        ]

    def to_json(self, **kwargs):
        if kwargs.get("max_indexing_time_mins"):
            self.max_indexing_time_mins = kwargs["max_indexing_time_mins"]

        return {
            **self._to_json(),
            "maxIndexingTimeInMinutes": self.max_indexing_time_mins,
        }


@dataclass
class Watchdog_Config__Variance(Watchdog_Config):
    report_type: str
    variance_percent: int = 10

    def __post_init__(self):
        self.variance_percent = self.watcher_parameters["variancePercent"]

    def to_json(self, **kwargs):
        if kwargs.get("variance_percent"):
            self.variance_percent = kwargs["variance_percent"]

        return {
            **self._to_json(),
            "variancePercent": self.variance_percent,
        }


@dataclass
class Watchdog_Config_RowCountVariance(Watchdog_Config__Variance):
    report_type = "row_count_variance"


@dataclass
class Watchdog_Config_ExecutionVariance(Watchdog_Config__Variance):
    report_type = "execution_variance"


@dataclass
class Watchdog_Config_ErrorDetection(Watchdog_Config):
    report_type: str = "error_detection"

    def to_json(self, **kwargs):
        return {
            **self._to_json(),
        }


@dataclass
class Watchdog_Config_LastDataUpdated(Watchdog_Config):
    report_type: str = "last_data_updated"
    min_data_update_frequency_in_mins: int = 10

    def __post_init__(self):
        self.min_data_update_frequency_in_mins = self.watcher_parameters[
            "minDataUpdateFrequencyInMinutes"
        ]

    def to_json(self, **kwargs):
        if kwargs.get("min_data_update_frequency_in_mins"):
            self.min_data_update_frequency_in_mins = kwargs[
                "min_data_update_frequency_in_mins"
            ]

        return {
            **self._to_json(),
            "minDataUpdateFrequencyInMinutes": self.min_data_update_frequency_in_mins,
        }


@dataclass
class Watchdog_Config_CustomQuery(Watchdog_Config):
    report_type: str = "custom_query"
    sql_query: str = ""

    def __post_init__(self):
        self.sql_query = self.watcher_parameters["sqlQuery"]

    def to_json(self, **kwargs):
        if kwargs.get("sql_query"):
            self.sql_query = kwargs["sql_query"]

        return {
            **self._to_json(),
            "sqlQuery": self.sql_query,
        }

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 23
class Watchdog_ConfigFactory(Enum):
    MAX_INDEXING_TIME = Watchdog_Config_MaxIndexingTime
    ROW_COUNT_VARIANCE = Watchdog_Config_RowCountVariance
    EXECUTION_VARIANCE = Watchdog_Config_ExecutionVariance
    ERROR_DETECTION = Watchdog_Config_ErrorDetection
    LAST_DATA_UPDATED = Watchdog_Config_LastDataUpdated
    CUSTOM_QUERY = Watchdog_Config_CustomQuery

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 25
@dataclass
class DomoJob_Watchdog(DomoJob):
    custom_message: str = None
    remote_instance: str = None

    notify_emails: List[str] = field(default_factory=lambda: [])
    notify_group_ids: List[str] = field(default_factory=lambda: [])
    notify_user_ids: List[str] = field(default_factory=lambda: [])

    config: Watchdog_Config = None
    webhooks: List[str] = None

    @classmethod
    def _from_json(cls, obj, auth):

        remote_instance = cls._format_remote_instance(
            obj["executionPayload"].get("domain")
        )

        watchdog_parameters_obj = obj["executionPayload"]["watcherParameters"]

        config = Watchdog_ConfigFactory[
            watchdog_parameters_obj["type"].upper()
        ].value._from_json(watchdog_parameters_obj)

        return cls(
            **cls._convert_API_res_to_DomoJob_base_obj(obj),
            remote_instance=remote_instance,
            custom_message=obj["executionPayload"]["customMessage"],
            config=config,
            notify_emails=obj["executionPayload"]["notifyEmailAddresses"],
            notify_group_ids=obj["executionPayload"]["notifyGroupIds"],
            notify_user_ids=obj["executionPayload"]["notifyUserIds"],
            webhooks=obj["executionPayload"]["webhooks"],
            auth=auth
        )

    @classmethod
    async def get_by_id(
        cls,
        application_id,
        job_id,
        auth: dmda.DomoAuth,
        debug_api: bool = False,
        session: Optional[httpx.AsyncClient] = None,
        debug_num_stacks_to_drop=2,
        return_raw: bool = False,
    ):

        return await cls._get_by_id(
            application_id=application_id,
            job_id=job_id,
            auth=auth,
            debug_api=debug_api,
            session=session,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            return_raw=return_raw,
            new_cls=cls,
            parent_class=cls.__name__,
        )

    def to_json(self):
        s = self._generate_to_json()

        s["executionPayload"].update(
            {
                "customMessage": self.custom_message,
                "domain": self.remote_instance,
                "notifyEmailAddresses": self.notify_emails,
                "notifyGroupIds": self.notify_group_ids,
                "notifyUserIds": self.notify_user_ids,
                "watcherParameters": self.config.to_json(),
                "webhooks": self.webhooks,
            }
        )
        return s

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 28
@patch_to(DomoJob)
async def update(
    self: DomoJob,
    debug_api: bool = False,
    session: Optional[httpx.AsyncClient] = None,
    debug_num_stacks_to_drop=2,
):

    res = await application_routes.update_application_job(
        auth=self.auth,
        body=self.to_json(),
        application_id=self.application_id,
        job_id=self.id,
        debug_api=debug_api,
        session=session,
        parent_class=self.__class__.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    return res

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 31
@patch_to(DomoJob)
async def execute(
    self,
    debug_api: bool = False,
    session: Optional[httpx.AsyncClient] = None,
    debug_num_stacks_to_drop=2,
):

    res = await application_routes.execute_application_job(
        auth=self.auth,
        application_id=self.application_id,
        job_id=self.id,
        debug_api=debug_api,
        session=session,
        parent_class=self.__class__.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    return res

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 34
@patch_to(DomoJob_Watchdog, cls_method=True)
async def create(
    cls,
    auth: dmda.DomoAuth,
    name: str,
    application_id: str,
    config: Watchdog_Config,
    logs_dataset_id: str,
    notify_user_ids: list = None,
    notify_group_ids: list = None,
    notify_emails: list = None,
    triggers: List[DomoTrigger_Schedule] = None,
    description: str = f"created via domolibrary - {dt.date.today()}",
    execution_timeout=1440,
    accounts: list[int] = None,
    remote_instance=None,
    custom_message: str = None,
    webhooks: List[str] = None,
    debug_api: bool = False,
    session: Optional[httpx.AsyncClient] = None,
    return_raw: bool = False,
):

    domo_job = cls(
        auth=auth,
        name=name,
        description=description,
        application_id=application_id,
        execution_timeout=execution_timeout,
        notify_user_ids=notify_user_ids or [],
        notify_group_ids=notify_group_ids or [],
        notify_emails=notify_emails or [],
        triggers=triggers or [],
        accounts=accounts or [],
        logs_dataset_id=logs_dataset_id,
        remote_instance=remote_instance,
        config=config,
        custom_message=custom_message,
        webhooks=webhooks,
    )

    body = domo_job.to_json()

    res = await application_routes.create_application_job(
        auth=auth,
        application_id=application_id,
        body=body,
        debug_api=debug_api,
        session=session,
    )

    if return_raw:
        return res

    return cls._from_json(res.response, auth=auth)

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoBootstrap.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoBootstrap.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoBootstrap.ipynb.

# %% auto 0
__all__ = ['DomoBootstrap_Feature', 'DomoBootstrap']

# %% ../../nbs/classes/50_DomoBootstrap.ipynb 2
from ..routes.bootstrap import InvalidAuthTypeError

# %% ../../nbs/classes/50_DomoBootstrap.ipynb 3
from dataclasses import dataclass, field
from nbdev.showdoc import patch_to
import httpx

import domolibrary.classes.DomoPage as dmpg

import domolibrary.utils.DictDot as util_dd
import domolibrary.client.DomoAuth as dmda
import domolibrary.routes.bootstrap as bootstrap_routes
import domolibrary.utils.chunk_execution as ce

# %% ../../nbs/classes/50_DomoBootstrap.ipynb 5
@dataclass
class DomoBootstrap_Feature:
    id: int
    name: str
    label: str
    type: str
    purchased: bool
    enabled: bool

    @classmethod
    def _from_json_bootstrap(cls, json_obj: dict):
        dd = util_dd.DictDot(json_obj)

        bsf = cls(
            id=dd.id,
            name=dd.name,
            label=dd.label,
            type=dd.type,
            purchased=dd.purchased,
            enabled=dd.enabled,
        )
        return bsf

# %% ../../nbs/classes/50_DomoBootstrap.ipynb 6
@dataclass
class DomoBootstrap:
    auth: dmda.DomoAuth = field(repr=False)
    bootstrap: dict = field(default=None)
    customer_id: str = None
    page_ls: list[dmpg.DomoPage] = field(default=None)
    feature_ls: list[DomoBootstrap_Feature] = field(default=None)

# %% ../../nbs/classes/50_DomoBootstrap.ipynb 7
@patch_to(DomoBootstrap)
async def get_all(
    self: DomoBootstrap,
    auth: dmda.DomoFullAuth = None,
    debug_api: bool = False,
    return_raw: bool = False,
    debug_num_stacks_to_drop=2,
):
    auth = auth or self.auth

    res = await bootstrap_routes.get_bootstrap(
        auth=auth,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
    )

    self.bootstrap = res.response

    if return_raw:
        return res

    return res.response

# %% ../../nbs/classes/50_DomoBootstrap.ipynb 10
@patch_to(DomoBootstrap)
async def get_customer_id(
    self: DomoBootstrap,
    auth: dmda.DomoFullAuth = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=3,
    return_raw: bool = False,
):
    res = await bootstrap_routes.get_bootstrap_customerid(
        auth=auth or self.auth,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        return_raw=return_raw,
        parent_class=self.__class__.__name__,
    )

    if return_raw:
        return res

    self.customer_id = res.response

    return self.customer_id

# %% ../../nbs/classes/50_DomoBootstrap.ipynb 13
@patch_to(DomoBootstrap)
async def get_pages(
    self: DomoBootstrap,
    auth: dmda.DomoFullAuth = None,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
) -> list[dmpg.DomoPage]:
    auth = auth or self.auth

    res = await bootstrap_routes.get_bootstrap_pages(
        auth=auth,
        debug_api=debug_api,
        parent_class=self.__class__.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    if not res.is_success:
        return None

    self.page_ls = await ce.gather_with_concurrency(
        n=60,
        *[
            dmpg.DomoPage._from_bootstrap(page_obj, auth=auth)
            for page_obj in res.response
        ]
    )

    return self.page_ls

# %% ../../nbs/classes/50_DomoBootstrap.ipynb 16
@patch_to(DomoBootstrap)
async def get_features(
    self: DomoBootstrap,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    return_raw: bool = False,
    debug_num_stacks_to_drop=2,
    session: httpx.AsyncClient = None,
):
    auth = auth or self.auth

    res = await bootstrap_routes.get_bootstrap_features(
        auth=auth,
        session=session,
        debug_api=debug_api,
        return_raw=return_raw,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
    )

    if return_raw:
        return res

    feature_list = [
        DomoBootstrap_Feature._from_json_bootstrap(json_obj)
        for json_obj in res.response
    ]

    return feature_list

# %% ../../nbs/classes/50_DomoBootstrap.ipynb 19
@patch_to(DomoBootstrap)
async def is_feature_accountsv2_enabled(
    self: DomoBootstrap,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    return_raw: bool = False,
    debug_num_stacks_to_drop=3,
):
    res = await bootstrap_routes.get_bootstrap_features_is_accountsv2_enabled(
        auth=auth or self.auth,
        return_raw=return_raw,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
    )

    if return_raw:
        return res

    return res.response

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoCard.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoCard.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoCard.ipynb.

# %% auto 0
__all__ = ['DomoCard']

# %% ../../nbs/classes/50_DomoCard.ipynb 2
from dataclasses import dataclass, field
from typing import List

import asyncio
import httpx
from nbdev.showdoc import patch_to

import domolibrary.utils.DictDot as util_dd
import domolibrary.utils.chunk_execution as ce

import domolibrary.routes.card as card_routes

import domolibrary.client.DomoAuth as dmda

# %% ../../nbs/classes/50_DomoCard.ipynb 4
@dataclass
class DomoCard:
    id: str
    auth: dmda.DomoAuth = field(repr=False)
    title: str = None
    description: str = None
    type: str = None
    urn: str = None
    chart_type: str = None
    dataset_id: str = None

    certification: dict = None
    owners: List[any] = None

    def __post_init__(self):
        # self.Definition = CardDefinition(self)
        pass

    def display_url(self) -> str:
        return f"https://{self.auth.domo_instance}.domo.com/kpis/details/{self.id}"

    @classmethod
    async def _from_json(cls, card_obj, auth: dmda.DomoAuth):
        import domolibrary.classes.DomoUser as dmu
        import domolibrary.classes.DomoGroup as dmg

        dd = card_obj
        if isinstance(card_obj, dict):
            dd = util_dd.DictDot(card_obj)

        card = cls(
            auth=auth,
            id=dd.id,
            title=dd.title,
            description=dd.description,
            type=dd.type,
            urn=dd.urn,
            certification=dd.certification,
            chart_type=dd.metadata and dd.metadata.chartType,
            dataset_id=dd.datasources[0].dataSourceId if dd.datasources else None,
        )

        tasks = []
        for user in dd.owners:
            if user.type == "USER":
                tasks.append(dmu.DomoUser.get_by_id(user_id=user.id, auth=auth))
            if user.type == "GROUP":
                tasks.append(dmg.DomoGroup.get_by_id(group_id=user.id, auth=auth))

        card.owners = await ce.gather_with_concurrency(n=60, *tasks)

        return card

# %% ../../nbs/classes/50_DomoCard.ipynb 5
@patch_to(DomoCard, cls_method=True)
async def get_by_id(
    cls: DomoCard,
    card_id: str,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    res = await card_routes.get_card_metadata(
        auth=auth, card_id=card_id, debug_api=debug_api, session=session
    )

    if not res.is_success:
        raise Exception("unable to retrieve card {card_id}")

    domo_card = await cls._from_json(res.response, auth)

    return domo_card

# %% ../../nbs/classes/50_DomoCard.ipynb 7
@patch_to(DomoCard)
async def share(
    self: DomoCard,
    auth: dmda.DomoAuth = None,
    domo_users: list = None,  # DomoUsers to share card with,
    domo_groups: list = None,  # DomoGroups to share card with
    message: str = None,  # message for automated email
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    import domolibrary.routes.datacenter as datacenter_routes

    if domo_groups:
        domo_groups = domo_groups if isinstance(domo_groups, list) else [domo_groups]
    if domo_users:
        domo_users = domo_users if isinstance(domo_users, list) else [domo_users]

    res = await datacenter_routes.share_resource(
        auth=auth or self.auth,
        resource_ids=[self.id],
        resource_type=datacenter_routes.ShareResource_Enum.CARD,
        group_ids=[group.id for group in domo_groups] if domo_groups else None,
        user_ids=[user.id for user in domo_users] if domo_users else None,
        message=message,
        debug_api=debug_api,
        session=session,
    )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoCertification.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoCertification.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoCertification.ipynb.

# %% auto 0
__all__ = []

# %% ../../nbs/classes/50_DomoCertification.ipynb 2
import datetime as dt
from dataclasses import dataclass
from enum import Enum
import domolibrary.utils.convert as cd
import domolibrary.utils.DictDot as util_dd


class DomoCertificationState(Enum):
    CERTIFIED = "certified"
    PENDING = "PENDING"


@dataclass
class DomoCertification:
    certification_state: DomoCertificationState
    last_updated: dt.datetime
    certification_type: str
    certification_name: str

    @classmethod
    def _from_json(cls, obj):
        dd = util_dd.DictDot(obj) if isinstance(obj, dict) else obj
        return cls(
            certification_state=DomoCertificationState[dd.state].value or dd.state,
            last_updated=cd.convert_epoch_millisecond_to_datetime(dd.lastUpdated),
            certification_type=dd.processType,
            certification_name=dd.processName,
        )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoCodeEngine.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoCodeEngine.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoCodeEngine.ipynb.

# %% auto 0
__all__ = ['DomoCodeEngine_ConfigError', 'DomoCodeEngine_Function', 'DomoCodeEngine_Version', 'DomoCodeEngine_Package']

# %% ../../nbs/classes/50_DomoCodeEngine.ipynb 2
from ..routes.codeengine import extract_functions

# %% ../../nbs/classes/50_DomoCodeEngine.ipynb 3
import os

from dataclasses import dataclass, field
from enum import Enum
from typing import List, Callable
import datetime as dt

from io import open
import httpx

from nbdev.showdoc import patch_to

import domolibrary.client.DomoAuth as dmda

import domolibrary.routes.codeengine as codeengine_routes
import domolibrary.client.DomoError as de
import domolibrary.utils.files as dmuf
from domolibrary.utils.convert import convert_string_to_datetime
import domolibrary.classes.DomoUser as dmdu

# %% ../../nbs/classes/50_DomoCodeEngine.ipynb 6
class DomoCodeEngine_ConfigError(de.DomoError):
    def __init__(
        self,
        domo_instance,
        package_id,
        version=None,
        message=None,
        status=None,
        function_name=None,
    ):
        super().__init__(
            entity_id=package_id,
            message=f"verion {version} | {message}" if version else message,
            status=status,
            domo_instance=domo_instance,
            function_name=function_name,
        )


@dataclass
class DomoCodeEngine_Function:
    name: str
    displayName: str
    description: str
    language: str
    package_id: str = field(repr=False)
    version: str = field(repr=False)

    code: str = None
    code_prefix: str = None
    inputs: List[dict] = field(repr=False, default=None)
    output: str = field(repr=False, default=None)
    example: str = field(repr=False, default=None)
    code_raw: str = field(repr=False, default=None)

    @classmethod
    def _from_json(cls, obj, language, package_id, version, code_raw=None):
        return cls(
            **obj,
            language=language,
            package_id=package_id,
            version=version,
            code_raw=code_raw,
        )

    def __eq__(self, other):
        if not isinstance(other, DomoCodeEngine_Function):
            return False

        if (
            self.version != other.version
            or self.package_id != other.package_id
            or self.name != other.name
        ):
            return False

        return True

    def export(
        self,
        file_name: str = None,
        output_folder: str = "EXPORT/code_engine/",
        debug_prn: bool = False,
    ):

        if not file_name:
            file_name = f"{self.package_id}/{self.version}/{self.name}"

        file_name = dmuf.change_extension(
            file_name, ExportExtension[self.language].value
        )

        output_folder = (
            f"{output_folder}/" if not output_folder.endswith("/") else output_folder
        )

        file_path = os.path.join(output_folder, file_name)
        dmuf.upsert_folder(file_path)

        if debug_prn:
            print(output_folder, file_name)

        with open(file_path, "w+", newline="\n", encoding="utf-8") as f:
            f.write(self.code)

        return file_path

# %% ../../nbs/classes/50_DomoCodeEngine.ipynb 7
@dataclass
class DomoCodeEngine_Version:
    auth: dmda.DomoAuth = field(repr=False)
    package_id: str
    version: str
    language: str
    description: str
    createdby_id: int
    released_dt: dt.datetime
    configuration: dict

    createdby: dmdu.DomoUser = None
    accounts_mapping: List[int] = None
    ml_model: List[str] = None

    code: str = field(repr=False, default=None)
    functions_ls: List[dict] = field(repr=False, default=None)
    functions: dict = None

    def _set_configuration(self, configuration=None):
        if configuration:
            self.configuration = configuration

        if not self.configuration:
            raise DomoCodeEngine_ConfigError(
                package_id=self.package_id,
                version=self.version,
                message="unable to set configuration",
                domo_instance=self.auth.domo_instance,
            )

        self.accounts_mapping = self.configuration["accountsMapping"]
        self.ml_model = self.configuration["mlModel"]

        return self

    def set_functions(
        self,
        code: str = None,
        functions: List[dict] = None,
        language: str = None,
        function_parser_fn: Callable = None,  # must receive code string, function_ls, language
    ):
        self.code = code or self.code

        self.functions_ls = functions or self.functions_ls

        self.language = language or self.language

        if not self.code or not self.configuration or not self.language:
            raise DomoCodeEngine_ConfigError(
                package_id=self.package_id,
                version=self.version,
                message="unable to set functions",
                domo_instance=self.auth.domo_instance,
            )
        try:
            function_parser_fn = function_parser_fn or extract_functions
            functions_ls = function_parser_fn(
                code=self.code, function_ls=self.functions_ls, language=self.language
            )

            self.functions = [
                DomoCodeEngine_Function._from_json(
                    obj,
                    language=self.language,
                    package_id=self.package_id,
                    version=self.version,
                    code_raw=self.code,
                )
                for obj in functions_ls
            ]
            return functions
        except Exception as e:
            print(e)
            raise DomoCodeEngine_ConfigError(
                package_id=self.package_id,
                version=self.version,
                message=e,
                domo_instance=self.auth.domo_instance,
            )

    @classmethod
    def _from_json(
        cls,
        obj: dict,
        package_id,
        auth: dmda.DomoAuth,
        language: str,
        supress_error: bool = True,
    ):

        domo_version = cls(
            auth=auth,
            package_id=package_id,
            language=language.upper() if language else None,
            version=obj["version"],
            code=obj.get("code"),
            description=obj.get("description", None),
            createdby_id=obj["createdBy"],
            released_dt=convert_string_to_datetime(obj.get("releasedOn")),
            configuration=obj["configuration"],
            functions_ls=obj["functions"],
        )

        try:
            domo_version._set_configuration()

        except DomoCodeEngine_ConfigError as e:
            if not supress_error:
                print(e)

        try:
            domo_version.set_functions()
        except DomoCodeEngine_ConfigError as e:
            if not supress_error:
                print(e)

        return domo_version

    @classmethod
    async def get_by_id_and_version(
        cls,
        package_id,
        version,
        auth: dmda.DomoAuth,
        language: str = None,
        debug_api: bool = False,
        debug_num_stacks_to_drop=2,
        return_raw: bool = False,
        session: httpx.AsyncClient = None,
    ):

        res = await codeengine_routes.get_codeengine_package_by_id_and_version(
            package_id=package_id,
            version=version,
            auth=auth,
            debug_api=debug_api,
            session=session,
            parent_class=cls.__name__,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        )

        if return_raw:
            return res

        return cls._from_json(
            auth=auth, obj=res.response, package_id=package_id, language=language
        )

    def __eq__(self, other):
        if not isinstance(other, DomoCodeEngine_Version):
            return False

        if self.version != other.version or self.package_id != other.package_id:
            return False

        return True

# %% ../../nbs/classes/50_DomoCodeEngine.ipynb 10
class ExportExtension(Enum):
    JAVASCRIPT = "js"
    PYTHON = "py"


@patch_to(DomoCodeEngine_Version)
def export(
    self,
    file_name: str = None,
    output_folder: str = "EXPORT/code_engine/",
    debug_prn: bool = False,
):
    output_folder = (
        f"{output_folder}/" if not output_folder.endswith("/") else output_folder
    )

    dmuf.upsert_folder(output_folder)

    file_name = file_name or self.package_id
    file_name = dmuf.change_extension(file_name, ExportExtension[self.language].value)

    file_path = os.path.join(output_folder, file_name)

    if debug_prn:
        print(output_folder, file_name)

    with open(file_path, "w+", newline="\n", encoding="utf-8") as f:
        f.write(self.code)

    return file_path

# %% ../../nbs/classes/50_DomoCodeEngine.ipynb 12
@dataclass
class DomoCodeEngine_Package:
    auth: dmda.DomoAuth = field(repr=False)
    id: str
    name: str
    description: str
    language: str
    environment: str
    availability: str
    owner_id: int
    created: dt.datetime
    last_modified: dt.datetime
    functions: List

    current_version: str = None
    versions: List[DomoCodeEngine_Version] = None
    owner: List[dmdu.DomoUser] = None

    def __post_init__(self):
        self._set_current_version()

    def _set_current_version(self):
        if not self.versions:
            return

        versions = [version.version for version in self.versions]
        self.current_version = max(versions)

    @classmethod
    def from_packages_api(cls, obj, auth):
        package_id = obj["id"]
        language = obj["language"]
        versions = [
            DomoCodeEngine_Version._from_json(
                version, package_id=package_id, language=language, auth=auth
            )
            for version in obj.get("versions")
        ]

        return cls(
            auth=auth,
            id=package_id,
            name=obj["name"],
            description=obj.get("description"),
            language=language,
            environment=obj.get("environment"),
            availability=obj.get("availability"),
            owner_id=obj.get("owner"),
            versions=versions,
            created=convert_string_to_datetime(obj.get("createdOn")),
            last_modified=convert_string_to_datetime(obj.get("updatedOn")),
            functions=obj.get("functions"),
        )

    @classmethod
    async def get_by_id(
        cls,
        auth: dmda.DomoAuth,
        package_id,
        debug_api: bool = False,
        session: httpx.AsyncClient = None,
        return_raw: bool = False,
        debug_num_stacks_to_drop=2,
    ):
        res = await codeengine_routes.get_codeengine_package_by_id(
            package_id,
            auth=auth,
            debug_api=debug_api,
            params=None,
            session=session,
            parent_class=cls.__name__,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        )
        if return_raw:
            return res

        return cls.from_packages_api(res.response, auth=auth)

    def __eq__(self, other):
        if not isinstance(other, DomoCodeEngine_Package):
            return False

        if self.id != other.id:
            return False

        return True

# %% ../../nbs/classes/50_DomoCodeEngine.ipynb 14
@patch_to(DomoCodeEngine_Package, cls_method=True)
async def get_current_version_by_id(
    cls,
    auth: dmda.DomoAuth,
    package_id,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=2,
):
    domo_package = await cls.get_by_id(
        package_id=package_id,
        auth=auth,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    current_version = domo_package.current_version

    domo_version = await DomoCodeEngine_Version.get_by_id_and_version(
        package_id=package_id,
        version=current_version,
        auth=auth,
        language=domo_package.language,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
    )

    return domo_version

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoDatacenter.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoDatacenter.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoDatacenter.ipynb.

# %% auto 0
__all__ = ['DomoDatacenter']

# %% ../../nbs/classes/50_DomoDatacenter.ipynb 2
import asyncio
from dataclasses import dataclass
from typing import Union, List
from enum import Enum

import httpx

from nbdev.showdoc import patch_to

import domolibrary.utils.chunk_execution as ce

import domolibrary.client.DomoAuth as dmda
import domolibrary.classes.DomoDataset as dmds
import domolibrary.classes.DomoAccount as dma
import domolibrary.classes.DomoCard as dmc

import domolibrary.routes.datacenter as datacenter_routes
import domolibrary.routes.card as card_routes

# %% ../../nbs/classes/50_DomoDatacenter.ipynb 4
@dataclass
class DomoDatacenter:
    "class for quering entities in the datacenter"
    auth: dmda.DomoAuth = None

# %% ../../nbs/classes/50_DomoDatacenter.ipynb 5
@patch_to(DomoDatacenter, cls_method=True)
async def search_datacenter(
    cls,
    auth: dmda.DomoAuth,
    maximum: int = None,  # maximum number of results to return
    body: dict = None,  # either pass a body or generate a body in the function using search_text, entity_type, and additional_filters parameters
    search_text=None,
    # can accept one value or a list of values
    entity_type: Union[str, list] = "dataset",
    additional_filters_ls=None,
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> list:

    res = await datacenter_routes.search_datacenter(
        auth=auth,
        maximum=maximum,
        body=body,
        session=session,
        search_text=search_text,
        entity_type=entity_type,
        additional_filters_ls=additional_filters_ls,
        debug_api=debug_api,
    )

    if return_raw:
        return res

    return res.response

# %% ../../nbs/classes/50_DomoDatacenter.ipynb 10
@patch_to(DomoDatacenter, cls_method=True)
async def search_datasets(
    cls,
    auth=dmda.DomoAuth,
    maximum: int = None,  # maximum number of results to return
    search_text=None,
    # can accept one value or a list of values
    additional_filters_ls=None,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
) -> list[dmds.DomoDataset]:

    json_list = await cls.search_datacenter(
        auth=auth,
        maximum=maximum,
        search_text=search_text,
        entity_type=datacenter_routes.Datacenter_Enum.DATASET.value,
        additional_filters_ls=additional_filters_ls,
        return_raw=return_raw,
        session=session,
        debug_api=debug_api,
    )

    if return_raw or len(json_list) == 0:
        return json_list

    return await ce.gather_with_concurrency(
        n=20,
        *[
            dmds.DomoDataset.get_from_id(
                dataset_id=json_obj.get("databaseId"),
                auth=auth,
                debug_api=debug_api,
                session=session,
            )
            for json_obj in json_list
        ]
    )

# %% ../../nbs/classes/50_DomoDatacenter.ipynb 13
@patch_to(DomoDatacenter, cls_method=True)
async def get_accounts(
    cls,
    auth=dmda.DomoAuth,
    maximum: int = None,  # maximum number of results to return
    # can accept one value or a list of values
    additional_filters_ls=None,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
) -> list[dma.DomoAccount]:
    """search Domo Datacenter account api.
    Note: at the time of this writing 7/18/2023, the datacenter api does not support searching accounts by name
    """

    json_list = await cls.search_datacenter(
        auth=auth,
        maximum=maximum,
        entity_type=datacenter_routes.Datacenter_Enum.ACCOUNT.value,
        additional_filters_ls=additional_filters_ls,
        return_raw=return_raw,
        session=session,
        debug_api=debug_api,
    )

    if return_raw or len(json_list) == 0:
        return json_list

    domo_account_ls = [
        dma.DomoAccount._from_json(json_obj, auth=auth) for json_obj in json_list
    ]

    return domo_account_ls

# %% ../../nbs/classes/50_DomoDatacenter.ipynb 16
class LineageTypes_Enum(Enum):
    DomoDataset = "DATA_SOURCE"
    DomoDataflow = "DATAFLOW"


@patch_to(DomoDatacenter, cls_method=True)
async def get_lineage_upstream(
    cls,
    auth: dmda.DomoAuth,
    domo_entity,  # DomoDataset or DomoDataflow
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_prn: bool = False,
):

    import domolibrary.classes.DomoDataset as dmds
    import domolibrary.classes.DomoDataflow as dmdf

    if not session:
        session = httpx.AsyncClient()
        is_close_session = True

    res = await datacenter_routes.get_lineage_upstream(
        auth=auth,
        entity_type=LineageTypes_Enum[domo_entity.__class__.__name__].value,
        entity_id=domo_entity.id,
        session=session,
        debug_api=debug_api,
    )

    if return_raw or res.status != 200:
        await session.aclose()
        return res

    obj = res.response

    domo_obj = []
    for key, item in obj.items():
        if item.get("type") == "DATA_SOURCE":
            domo_obj.append(
                await dmds.DomoDataset.get_from_id(
                    auth=auth, dataset_id=item.get("id"), session=session
                )
            )

        if item.get("type") == "DATAFLOW":
            # print(item.get('id'))
            domo_obj.append(
                await dmdf.DomoDataflow.get_from_id(
                    auth=auth, dataflow_id=item.get("id"), session=session
                )
            )
            pass

    if is_close_session:
        await session.aclose()
    return domo_obj

# %% ../../nbs/classes/50_DomoDatacenter.ipynb 18
@patch_to(DomoDatacenter, cls_method=True)
async def search_cards(
    cls,
    auth=dmda.DomoAuth,
    maximum: int = None,  # maximum number of results to return
    search_text=None,
    # can accept one value or a list of values
    additional_filters_ls=None,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
) -> list[dmds.DomoDataset]:

    json_list = await cls.search_datacenter(
        auth=auth,
        maximum=maximum,
        search_text=search_text,
        entity_type=datacenter_routes.Datacenter_Enum.CARD.value,
        additional_filters_ls=additional_filters_ls,
        return_raw=return_raw,
        session=session,
        debug_api=debug_api,
    )

    if return_raw or len(json_list) == 0:
        return json_list

    return await ce.gather_with_concurrency(
        n=60,
        *[
            dmc.DomoCard.get_by_id(
                card_id=json_obj.get("databaseId"),
                auth=auth,
                debug_api=debug_api,
                session=session,
            )
            for json_obj in json_list
        ]
    )

# %% ../../nbs/classes/50_DomoDatacenter.ipynb 20
@patch_to(DomoDatacenter, cls_method=True)
async def get_cards_admin_summary(
    cls,
    auth=dmda.DomoAuth,
    page_ids: List[str] = None,
    card_search_text: str = None,
    page_search_text: str = None,
    maximum: int = None,  # maximum number of results to return
    # can accept one value or a list of values
    return_raw: bool = False,
    debug_api: bool = False,
    debug_loop: bool = False,
    session: httpx.AsyncClient = None,
) -> list[dmc.DomoCard]:
    """search Domo Datacenter card api."""

    search_body = card_routes.generate_body_search_cards_admin_summary(
        page_ids=page_ids,
        card_search_text=card_search_text,
        page_search_text=page_search_text,
    )

    res = await card_routes.search_cards_admin_summary(
        auth=auth,
        body=search_body,
        maximum=maximum,
        debug_api=debug_api,
        debug_loop=debug_loop,
        session=session,
        wait_sleep=5,
    )

    if return_raw or len(res.response) == 0:
        return res

    domo_account_ls = await ce.gather_with_concurrency(
        n=60,
        *[dmc.DomoCard._from_json(json_obj, auth=auth) for json_obj in res.response]
    )

    return domo_account_ls

# %% ../../nbs/classes/50_DomoDatacenter.ipynb 24
@patch_to(DomoDatacenter, cls_method=True)
async def search_codeengine(
    cls,
    auth=dmda.DomoAuth,
    maximum: int = None,  # maximum number of results to return
    search_text=None,
    # can accept one value or a list of values
    additional_filters_ls=None,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
) -> list[dmds.DomoDataset]:

    import domolibrary.classes.DomoCodeEngine as dmce

    search_ls = await cls.search_datacenter(
        auth=auth,
        maximum=maximum,
        search_text=search_text,
        entity_type=datacenter_routes.Datacenter_Enum.PACKAGE.value,
        additional_filters_ls=additional_filters_ls,
        return_raw=return_raw,
        session=session,
        debug_api=debug_api,
    )

    if return_raw or len(search_ls) == 0:
        return search_ls

    return await ce.gather_with_concurrency(
        *[
            dmce.DomoCodeEngine_Package.get_current_version_by_id(
                auth=auth,
                package_id=obj["uuid"],
            )
            for obj in search_ls
        ],
        n=10
    )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoDataflow.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoDataflow.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoDataflow.ipynb.

# %% ../../nbs/classes/50_DomoDataflow.ipynb 2
from __future__ import annotations

# %% auto 0
__all__ = ['DomoDataflow']

# %% ../../nbs/classes/50_DomoDataflow.ipynb 3
from dataclasses import dataclass, field
from typing import List

import domolibrary.utils.DictDot as util_dd
import domolibrary.utils.chunk_execution as ce

import domolibrary.client.DomoAuth as dmda
import domolibrary.routes.dataflow as dataflow_routes

import httpx
from nbdev.showdoc import patch_to

# %% ../../nbs/classes/50_DomoDataflow.ipynb 4
from .DomoDataflow_Action import DomoDataflow_Action
from domolibrary.classes.DomoDataflow_History import (
    DomoDataflow_History,
    DomoDataflow_ActionResult,
)

# %% ../../nbs/classes/50_DomoDataflow.ipynb 6
@dataclass
class DomoDataflow:
    id: str
    name: str = None
    auth: dmda.DomoAuth = field(default=None, repr=False)
    owner: str = None
    description: str = None
    tags: list[str] = None
    actions: list[DomoDataflow_Action] = None

    version_id: int = None
    version_number: int = None
    versions: List[dict] = None  # list of DomoDataflow Versions

    history: DomoDataflow_History = None  # class for managing the history of a dataflow

    def __post_init__(self):
        self.history = DomoDataflow_History(
            dataflow=self, dataflow_id=self.id, auth=self.auth
        )

    @classmethod
    def _from_json(cls, obj, auth, version_id=None, version_number=None):
        dd = util_dd.DictDot(obj)

        domo_dataflow = cls(
            auth=auth,
            id=dd.id,
            name=dd.name,
            description=dd.description,
            owner=dd.owner,
            tags=dd.tags,
            version_id=version_id,
            version_number=version_number,
        )

        if dd.actions:
            domo_dataflow.actions = [
                DomoDataflow_Action._from_json(action) for action in dd.actions
            ]

            [
                domo_action.get_parents(domo_dataflow.actions)
                for domo_action in domo_dataflow.actions
            ]

        return domo_dataflow

# %% ../../nbs/classes/50_DomoDataflow.ipynb 7
@patch_to(DomoDataflow, cls_method=True)
async def get_from_id(
    cls: DomoDataflow,
    dataflow_id: int,
    auth: dmda.DomoAuth = None,
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
):
    res = await dataflow_routes.get_dataflow_by_id(
        auth=auth,
        dataflow_id=dataflow_id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=cls.__name__,
        session=session,
    )

    if return_raw:
        return res

    if not res.is_success:
        return None

    return cls._from_json(res.response, auth=auth)

# %% ../../nbs/classes/50_DomoDataflow.ipynb 12
@patch_to(DomoDataflow)
async def execute(
    self: DomoDataflow,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
):
    return await dataflow_routes.execute_dataflow(
        auth=auth or self.auth,
        dataflow_id=self.id,
        parent_class=self.__class__.__name__,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

# %% ../../nbs/classes/50_DomoDataflow.ipynb 16
@patch_to(DomoDataflow, cls_method=True)
async def get_by_version_id(
    cls: DomoDataflow,
    auth: dmda.DomoAuth,
    dataflow_id: int,
    version_id: int,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    res = await dataflow_routes.get_dataflow_by_id_and_version(
        auth=auth,
        dataflow_id=dataflow_id,
        version_id=version_id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=cls.__name__,
        session=session,
    )

    if return_raw:
        return res

    domo_dataflow = cls._from_json(
        res.response["dataFlow"],
        version_id=res.response["id"],
        version_number=res.response["versionNumber"],
        auth=auth,
    )

    return domo_dataflow

# %% ../../nbs/classes/50_DomoDataflow.ipynb 18
@patch_to(DomoDataflow)
async def get_versions(
    self: DomoDataflow,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    res = await dataflow_routes.get_dataflow_versions(
        auth=self.auth,
        dataflow_id=self.id,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
    )

    if return_raw:
        return res

    version_ids = [df_obj["id"] for df_obj in res.response]

    self.versions = await ce.gather_with_concurrency(
        *[
            DomoDataflow.get_by_version_id(
                dataflow_id=self.id,
                version_id=version_id,
                auth=self.auth,
                session=session,
                debug_api=debug_api,
                debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            )
            for version_id in version_ids
        ],
        n=10
    )

    return self.versions

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoDataflow_Action.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoDataflow_Action.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoDataflow_Action.ipynb.

# %% ../../nbs/classes/50_DomoDataflow_Action.ipynb 2
from __future__ import annotations

from enum import Enum
from dataclasses import dataclass
from typing import List

import datetime as dt
import domolibrary.utils.DictDot as util_dd
import domolibrary.utils.convert as ct

from nbdev.showdoc import patch_to

# %% auto 0
__all__ = ['DomoDataflow_Action_Type', 'DomoAction', 'DomoDataflow_Action', 'DomoDataflow_ActionResult']

# %% ../../nbs/classes/50_DomoDataflow_Action.ipynb 4
class DomoDataflow_Action_Type(Enum):
    LoadFromVault = "LoadFromVault"
    PublishToVault = "PublishToVault"
    GenerateTableAction = "GenerateTableAction"


@dataclass
class DomoAction:
    id: str
    type: str = None
    name: str = None


@dataclass
class DomoDataflow_Action(DomoAction):
    datasource_id: str = None
    sql: str = None

    depends_on: List[str] = None
    parent_actions: List[dict] = None

    @classmethod
    def _from_json(cls, obj: dict):
        dd = obj

        if isinstance(dd, dict):
            dd = util_dd.DictDot(obj)

        tbl_name = dd.dataSource.name if dd.dataSource else None
        ds_id = dd.dataSource.guid if dd.dataSource else None

        return cls(
            type=dd.type,
            id=dd.id,
            name=dd.name or dd.targetTableName or dd.tableName or tbl_name,
            depends_on=dd.dependsOn,
            datasource_id=dd.dataSourceId or ds_id,
            sql=dd.selectStatement or dd.query,
        )

# %% ../../nbs/classes/50_DomoDataflow_Action.ipynb 5
@patch_to(DomoDataflow_Action)
def get_parents(self: DomoDataflow_Action, domo_actions: List[DomoDataflow_Action]):
    if self.depends_on and len(self.depends_on) > 0:
        self.parent_actions = [
            parent_action
            for depends_id in self.depends_on
            for parent_action in domo_actions
            if parent_action.id == depends_id
        ]

    if self.parent_actions:
        [
            parent.get_parents(domo_actions)
            for parent in self.parent_actions
            if parent.depends_on
        ]

    return self.parent_actions

# %% ../../nbs/classes/50_DomoDataflow_Action.ipynb 8
@dataclass
class DomoDataflow_ActionResult(DomoAction):
    is_success: bool = None
    rows_processed: int = None
    begin_time: dt.datetime = None
    end_time: dt.datetime = None
    duration_in_sec: int = None

    def __post_init__(self):
        if self.begin_time and self.end_time:
            self.duration_in_sec = (self.end_time - self.begin_time).total_seconds()

    @classmethod
    def _from_json(cls, obj: dict):
        return cls(
            id=obj.get("actionId"),
            type=obj.get("type"),
            is_success=obj.get("wasSuccessful"),
            begin_time=ct.convert_epoch_millisecond_to_datetime(
                obj.get("beginTime", None)
            ),
            end_time=ct.convert_epoch_millisecond_to_datetime(obj.get("endTime", None)),
            rows_processed=obj.get("rowsProcessed", None),
        )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoDataflow_History.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoDataflow_History.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoDataflow_History.ipynb.

# %% ../../nbs/classes/50_DomoDataflow_History.ipynb 2
from __future__ import annotations

from dataclasses import dataclass, field
from typing import List
import datetime as dt

import httpx

from nbdev.showdoc import patch_to

import domolibrary.utils.convert as ct
import domolibrary.utils.chunk_execution as ce

import domolibrary.client.DomoAuth as dmda
import domolibrary.routes.dataflow as dataflow_routes

# %% auto 0
__all__ = ['DomoDataflow_History_Execution', 'DomoDataflow_History']

# %% ../../nbs/classes/50_DomoDataflow_History.ipynb 3
from .DomoDataflow_Action import DomoDataflow_ActionResult

# %% ../../nbs/classes/50_DomoDataflow_History.ipynb 6
@dataclass
class DomoDataflow_History_Execution:
    auth: dmda.DomoAuth = field(repr=False)
    id: str
    dataflow_id: str
    dataflow_execution_id: str
    dataflow_version: str

    begin_time: dt.datetime
    end_time: dt.datetime
    last_updated: dt.datetime

    is_failed: bool
    state: str
    activation_type: str
    data_processor: str
    telemetry: dict
    execution_stats: dict

    action_results: List[DomoDataflow_ActionResult] = None

    @classmethod
    def _from_json(cls, de_obj, auth: dmda.DomoAuth):

        action_results = None
        if de_obj.get("actionResults"):
            action_results = [
                DomoDataflow_ActionResult._from_json(action_obj)
                for action_obj in de_obj.get("actionResults")
            ]

        return cls(
            auth=auth,
            id=de_obj["id"],
            dataflow_id=de_obj["onboardFlowId"],
            dataflow_execution_id=de_obj["dapDataFlowExecutionId"],
            dataflow_version=de_obj.get("dataFlowVersion"),
            begin_time=ct.convert_epoch_millisecond_to_datetime(
                de_obj.get("beginTime")
            ),
            end_time=ct.convert_epoch_millisecond_to_datetime(de_obj.get("endTime")),
            last_updated=ct.convert_epoch_millisecond_to_datetime(
                de_obj["lastUpdated"]
            ),
            is_failed=de_obj.get("failed"),
            state=de_obj["state"],
            activation_type=de_obj["activationType"],
            data_processor=de_obj["dataProcessor"],
            telemetry=de_obj.get("telemetry"),
            execution_stats={
                "total_bytes_written": de_obj.get("totalBytesWritten", 0),
                "total_rows_read": de_obj.get("totalRowsRead", 0),
                "total_bytes_read": de_obj.get("totalBytesRead", 0),
                "mean_download_rate_kbps": de_obj.get("meanDownloadRateKbps", 0),
                "total_rows_written": de_obj.get("totalRowsWritten", 0),
            },
            action_results=action_results,
        )

# %% ../../nbs/classes/50_DomoDataflow_History.ipynb 7
@patch_to(DomoDataflow_History_Execution, cls_method=True)
async def get_by_id(
    cls,
    auth: dmda.DomoAuth,
    dataflow_id: int,
    execution_id: int,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    """retrieves details about a dataflow execution including actions"""

    res = await dataflow_routes.get_dataflow_execution_by_id(
        auth=auth,
        dataflow_id=dataflow_id,
        execution_id=execution_id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=cls.__name__,
        session=session,
    )

    if return_raw:
        return res

    return cls._from_json(auth=auth, de_obj=res.response)

# %% ../../nbs/classes/50_DomoDataflow_History.ipynb 11
@patch_to(DomoDataflow_History_Execution)
async def get_actions(
    self: DomoDataflow_History_Execution,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    """retrieves details execution action results"""

    res = await dataflow_routes.get_dataflow_execution_by_id(
        auth=self.auth,
        dataflow_id=self.dataflow_id,
        execution_id=self.id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
        session=session,
    )

    if return_raw:
        return res

    action_results = res.response.get("actionResults")
    if action_results:
        action_results = [
            DomoDataflow_ActionResult._from_json(action_obj)
            for action_obj in action_results
        ]

    self.action_results = action_results
    return self.action_results

# %% ../../nbs/classes/50_DomoDataflow_History.ipynb 13
@dataclass
class DomoDataflow_History:
    auth: dmda.DomoAuth = field(repr=False)
    dataflow_id: int = field(repr=False)

    dataflow: None = field(repr=False, default=None)

    execution_history: List[DomoDataflow_History_Execution] = None

# %% ../../nbs/classes/50_DomoDataflow_History.ipynb 14
@patch_to(DomoDataflow_History)
async def get_execution_history(
    self: DomoDataflow_History,
    auth: dmda.DomoAuth = None,
    maximum=10,  # maximum number of execution histories to retrieve
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
):
    """retrieves metadata about execution history.
    includes details like execution status.
    """

    auth = auth or self.auth or self.dataflow.auth

    res = await dataflow_routes.get_dataflow_execution_history(
        auth=auth,
        dataflow_id=self.dataflow_id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
        maximum=maximum,
    )

    if return_raw:
        return res

    execution_history = [
        DomoDataflow_History_Execution._from_json(df_obj, auth)
        for df_obj in res.response
    ]

    await ce.gather_with_concurrency(
        *[domo_execution.get_actions() for domo_execution in execution_history], n=20
    )

    self.execution_history = execution_history

    return self.execution_history

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoDataset.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoDataset.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoDataset.ipynb.

# %% auto 0
__all__ = ['DatasetSchema_Types', 'DomoDataset_Schema_Column', 'DomoDataset_Schema', 'DatasetTags_SetTagsError',
           'DomoDataset_Tags', 'DomoDataset', 'QueryExecutionError', 'DomoDataset_DeleteDataset_Error',
           'DomoDataset_CreateDataset_Error']

# %% ../../nbs/classes/50_DomoDataset.ipynb 3
import json
import io

import httpx
import asyncio

import pandas as pd
from dataclasses import dataclass, field
from typing import List, Optional
from enum import Enum

from nbdev.showdoc import patch_to

import domolibrary.utils.DictDot as util_dd
import domolibrary.utils.chunk_execution as ce

import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

import domolibrary.routes.dataset as dataset_routes

import domolibrary.classes.DomoPDP as dmpdp
import domolibrary.classes.DomoCertification as dmdc

# %% ../../nbs/classes/50_DomoDataset.ipynb 5
from domolibrary.routes.dataset import (
    ShareDataset_AccessLevelEnum,
    DatasetNotFoundError,
    QueryRequestError,
    ShareDataset_Error,
    UploadDataError,
)

# %% ../../nbs/classes/50_DomoDataset.ipynb 7
async def _have_prereqs(self, auth, dataset_id, function_name):
    """tests if have a parent dataset or prerequsite dataset_id and auth object"""

    auth_from_self_dataset = (
        getattr(self.dataset, "auth", None) if getattr(self, "dataset", None) else None
    )
    auth_from_self = getattr(self, "auth", None)

    auth = auth or auth_from_self or auth_from_self_dataset

    await auth.get_auth_token()

    if not auth or not auth.token:
        raise de.AuthNotProvidedError(
            function_name=function_name, entity_id=self.dataset.id
        )

    id_from_self = getattr(self, "id", None)
    id_from_self_parent = (
        getattr(self.dataset, "id", None) if getattr(self, "dataset", None) else None
    )

    dataset_id = dataset_id or id_from_self or id_from_self_parent

    if not dataset_id:
        raise de.DatasetNotProvidedError(
            function_name=function_name, domo_instance=auth.domo_instance
        )

    return auth, dataset_id

# %% ../../nbs/classes/50_DomoDataset.ipynb 8
class DatasetSchema_Types(Enum):
    STRING = "STRING"
    DOUBLE = "DOUBLE"
    LONG = "LONG"
    DATE = "DATE"
    DATETIME = "DATETIME"


@dataclass
class DomoDataset_Schema_Column:
    name: str
    id: str
    type: DatasetSchema_Types
    order: int = 0
    visible: bool = True
    upsert_key: bool = False

    def __eq__(self, other):
        return self.id == other.id

    @classmethod
    def _from_json(cls, json_obj):
        dd = util_dd.DictDot(json_obj)
        return cls(
            name=dd.name,
            id=dd.id,
            type=dd.type,
            visible=dd.visible or dd.isVisible or True,
            upsert_key=dd.upsertKey or False,
            order=dd.order or 0,
        )

    def to_dict(self):
        s = self.__dict__
        s["upsertKey"] = s.pop("upsert_key") if "upsert_key" in s else False
        return s


@dataclass
class DomoDataset_Schema:
    """class for interacting with dataset schemas"""

    dataset: any = None
    columns: List[DomoDataset_Schema_Column] = field(default_factory=list)

    async def get(
        self,
        auth: Optional[dmda.DomoAuth] = None,
        dataset_id: str = None,
        debug_api: bool = False,
        return_raw: bool = False,  # return the raw response
    ) -> List[DomoDataset_Schema_Column]:
        """method that retrieves schema for a dataset"""

        auth, dataset_id = await _have_prereqs(
            self=self,
            auth=auth,
            dataset_id=dataset_id,
            function_name="DomoDataset_Schema.get",
        )

        res = await dataset_routes.get_schema(
            auth=auth, dataset_id=dataset_id, debug_api=debug_api
        )

        if return_raw:
            return res.response

        if res.status == 200:
            json_list = res.response.get("tables")[0].get("columns")

            self.columns = [
                DomoDataset_Schema_Column._from_json(json_obj=json_obj)
                for json_obj in json_list
            ]

            return self.columns

# %% ../../nbs/classes/50_DomoDataset.ipynb 12
class DatasetSchema_InvalidSchema(de.DomoError):
    def __init__(self, domo_instance, dataset_id, missing_columns, dataset_name=None):

        if dataset_id:
            message = f"{dataset_id}{f' - {dataset_name}' if dataset_name else ''} is missing columns {', '.join(missing_columns)}"

        super().__init__(domo_instance=domo_instance, message=message)


@patch_to(DomoDataset_Schema)
async def _test_missing_columns(
    self: DomoDataset_Schema,
    df: pd.DataFrame,
    dataset_id=None,
    auth: dmda.DomoAuth = None,
):

    dataset_id = dataset_id or self.dataset.id
    auth = auth or self.dataset.auth

    await self.get(dataset_id=dataset_id, auth=auth)

    missing_columns = [
        col for col in df.columns if col not in [scol.name for scol in self.columns]
    ]

    if len(missing_columns) > 0:
        raise DatasetSchema_InvalidSchema(
            domo_instance=auth.domo_instance,
            dataset_id=dataset_id,
            missing_columns=missing_columns,
        )
        return missing_columns

    return False

# %% ../../nbs/classes/50_DomoDataset.ipynb 14
@patch_to(DomoDataset_Schema)
async def reset_col_order(self: DomoDataset_Schema, df: pd.DataFrame, dataset_id):

    await self.get()

    if len(self.columns) != len(df.columns):
        raise Exception("")

    for index, col in enumerate(self.schema.columns):
        col.order = col.order if col.order > 0 else index

    # for index, schema in enumerate(consol_ds.schema.columns):
    #     schema.order = index

    # schema = {'columns': [col.__dict__ for col in consol_ds.schema.columns]}
    # schema

    # import domolibrary.routes.dataset as dataset_routes
    # await dataset_routes.alter_schema(auth = consol_auth, dataset_id = consol_ds.id, schema_obj = schema)

    df[[]]

# %% ../../nbs/classes/50_DomoDataset.ipynb 15
@patch_to(DomoDataset_Schema)
def to_dict(self: DomoDataset_Schema):
    return {"columns": [col.to_dict() for col in self.columns]}

# %% ../../nbs/classes/50_DomoDataset.ipynb 17
@patch_to(DomoDataset_Schema)
def add_col(
    self: DomoDataset_Schema, col: DomoDataset_Schema_Column, debug_prn: bool = False
):

    if col in self.columns and debug_prn:
        print(
            f"column - {col.name} already in dataset {self.dataset.name if self.dataset else '' }"
        )

    if col not in self.columns:
        self.columns.append(col)

    return self.columns


@patch_to(DomoDataset_Schema)
def remove_col(
    self: DomoDataset_Schema,
    remove_col: DomoDataset_Schema_Column,
    debug_prn: bool = False,
):

    [
        self.columns.pop(index)
        for index, col in enumerate(self.columns)
        if col == remove_col
    ]

    return self.columns

# %% ../../nbs/classes/50_DomoDataset.ipynb 19
@patch_to(DomoDataset_Schema)
async def alter_schema(
    self: DomoDataset_Schema,
    dataset_id: str = None,
    auth: dmda.DomoAuth = None,
    return_raw: bool = False,
    debug_api: bool = False,
):

    dataset_id = dataset_id or self.dataset.id
    auth = auth or self.dataset.auth

    schema_obj = self.to_dict()

    if return_raw:
        return schema_obj

    res = await dataset_routes.alter_schema(
        dataset_id=dataset_id, auth=auth, schema_obj=schema_obj, debug_api=debug_api
    )

# %% ../../nbs/classes/50_DomoDataset.ipynb 22
class DatasetTags_SetTagsError(Exception):
    """return if DatasetTags request is not successfull"""

    def __init__(self, dataset_id, domo_instance):
        message = f"failed to set tags on dataset - {dataset_id} in {domo_instance}"
        super().__init__(message)


@dataclass
class DomoDataset_Tags:
    """class for interacting with dataset tags"""

    dataset: any = None
    tag_ls: List[str] = field(default_factory=list)

    async def get(
        self,
        dataset_id: str = None,
        auth: Optional[dmda.DomoAuth] = None,
        debug_api: bool = False,
        session: Optional[httpx.AsyncClient] = None,
    ) -> List[str]:  # returns a list of tags
        """gets the existing list of dataset_tags"""

        auth, dataset_id = await _have_prereqs(
            self=self,
            auth=auth,
            dataset_id=dataset_id,
            function_name="DomoDataset_Tages.get",
        )

        res = await dataset_routes.get_dataset_by_id(
            dataset_id=dataset_id, auth=auth, debug_api=debug_api, session=session
        )

        if res.is_success == False:
            print(res)
            return None

        tag_ls = []

        if res.response.get("tags"):
            tag_ls = json.loads(res.response.get("tags"))

        self.tag_ls = tag_ls

        return tag_ls

    async def set(
        self,
        tag_ls: List[str],
        dataset_id: str = None,
        auth: Optional[dmda.DomoAuth] = None,
        debug_api: bool = False,
        session: Optional[httpx.AsyncClient] = None,
    ) -> List[str]:  # returns a list of tags
        """replaces all tags with a new list of dataset_tags"""

        auth, dataset_id = await _have_prereqs(
            self=self,
            auth=auth,
            dataset_id=dataset_id,
            function_name="DomoDatasetTags.set",
        )

        res = await dataset_routes.set_dataset_tags(
            auth=auth,
            tag_ls=list(set(tag_ls)),
            dataset_id=dataset_id,
            debug_api=debug_api,
            session=session,
        )

        if res.status != 200:
            raise DatasetTags_SetTagsError(
                dataset_id=dataset_id, domo_instance=auth.domo_instance
            )

        await self.get(dataset_id=dataset_id, auth=auth)

        return self.tag_ls

# %% ../../nbs/classes/50_DomoDataset.ipynb 25
@patch_to(DomoDataset_Tags)
async def add(
    self: DomoDataset_Tags,
    add_tag_ls: List[str],
    dataset_id: str = None,
    auth: Optional[dmda.DomoAuth] = None,
    debug_api: bool = False,
    session: Optional[httpx.AsyncClient] = None,
) -> List[str]:  # returns a list of tags
    """appends tags to the list of existing dataset_tags"""

    auth, dataset_id = await _have_prereqs(
        self=self,
        auth=auth,
        dataset_id=dataset_id,
        function_name="DomoDataset_Tags.add",
    )

    existing_tag_ls = await self.get(dataset_id=dataset_id, auth=auth) or []

    add_tag_ls += existing_tag_ls

    return await self.set(
        auth=auth,
        dataset_id=dataset_id,
        tag_ls=list(set(add_tag_ls)),
        debug_api=debug_api,
        session=session,
    )

# %% ../../nbs/classes/50_DomoDataset.ipynb 27
@patch_to(DomoDataset_Tags)
async def remove(
    self: DomoDataset_Tags,
    remove_tag_ls: List[str],
    dataset_id: str = None,
    auth: dmda.DomoFullAuth = None,
    debug_api: bool = False,
    session: Optional[httpx.AsyncClient] = None,
) -> List[str]:  # returns a list of tags
    """removes tags from the existing list of dataset_tags"""

    auth, dataset_id = await _have_prereqs(
        self=self,
        auth=auth,
        dataset_id=dataset_id,
        function_name="DomoDataset_Tags.remove",
    )

    existing_tag_ls = await self.get(dataset_id=dataset_id, auth=auth)

    existing_tag_ls = [ex for ex in existing_tag_ls if ex not in remove_tag_ls]

    return await self.set(
        auth=auth,
        dataset_id=dataset_id,
        tag_ls=list(set(existing_tag_ls)),
        debug_api=debug_api,
        session=session,
    )

# %% ../../nbs/classes/50_DomoDataset.ipynb 31
@dataclass
class DomoDataset:
    "interacts with domo datasets"

    auth: dmda.DomoAuth = field(repr=False, default=None)

    id: str = ""
    display_type: str = ""
    data_provider_type: str = ""
    name: str = ""
    description: str = ""
    row_count: int = None
    column_count: int = None

    stream_id: int = None

    owner: dict = field(default_factory=dict)
    formula: dict = field(default_factory=dict)

    schema: DomoDataset_Schema = field(default=None)
    tags: DomoDataset_Tags = field(default=None)

    certification: dmdc.DomoCertification = None
    PDP: dmpdp.Dataset_PDP_Policies = None

    def __post_init__(self):
        self.schema = DomoDataset_Schema(dataset=self)
        self.tags = DomoDataset_Tags(dataset=self)

        self.PDP = dmpdp.Dataset_PDP_Policies(dataset=self)

    def display_url(self):
        return f"https://{self.auth.domo_instance }.domo.com/datasources/{self.id}/details/overview"

# %% ../../nbs/classes/50_DomoDataset.ipynb 35
@patch_to(DomoDataset, cls_method=True)
async def get_from_id(
    cls: DomoDataset,
    dataset_id: str,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=2,
    parent_class: str = None,
):
    """retrieves dataset metadata"""

    parent_class = parent_class or cls.__name__

    res = await dataset_routes.get_dataset_by_id(
        auth=auth,
        dataset_id=dataset_id,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if return_raw:
        return res.response

    dd = util_dd.DictDot(res.response)
    ds = cls(
        auth=auth,
        id=dd.id,
        display_type=dd.displayType,
        data_provider_type=dd.dataProviderType,
        name=dd.name,
        description=dd.description,
        owner=res.response.get("owner"),
        stream_id=dd.streamId,
        row_count=int(dd.rowCount),
        column_count=int(dd.columnCount),
    )

    if dd.properties.formulas.formulas.__dict__:
        # print(dd.properties.formulas.formulas.__dict__)
        ds.formula = res.response.get("properties").get("formulas").get("formulas")

    if dd.tags:
        ds.tags.tag_ls = json.loads(dd.tags)

    if dd.certification:
        # print('class def certification', dd.certification)
        ds.certification = dmdc.DomoCertification._from_json(dd.certification)

    return ds

# %% ../../nbs/classes/50_DomoDataset.ipynb 40
class QueryExecutionError(de.DomoError):
    def __init__(
        self, sql, dataset_id, domo_instance, status, message, function_name=None
    ):

        message = f"error executing {sql}: {message}"

        super().__init__(
            entity_id=dataset_id,
            function_name=function_name,
            status=status,
            message=message,
            domo_instance=domo_instance,
        )


@patch_to(DomoDataset, cls_method=True)
async def query_dataset_private(
    cls: DomoDataset,
    auth: dmda.DomoAuth,  # DomoFullAuth or DomoTokenAuth
    dataset_id: str,
    sql: str,
    session: Optional[httpx.AsyncClient] = None,
    filter_pdp_policy_id_ls: List[int] = None,  # filter by pdp policy
    loop_until_end: bool = False,  # retrieve all available rows
    limit=100,  # maximum rows to return per request.  refers to PAGINATION
    skip=0,
    maximum=100,  # equivalent to the LIMIT or TOP clause in SQL, the number of rows to return total
    debug_api: bool = False,
    debug_loop: bool = False,
    debug_num_stacks_to_drop: int = 2,
    timeout=10,  # larger API requests may require a longer response time
    maximum_retry: int = 5,
    parent_class: str = None,
    is_return_dataframe: bool = True,
) -> pd.DataFrame:

    parent_class = parent_class or cls.__name__
    res = None
    retry = 1

    if filter_pdp_policy_id_ls and not isinstance(filter_pdp_policy_id_ls, list):
        filter_pdp_policy_id_ls = [int(filter_pdp_policy_id_ls)]

    while (not res or not res.is_success) and retry <= maximum_retry:
        try:
            res = await dataset_routes.query_dataset_private(
                auth=auth,
                dataset_id=dataset_id,
                sql=sql,
                maximum=maximum,
                filter_pdp_policy_id_ls=filter_pdp_policy_id_ls,
                skip=skip,
                limit=limit,
                loop_until_end=loop_until_end,
                session=session,
                debug_loop=debug_loop,
                debug_api=debug_api,
                timeout=timeout,
                debug_num_stacks_to_drop=debug_num_stacks_to_drop,
                parent_class=parent_class,
            )
        except dataset_routes.DatasetNotFoundError as e:
            print(e)
            return res

        except dataset_routes.QueryRequestError as e:
            print(e)
            return res

        except Exception as e:
            if retry <= maximum_retry:
                print(
                    f"‚ö†Ô∏è Error.  Attempt {retry} / {maximum_retry} - {e} - while query dataset {dataset_id} in {auth.domo_instance} with {sql}"
                )
            retry += 1

    if res and not res.is_success:
        raise QueryExecutionError(
            status=res.status,
            message=res.response,
            function_name="query_dataset_private",
            sql=sql,
            dataset_id=dataset_id,
            domo_instance=auth.domo_instance,
        )

    if is_return_dataframe:
        return pd.DataFrame(res.response)

    return res.response

# %% ../../nbs/classes/50_DomoDataset.ipynb 42
class DomoDataset_DeleteDataset_Error(de.DomoError):
    def __init__(self, dataset_id, status, reason, domo_instance, function_name):

        super().__init__(
            entity_id=dataset_id,
            function_name=function_name,
            status=status,
            message=reason,
            domo_instance=domo_instance,
        )


@patch_to(DomoDataset)
async def delete(
    self: DomoDataset,
    dataset_id=None,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):

    dataset_id = dataset_id or self.id
    auth = auth or self.auth

    res = await dataset_routes.delete(
        auth=auth, dataset_id=dataset_id, debug_api=debug_api, session=session
    )

    if not res.is_success:
        raise DomoDataset_DeleteDataset_Error(
            dataset_id=dataset_id,
            function_name="DomoDataset.delete",
            domo_instance=auth.domo_instance,
            status=res.status,
            reason=res.response,
        )

    return res

# %% ../../nbs/classes/50_DomoDataset.ipynb 43
@patch_to(DomoDataset)
async def share(
    self: DomoDataset,
    member,  # DomoUser or DomoGroup
    auth: dmda.DomoAuth = None,
    share_type: ShareDataset_AccessLevelEnum = ShareDataset_AccessLevelEnum.CAN_SHARE,
    is_send_email=False,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):

    body = dataset_routes.generate_share_dataset_payload(
        entity_type="GROUP" if type(member).__name__ == "DomoGroup" else "USER",
        entity_id=int(member.id),
        access_level=share_type,
        is_send_email=is_send_email,
    )

    res = await dataset_routes.share_dataset(
        auth=auth or self.auth,
        dataset_id=self.id,
        body=body,
        session=session,
        debug_api=debug_api,
    )

    return res

# %% ../../nbs/classes/50_DomoDataset.ipynb 47
@patch_to(DomoDataset)
async def index_dataset(
    self: DomoDataset,
    auth: dmda.DomoAuth = None,
    dataset_id: str = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):

    auth = auth or self.auth
    dataset_id = dataset_id or self.id
    return await dataset_routes.index_dataset(
        auth=auth, dataset_id=dataset_id, debug_api=debug_api, session=session
    )

# %% ../../nbs/classes/50_DomoDataset.ipynb 48
@patch_to(DomoDataset)
async def upload_data(
    self: DomoDataset,
    upload_df: pd.DataFrame = None,
    upload_df_ls: list[pd.DataFrame] = None,
    upload_file: io.TextIOWrapper = None,
    upload_method: str = "REPLACE",  # APPEND or REPLACE
    partition_key: str = None,
    is_index: bool = True,
    dataset_id: str = None,
    dataset_upload_id=None,
    auth: dmda.DomoAuth = None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_prn: bool = False,
):

    auth, dataset_id = await _have_prereqs(
        self=self, auth=auth, dataset_id=dataset_id, function_name="upload_data"
    )

    upload_df_ls = upload_df_ls or [upload_df]

    status_message = f"{dataset_id} {partition_key} | {auth.domo_instance}"

    # stage 1 get uploadId
    retry = 1
    while dataset_upload_id is None and retry < 5:
        try:
            if debug_prn:
                print(f"\n\nüé≠ starting Stage 1 - {status_message}")

            res = await dataset_routes.upload_dataset_stage_1(
                auth=auth,
                dataset_id=dataset_id,
                session=session,
                partition_tag=partition_key,
                debug_api=debug_api,
            )
            if debug_prn:
                print(f"\n\nüé≠ Stage 1 response -- {res.status} for {status_message}")

            dataset_upload_id = res.response

        except dataset_routes.UploadDataError as e:
            print(f"{e} - attempt{retry}")
            retry += 1

            if retry == 5:
                print(f"failed to upload data for {dataset_id} in {auth.domo_instance}")
                raise e
                return

            await asyncio.sleep(5)

    # stage 2 upload_dataset
    if upload_file:
        if debug_prn:
            print(f"\n\nüé≠ starting Stage 2 - upload file for {status_message}")

        res = await ce.gather_with_concurrency(
            n=60,
            *[
                dataset_routes.upload_dataset_stage_2_file(
                    auth=auth,
                    dataset_id=dataset_id,
                    upload_id=dataset_upload_id,
                    part_id=1,
                    data_file=upload_file,
                    session=session,
                    debug_api=debug_api,
                )
            ],
        )

    else:
        if debug_prn:
            print(
                f"\n\nüé≠ starting Stage 2 - {len(upload_df_ls)} - number of parts for {status_message}"
            )

        res = await ce.gather_with_concurrency(
            n=60,
            *[
                dataset_routes.upload_dataset_stage_2_df(
                    auth=auth,
                    dataset_id=dataset_id,
                    upload_id=dataset_upload_id,
                    part_id=index + 1,
                    upload_df=df,
                    session=session,
                    debug_api=debug_api,
                )
                for index, df in enumerate(upload_df_ls)
            ],
        )

    if debug_prn:
        print(f"üé≠ Stage 2 - upload data: complete for {status_message}")

    # stage 3 commit_data
    if debug_prn:
        print(
            f"\n\nüé≠ starting Stage 3 - commit dataset_upload_id for {status_message}"
        )

    await asyncio.sleep(5)  # wait for uploads to finish

    res = await dataset_routes.upload_dataset_stage_3(
        auth=auth,
        dataset_id=dataset_id,
        upload_id=dataset_upload_id,
        update_method=upload_method,
        partition_tag=partition_key,
        is_index=False,
        session=session,
        debug_api=debug_api,
    )

    if debug_prn:
        print(f"\nüé≠ stage 3 - commit dataset: complete for {status_message} ")

    if is_index:
        await asyncio.sleep(3)
        return await self.index_dataset(
            auth=auth, dataset_id=dataset_id, debug_api=debug_api, session=session
        )

    return res

# %% ../../nbs/classes/50_DomoDataset.ipynb 50
@patch_to(DomoDataset)
async def list_partitions(
    self: DomoDataset,
    auth: dmda.DomoAuth = None,
    dataset_id: str = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):

    auth = auth or self.auth
    dataset_id = dataset_id or self.id

    res = await dataset_routes.list_partitions(
        auth=auth, dataset_id=dataset_id, debug_api=debug_api, session=session
    )
    if res.status != 200:
        return None

    return res.response

# %% ../../nbs/classes/50_DomoDataset.ipynb 53
class DomoDataset_CreateDataset_Error(Exception):
    def __init__(self, domo_instance: str, dataset_name: str, status: int, reason: str):
        message = f"Failure to create dataset {dataset_name} in {domo_instance} :: {status} - {reason}"
        super().__init__(message)


@patch_to(DomoDataset, cls_method=True)
async def create(
    cls: DomoDataset,
    dataset_name: str,
    dataset_type="api",
    schema=None,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    schema = schema or {
        "columns": [
            {"name": "col1", "type": "LONG", "upsertKey": False},
            {"name": "col2", "type": "STRING", "upsertKey": False},
        ]
    }

    res = await dataset_routes.create(
        dataset_name=dataset_name,
        dataset_type=dataset_type,
        schema=schema,
        auth=auth,
        debug_api=debug_api,
        session=session,
    )

    if not res.is_success:
        raise DomoDataset_CreateDataset_Error(
            domo_instance=auth.domo_instance,
            dataset_name=dataset_name,
            status=res.status,
            reason=res.response,
        )

    dataset_id = res.response.get("dataSource").get("dataSourceId")

    return await cls.get_from_id(dataset_id=dataset_id, auth=auth)

# %% ../../nbs/classes/50_DomoDataset.ipynb 56
@patch_to(DomoDataset)
async def delete_partition(
    self: DomoDataset,
    dataset_partition_id: str,
    dataset_id: str = None,
    empty_df: pd.DataFrame = None,
    auth: dmda.DomoAuth = None,
    is_index: bool = True,
    debug_api: bool = False,
    debug_prn: bool = False,
    return_raw: bool = False,
):

    auth = auth or self.auth
    dataset_id = dataset_id or self.id

    if empty_df is None:
        empty_df = await self.query_dataset_private(
            auth=auth,
            dataset_id=dataset_id,
            sql="SELECT * from table limit 1",
            debug_api=debug_api,
        )

    await self.upload_data(
        upload_df=empty_df.head(0),
        upload_method="REPLACE",
        is_index=is_index,
        partition_key=dataset_partition_id,
        debug_api=debug_api,
    )
    if debug_prn:
        print(f"\n\nüé≠ starting Stage 1")

    res = await dataset_routes.delete_partition_stage_1(
        auth=auth,
        dataset_id=dataset_id,
        dataset_partition_id=dataset_partition_id,
        debug_api=debug_api,
    )
    if debug_prn:
        print(f"\n\nüé≠ Stage 1 response -- {res.status}")
        print(res)

    if debug_prn:
        print("starting Stage 2")

    res = await dataset_routes.delete_partition_stage_2(
        auth=auth,
        dataset_id=dataset_id,
        dataset_partition_id=dataset_partition_id,
        debug_api=debug_api,
    )

    if debug_prn:
        print(f"\n\nüé≠ Stage 2 response -- {res.status}")

    if debug_prn:
        print("starting Stage 3")

    res = await dataset_routes.index_dataset(
        auth=auth, dataset_id=dataset_id, debug_api=debug_api
    )
    if debug_prn:
        print(f"\n\nüé≠ Stage 3 response -- {res.status}")

    if return_raw:
        return res

    return res.response

# %% ../../nbs/classes/50_DomoDataset.ipynb 59
@patch_to(DomoDataset)
async def reset_dataset(
    self: DomoDataset,
    auth: dmda.DomoAuth = None,
    is_index: bool = True,
    debug_api: bool = False,
):

    execute_reset = input(
        "This function will delete all rows.  Type BLOW_ME_AWAY to execute:"
    )

    if execute_reset != "BLOW_ME_AWAY":
        print("You didn't type BLOW_ME_AWAY, moving on.")
        return None

    auth = auth or self.auth

    if not auth:
        raise Exception("auth required")

    # create empty dataset to retain schema
    empty_df = await self.query_dataset_private(
        auth=auth,
        dataset_id=self.id,
        sql="SELECT * from table limit 1",
        debug_api=debug_api,
    )
    empty_df = empty_df.head(0)

    # get partition list
    partition_list = await self.list_partitions()
    if len(partition_list) > 0:
        partition_list = ce.chunk_list(partition_list, 100)

    for index, pl in enumerate(partition_list):
        print(f"ü•´ starting chunk {index + 1} of {len(partition_list)}")

        await asyncio.gather(
            *[
                self.delete_partition(
                    auth=auth,
                    dataset_partition_id=partition.get("partitionId"),
                    empty_df=empty_df,
                    debug_api=debug_api,
                )
                for partition in pl
            ]
        )
        if is_index:
            await self.index_dataset()

    res = await self.upload_data(
        upload_df=empty_df,
        upload_method="REPLACE",
        is_index=is_index,
        debug_api=debug_api,
    )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoGrant.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoGrant.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoGrant.ipynb.

# %% auto 0
__all__ = ['DomoGrant', 'DomoGrants']

# %% ../../nbs/classes/50_DomoGrant.ipynb 2
from dataclasses import dataclass, field
from nbdev.showdoc import patch_to
import httpx

import domolibrary.client.DomoAuth as dmda
import domolibrary.utils.DictDot as util_dd
import domolibrary.routes.grant as grant_routes

# %% ../../nbs/classes/50_DomoGrant.ipynb 3
@dataclass
class DomoGrant:
    id: str
    display_group: str = None
    title: str = None
    depends_on_ls: list[str] = None
    description: str = None
    role_membership_ls: list[str] = field(default=None)

    def __post_init__(self):
        self.id = str(self.id)

    def __eq__(self, other):
        if not isinstance(other, DomoGrant):
            return False

        return self.id == other.id

    @classmethod
    def _from_json(cls, obj):

        dd = obj
        if not isinstance(dd, util_dd.DictDot):
            dd = util_dd.DictDot(obj)

        return cls(
            id=dd.authority,
            display_group=dd.authorityUIGroup,
            depends_on_ls=dd.dependsOnAuthorities,
            title=dd.title,
            description=dd.description,
            role_membership_ls=[str(role) for role in dd.roleIds],
        )

# %% ../../nbs/classes/50_DomoGrant.ipynb 4
@dataclass
class DomoGrants:
    pass

# %% ../../nbs/classes/50_DomoGrant.ipynb 5
@patch_to(DomoGrants, cls_method=True)
async def get_grants(
    cls: DomoGrants,
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    return_raw: bool = False,
):
    res = await grant_routes.get_grants(auth=auth, debug_api=debug_api, session=session)

    if return_raw or not res.is_success:
        return res

    return [DomoGrant._from_json(row) for index, row in enumerate(res.response)]

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoGroup.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoGroup.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoGroup.ipynb.

# %% auto 0
__all__ = ['DomoGroup', 'DomoGroups']

# %% ../../nbs/classes/50_DomoGroup.ipynb 2
from domolibrary.routes.group import (
    SearchGroups_Error,
    Group_CRUD_Error,
    GroupType_Enum,
)

# %% ../../nbs/classes/50_DomoGroup.ipynb 3
from dataclasses import dataclass, field
from typing import List

import httpx

from nbdev.showdoc import patch_to


import domolibrary.utils.chunk_execution as ce

import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de
import domolibrary.utils.DictDot as util_dd

import domolibrary.routes.group as group_routes

import domolibrary.classes.DomoGroup_Membership as dmgm
import domolibrary.classes.DomoUser as dmu

# %% ../../nbs/classes/50_DomoGroup.ipynb 6
@dataclass
class DomoGroup:
    auth: dmda.DomoAuth = field(repr=False, default=None)
    id: str = None
    name: str = None
    type: str = None
    description: str = None
    members_id_ls: list[str] = field(repr=False, default_factory=list)
    owner_id_ls: list[str] = field(repr=False, default_factory=list)

    members_ls: list[dict] = field(repr=False, default_factory=list)
    owner_ls: list[dict] = field(repr=False, default_factory=list)

    custom_attributes: dict = field(default_factory=dict)

    def __post_init__(self):
        # self.domo_instance = self.domo_instance or auth.domo_instance
        self.Membership = dmgm.GroupMembership(self)

    @classmethod
    def _from_group_json(cls, auth: dmda.DomoAuth, json_obj):
        dd = json_obj

        if not isinstance(json_obj, util_dd.DictDot):
            dd = util_dd.DictDot(json_obj)

        return cls(
            auth=auth,
            id=dd.id or dd.groupId,
            name=dd.name,
            description=dd.description,
            type=dd.type or dd.groupType,
            members_id_ls=dd.userIds,
            owner_ls=dd.owners,
        )

    @classmethod
    def _from_grouplist_json(cls, auth: dmda.DomoAuth, json_obj):
        dd = json_obj

        if not isinstance(json_obj, util_dd.DictDot):
            dd = util_dd.DictDot(json_obj)

        return cls(
            auth=auth,
            id=dd.groupId,
            name=dd.name,
            description=dd.description,
            type=dd.groupType,
            owner_ls=dd.owners,
            owner_id_ls=[owner.id for owner in dd.owners],
            members_ls=dd.groupMembers,
            members_id_ls=[member.id for member in dd.members],
        )

    @staticmethod
    def _groups_to_domo_group(json_list, auth: dmda.DomoAuth) -> List[dict]:
        domo_groups = [
            DomoGroup._from_group_json(auth=auth, json_obj=json_obj)
            for json_obj in json_list
        ]

        return domo_groups

# %% ../../nbs/classes/50_DomoGroup.ipynb 8
@patch_to(DomoGroup, cls_method=True)
async def get_by_id(
    cls,
    auth: dmda.DomoAuth,
    group_id: str,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    res = await group_routes.get_group_by_id(
        auth=auth, group_id=group_id, debug_api=debug_api, session=session
    )
    if return_raw:
        return res

    if res.status != 200:
        raise Exception()

    dg = cls._from_group_json(auth=auth, json_obj=res.response)

    # await dg.Membership.get_owners()
    # await dg.Membership.get_members() # disabled because causes recursion
    return dg

# %% ../../nbs/classes/50_DomoGroup.ipynb 11
@patch_to(DomoGroup, cls_method=True)
async def search_by_name(
    cls,
    auth: dmda.DomoAuth,
    group_name: str,
    is_exact_match: bool = True,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    res = await group_routes.search_groups_by_name(
        auth=auth,
        search_name=group_name,
        debug_api=debug_api,
        is_exact_match=is_exact_match,
        session=session,
    )

    if return_raw:
        return res

    if isinstance(res.response, list):
        return cls._groups_to_domo_group(res.response, auth)

    return cls._from_group_json(auth=auth, json_obj=res.response)

# %% ../../nbs/classes/50_DomoGroup.ipynb 32
class DomoGroups:
    def __init__(self):
        pass

    @staticmethod
    def _groups_to_domo_group(json_list, auth: dmda.DomoAuth):
        return [
            DomoGroup._from_group_json(auth=auth, json_obj=json_obj)
            for json_obj in json_list
        ]

# %% ../../nbs/classes/50_DomoGroup.ipynb 34
@patch_to(DomoGroups, cls_method=True)
async def get_all_groups(
    cls: DomoGroups,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    res = await group_routes.get_all_groups(
        auth=auth, debug_api=debug_api, session=session
    )

    if len(res.response) > 0:
        json_list = res.response

        return cls._groups_to_domo_group(json_list=json_list, auth=auth)

    else:
        return []

# %% ../../nbs/classes/50_DomoGroup.ipynb 38
@patch_to(DomoGroups, cls_method=True)
async def toggle_system_group_visibility(
    cls: DomoGroups,
    auth: dmda.DomoAuth,
    is_hide_system_groups: bool,
    debug_api: bool = False,
):
    return await group_routes.toggle_system_group_visibility(
        auth=auth, is_hide_system_groups=is_hide_system_groups, debug_api=debug_api
    )

# %% ../../nbs/classes/50_DomoGroup.ipynb 43
@patch_to(DomoGroup, cls_method=True)
async def create_from_name(
    cls: DomoGroup,
    auth: dmda.DomoAuth,
    group_name: str = None,
    group_type: str = "open",  # use GroupType_Enum
    description: str = None,
    is_include_manage_groups_role: bool = True,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    res = await group_routes.create_group(
        auth=auth,
        group_name=group_name,
        group_type=group_type,
        description=description,
        debug_api=debug_api,
    )

    domo_group = cls._from_group_json(auth=auth, json_obj=res.response)

    await domo_group.Membership.add_owner_manage_groups_role()

    return domo_group

# %% ../../nbs/classes/50_DomoGroup.ipynb 47
@patch_to(DomoGroup)
async def update_metadata(
    self: DomoGroup,
    auth: dmda.DomoAuth = None,
    group_name: str = None,
    group_type: str = None,  # use GroupType_Enum
    description: str = None,
    additional_params: dict = None,
    debug_api: bool = False,
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
):
    auth = auth or self.auth

    try:
        res = await group_routes.update_group(
            auth=auth,
            group_id=self.id,
            group_name=group_name,
            group_type=group_type,
            description=description,
            additional_params=additional_params,
            debug_api=debug_api,
            session=session,
        )

        if return_raw:
            return res

        updated_group = await DomoGroup.get_by_id(auth=auth, group_id=self.id)

        self.name = updated_group.name or self.name
        self.description = updated_group.description or self.description
        self.type = updated_group.type or self.type

    except Group_CRUD_Error as e:
        if group_type != self.type:
            raise Group_CRUD_Error(
                status=400,
                message=f"probably cannot change group_type to '{group_type}' from current type '{self.type}' consider passing `addtional_parameters`",
                domo_instance=auth.domo_instance,
                function_name="update_group",
                parent_class=self.__class__.__name__,
            )

        else:
            raise e

    return self

# %% ../../nbs/classes/50_DomoGroup.ipynb 52
@patch_to(DomoGroup, cls_method=True)
async def upsert(
    cls: DomoGroup,
    auth: dmda.DomoAuth,
    group_name: str,
    group_type: str = None,  # if create_group, use routes.class.GroupType_Enum
    description: str = None,
    debug_api: bool = False,
    debug_prn: bool = False,
    additional_params: dict = None,
    session: httpx.AsyncClient = None,
):
    domo_group = None

    try:
        domo_group = await DomoGroup.search_by_name(
            auth=auth, group_name=group_name, is_exact_match=True, session=session
        )

        return await domo_group.update_metadata(
            group_type=group_type, description=description, debug_api=debug_api
        )

    except group_routes.SearchGroups_Error as e:
        print(e)
        return await DomoGroup.create_from_name(
            auth=auth,
            group_name=group_name,
            group_type=group_type,
            description=description,
            debug_api=debug_api,
            session=session,
        )

    except Group_CRUD_Error as e:
        print(e)

        # try running without changing group type

        return await group_routes.update_group(
            auth=auth,
            group_id=domo_group.id,
            group_name=group_name,
            # group_type=group_type,
            description=description,
            additional_params=additional_params,
            debug_api=debug_api,
            session=session,
        )

# %% ../../nbs/classes/50_DomoGroup.ipynb 56
@patch_to(DomoGroup)
async def delete(
    self: DomoGroup,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: httpx.AsyncClient = None,
):
    res = await group_routes.delete_groups(
        auth=self.auth,
        group_ids=[str(self.id)],
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
        session=session,
    )

    res.parent_class = self.__class__.__name__

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoGroup_Membership.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoGroup_Membership.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoGroup_Membership.ipynb.

# %% ../../nbs/classes/50_DomoGroup_Membership.ipynb 2
from __future__ import annotations
from typing import List

import httpx

from nbdev.showdoc import patch_to

import domolibrary.utils.chunk_execution as ce

import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

import domolibrary.routes.group as group_routes

import domolibrary.classes.DomoUser as dmu

# %% auto 0
__all__ = ['UpdateGroupMembership', 'GroupMembership']

# %% ../../nbs/classes/50_DomoGroup_Membership.ipynb 4
class UpdateGroupMembership(de.DomoError):
    def __init__(self, member_name, group_name, domo_instance):
        super().__init__(
            domo_instance=domo_instance,
            message=f"unable to add {member_name} to {group_name}",
        )


class GroupMembership:
    _add_member_ls: list[str]
    _remove_group_ls: list[str]

    _add_owners_ls: list[str]
    _remove_owner_ls: list[str]

    _current_member_ls: list[str]
    _current_owner_ls: list[str]

    group = None

    def __init__(self, group):
        self.group = group

        self._add_member_ls: List[dict] = []
        self._remove_member_ls: List[dict] = []

        self._add_owner_ls: List[dict] = []
        self._remove_owner_ls: List[dict] = []

        self._current_member_ls = []
        self._current_owner_ls = []

    def _add_to_list(self, member, list_to_update, debug_prn: bool = False):
        import domolibrary.classes.DomoUser as dmu
        import domolibrary.classes.DomoGroup as dmg

        match_obj = next(
            (
                user_obj
                for user_obj in list_to_update
                if user_obj.get("id") == member.id
            ),
            None,
        )
        if match_obj:
            print(f"‚û°Ô∏è {member}  of type {type(member).__name__} already in ls")
            return list_to_update

        if debug_prn:
            print(
                f"‚û°Ô∏è adding {member.id}  of type {type(member).__name__} to {self.group.name}"
            )

        if isinstance(member, dmu.DomoUser):
            list_to_update.append({"id": str(member.id), "type": "USER"})

            return list_to_update

        if isinstance(member, dmg.DomoGroup):
            list_to_update.append({"id": str(member.id), "type": "GROUP"})

            return list_to_update

        member_name = (
            getattr(member, "name", None)
            or getattr(member, "display_name", None)
            or "name not provided"
        )

        raise UpdateGroupMembership(
            domo_instance=self.group.auth.domo_instance,
            group_name=self.group.name,
            member_name=member_name,
        )

    def _add_member(self, member, debug_prn: bool = False):
        return self._add_to_list(member, self._add_member_ls, debug_prn)

    def _remove_member(self, member, debug_prn: bool = False):
        if type(member).__name__ == "DomoGroup" and member.type == "system":
            if debug_prn:
                print(f"remove_owner - skipping {member.name} type is {member.type}")
            return
        return self._add_to_list(member, self._remove_member_ls, debug_prn)

    def _add_owner(self, member, debug_prn: bool = False):
        return self._add_to_list(member, self._add_owner_ls, debug_prn)

    def _remove_owner(self, member, debug_prn: bool = False):
        if type(member).__name__ == "DomoGroup" and member.type == "system":
            if debug_prn:
                print(f"remove_owner - skipping {member.name} type is {member.type}")
            return

        return self._add_to_list(member, self._remove_owner_ls, debug_prn)

    def _reset_obj(self):
        self._add_member_ls = []
        self._remove_member_ls = []

        self._add_owner_ls = []
        self._remove_owner_ls = []

    async def _update_group_access(
        self,
        debug_api: bool = False,
        session: httpx.AsyncClient = None,
    ):
        res = await group_routes.update_group_membership(
            auth=self.group.auth,
            group_id=self.group.id,
            add_member_arr=self._add_member_ls,
            remove_member_arr=self._remove_member_ls,
            add_owner_arr=self._add_owner_ls,
            remove_owner_arr=self._remove_owner_ls,
            debug_api=debug_api,
            session=session,
        )
        self._reset_obj()

        # add
        # remove
        # set

# %% ../../nbs/classes/50_DomoGroup_Membership.ipynb 6
@patch_to(GroupMembership)
async def get_owners(
    self: GroupMembership,
    auth: dmda.DomoAuth = None,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    import domolibrary.classes.DomoUser as dmu
    import domolibrary.classes.DomoGroup as dmg

    auth = auth or self.group.auth

    self._current_owner_ls = []

    res = await group_routes.get_group_owners(
        group_id=self.group.id, auth=self.group.auth
    )
    if return_raw:
        return res

    group_ids = [obj.get("id") for obj in res.response if obj.get("type") == "GROUP"]
    if group_ids:
        domo_groups = await ce.gather_with_concurrency(
            n=60,
            *[
                dmg.DomoGroup.get_by_id(group_id=group_id, auth=auth)
                for group_id in group_ids
            ]
        )
        self._current_owner_ls += domo_groups

    user_ids = [obj.get("id") for obj in res.response if obj.get("type") == "USER"]
    if user_ids:
        domo_users = await dmu.DomoUsers.by_id(
            user_ids=user_ids, auth=auth, only_allow_one=False
        )
        self._current_owner_ls += domo_users

    self.group.owner_id_ls = group_ids + user_ids
    self.group.owner_ls = self._current_owner_ls

    return self._current_owner_ls
    # return domo_users

# %% ../../nbs/classes/50_DomoGroup_Membership.ipynb 7
@patch_to(GroupMembership)
async def get_members(
    self: GroupMembership,
    auth: dmda.DomoAuth = None,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    import domolibrary.classes.DomoUser as dmu

    auth = auth or self.group.auth

    self._current_member_ls = []

    res = await group_routes.get_group_membership(
        group_id=self.group.id, auth=self.group.auth
    )
    if return_raw:
        return res

    user_ids = [obj.get("userId") for obj in res.response]
    if user_ids:
        domo_users = await dmu.DomoUsers.by_id(
            user_ids=user_ids, auth=auth, only_allow_one=False
        )
        self._current_member_ls += domo_users

    self.group.members_id_ls = user_ids
    self.group.members_ls = self._current_member_ls

    return self.group.members_ls

# %% ../../nbs/classes/50_DomoGroup_Membership.ipynb 9
@patch_to(GroupMembership)
async def add_members(
    self: GroupMembership,
    add_user_ls: list[dmu.DomoUser],
    return_raw: bool = False,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    self._reset_obj()

    [self._add_member(domo_user, debug_prn) for domo_user in add_user_ls]

    res = await self._update_group_access(debug_api=debug_api, session=session)

    if return_raw:
        return res

    return await self.get_members()


@patch_to(GroupMembership)
async def remove_members(
    self: GroupMembership,
    remove_user_ls: list[dmu.DomoUser],
    return_raw: bool = False,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    self._reset_obj()

    [self._remove_member(domo_user, debug_prn) for domo_user in remove_user_ls]

    res = await self._update_group_access(debug_api=debug_api, session=session)

    if return_raw:
        return res

    return await self.get_members()


@patch_to(GroupMembership)
async def set_members(
    self: GroupMembership,
    user_ls: list[dmu.DomoUser],
    return_raw: bool = False,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    self._reset_obj()

    domo_users = await self.get_members()

    if debug_prn:
        print({"domo_users": domo_users, "user_ls": user_ls})

    [self._add_member(domo_user, debug_prn) for domo_user in user_ls]
    [
        self._remove_member(domo_user, debug_prn)
        for domo_user in domo_users
        if domo_user not in user_ls
    ]

    res = await self._update_group_access(debug_api=debug_api, session=session)

    if return_raw:
        return res

    return await self.get_members()

# %% ../../nbs/classes/50_DomoGroup_Membership.ipynb 10
@patch_to(GroupMembership)
async def add_owners(
    self: GroupMembership,
    add_owner_ls,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    self._reset_obj()

    [self._add_owner(domo_user, debug_prn) for domo_user in add_owner_ls]

    res = await self._update_group_access(debug_api=debug_api, session=session)

    if return_raw:
        return res

    return await self.get_owners()


@patch_to(GroupMembership)
async def remove_owners(
    self: GroupMembership,
    remove_owner_ls,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    self._reset_obj()

    [self._remove_owner(domo_user, debug_prn) for domo_user in remove_owner_ls]

    res = await self._update_group_access(debug_api=debug_api, session=session)

    if return_raw:
        return res

    return await self.get_owners()


@patch_to(GroupMembership)
async def set_owners(
    self: GroupMembership,
    owner_ls,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    self._reset_obj()

    domo_users = await self.get_owners()

    if debug_prn:
        print({"domo_users": domo_users, "user_ls": owner_ls})

    [self._add_owner(domo_user, debug_prn) for domo_user in owner_ls]
    [
        self._remove_owner(domo_user, debug_prn)
        for domo_user in domo_users
        if domo_user not in owner_ls
    ]

    res = await self._update_group_access(debug_api=debug_api, session=session)

    if return_raw:
        return res

    return await self.get_owners()

# %% ../../nbs/classes/50_DomoGroup_Membership.ipynb 11
@patch_to(GroupMembership)
async def add_owner_manage_groups_role(self: GroupMembership):
    import domolibrary.classes.DomoGroup as dmg

    await dmg.DomoGroups.toggle_system_group_visibility(
        auth=self.group.auth, is_hide_system_groups=False
    )

    grant_group = await dmg.DomoGroup.search_by_name(
        auth=self.group.auth, group_name="Grant: Manage all groups"
    )

    await self.add_owners(add_owner_ls=[grant_group])

    await dmg.DomoGroups.toggle_system_group_visibility(
        auth=self.group.auth, is_hide_system_groups=True
    )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoInstanceConfig.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoInstanceConfig.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoInstanceConfig.ipynb.

# %% auto 0
__all__ = ['DomoInstanceConfig', 'SSO_Config', 'DomoConnector']

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 2
from ..routes.instance_config import UpdateSSO_Error

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 3
import httpx
import datetime as dt
from nbdev.showdoc import patch_to
import sys
import pandas as pd


from dataclasses import dataclass, field, asdict

import domolibrary.utils.DictDot as util_dd
import domolibrary.utils.chunk_execution as ce
import domolibrary.utils.convert as cd

import domolibrary.client.DomoAuth as dmda

import domolibrary.classes.DomoInstanceConfig_UserAttribute as dicua

import domolibrary.routes.instance_config as instance_config_routes
import domolibrary.routes.sandbox as sandbox_routes
import domolibrary.routes.publish as publish_routes
import domolibrary.routes.application as application_routes

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 5
@dataclass
class DomoInstanceConfig:
    """utility class that absorbs many of the domo instance configuration methods"""

    auth: dmda.DomoAuth
    allowlist: list[str] = field(default_factory=list)

    is_sandbox_self_instance_promotion_enabled: bool = field(default=None)
    is_user_invite_notification_enabled: bool = field(default=None)
    is_invite_social_users_enabled: bool = field(default=None)

    sso_config: dict = field(default=None)

    user_attributes: dicua.UserAttributes = None

    def __post_init__(self):
        self.user_attributes = dicua.UserAttributes(auth=self.auth)

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 10
@patch_to(DomoInstanceConfig)
async def get_sandbox_is_same_instance_promotion_enabled(
    self: DomoInstanceConfig,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
    debug_num_stacks_to_drop=2,
):
    auth = auth or self.auth

    res = await sandbox_routes.get_is_allow_same_instance_promotion_enabled(
        auth=auth or self.auth,
        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
    )

    self.is_sandbox_self_instance_promotion_enabled = res.response["is_enabled"]

    if return_raw:
        return res

    return res.response

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 13
@patch_to(DomoInstanceConfig)
async def toggle_sandbox_allow_same_instance_promotion(
    self: DomoInstanceConfig,
    auth: dmda.DomoAuth,
    is_enabled: bool,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
    debug_num_stacks_to_drop=2,
):
    res = await sandbox_routes.toggle_allow_same_instance_promotion(
        auth=auth or self.auth,
        session=session,
        is_enabled=is_enabled,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
    )

    res_is_enabled = await self.get_sandbox_is_same_instance_promotion_enabled()

    if return_raw:
        return res

    return res_is_enabled

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 16
@patch_to(DomoInstanceConfig)
async def get_is_user_invite_notification_enabled(
    self: DomoInstanceConfig,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    """
    Admin > Company Settings > Admin Notifications
    Toggles whether user recieves 'You've been Domo'ed email
    """

    auth = auth or self.auth

    res = await instance_config_routes.get_is_user_invite_notifications_enabled(
        auth=auth or self.auth,
        session=session,
        debug_api=debug_api,
    )

    self.is_user_invite_notification_enabled = res.response["is_enabled"]

    if return_raw:
        return res

    return res.response

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 19
@patch_to(DomoInstanceConfig)
async def toggle_is_user_invite_notification_enabled(
    self: DomoInstanceConfig,
    auth: dmda.DomoFullAuth,
    is_enabled: bool,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    res_is_enabled = await self.get_is_user_invite_notification_enabled(auth=auth)

    if is_enabled == self.is_user_invite_notification_enabled:
        if debug_prn:
            print(
                f"User invite notification is already {'enabled' if is_enabled else 'disabled'} in {auth.domo_instance}"
            )
        return res_is_enabled

    if debug_prn:
        print(
            f"{'enabling' if is_enabled else 'disabling'} User invite notification {auth.domo_instance}"
        )

    res = await instance_config_routes.toggle_is_user_invite_enabled(
        auth=auth or self.auth,
        is_enabled=is_enabled,
        session=session,
        debug_api=debug_api,
    )

    res_is_enabled = await self.get_is_user_invite_notification_enabled(auth=auth)

    if return_raw:
        return res

    return res_is_enabled

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 23
@patch_to(DomoInstanceConfig)
async def get_is_invite_social_users_enabled(
    self: DomoInstanceConfig,
    auth: dmda.DomoFullAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    import domolibrary.classes.DomoBootstrap as dmbp

    auth = auth or self.auth
    bs = dmbp.DomoBootstrap(auth=auth)
    customer_id = await bs.get_customer_id()

    res = await instance_config_routes.get_is_invite_social_users_enabled(
        auth=auth or self.auth,
        customer_id=customer_id,
        session=session,
        debug_api=debug_api,
    )

    self.is_invite_social_users_enabled = res.response["is_enabled"]

    if return_raw:
        return res

    return res.response

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 26
@patch_to(DomoInstanceConfig)
async def toggle_is_invite_social_users_enabled(
    self: DomoInstanceConfig,
    is_enabled: bool,
    auth: dmda.DomoFullAuth = None,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    auth = auth or self.auth

    res_is_enabled = await self.get_is_invite_social_users_enabled(auth=auth)

    if is_enabled == self.is_invite_social_users_enabled:
        if debug_prn:
            print(
                f"invite social users is already {'enabled' if is_enabled else 'disabled'} in {auth.domo_instance}"
            )
        return res_is_enabled

    if debug_prn:
        print(
            f"{'enabling' if is_enabled else 'disabling'} invite social users {auth.domo_instance}"
        )

    res = await instance_config_routes.toggle_is_social_users_enabled(
        auth=auth or self.auth,
        is_enabled=is_enabled,
        session=session,
        debug_api=debug_api,
    )

    res_is_enabled = await self.get_is_invite_social_users_enabled()

    if return_raw:
        return res

    return res_is_enabled

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 30
@patch_to(DomoInstanceConfig)
async def get_is_weekly_digest_enabled(
    self: DomoInstanceConfig,
    auth: dmda.DomoFullAuth = None,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 2,
    session: httpx.AsyncClient = None,
):

    res = await instance_config_routes.get_is_weekly_digest_enabled(
        auth=auth or self.auth,
        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
    )

    self.is_weekly_digest_enabled = res.response["is_enabled"]

    if return_raw:
        return res

    return res.response

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 32
@patch_to(DomoInstanceConfig)
async def toggle_is_weekly_digest_enabled(
    self: DomoInstanceConfig,
    is_enabled: bool,
    auth: dmda.DomoFullAuth = None,
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_prn: bool = False,
    debug_num_stacks_to_drop=1,
):
    auth = auth or self.auth

    res_is_enabled = await self.get_is_weekly_digest_enabled(auth=auth)

    if is_enabled == self.is_weekly_digest_enabled:
        if debug_prn:
            print(
                f"weekly digest is already {'enabled' if is_enabled else 'disabled'} in {auth.domo_instance}"
            )
        return res_is_enabled

    if debug_prn:
        print(
            f"{'enabling' if is_enabled else 'disabling'} weekly digest {auth.domo_instance}"
        )

    res = await instance_config_routes.toggle_is_weekly_digest_enabled(
        auth=auth or self.auth,
        is_enabled=is_enabled,
        session=session,
        debug_api=debug_api,
        parent_class=self.__class__.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    res_is_enabled = await self.get_is_weekly_digest_enabled()

    if return_raw:
        return res

    return res_is_enabled

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 35
py310 = sys.version_info.minor >= 10 or sys.version_info.major > 3

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 36
# class SSOConfig_InstantiationError(de.DomoError):
#     def __init__(self, domo_instance, parent_class, function_name, message="invalid data types, check attribute types"):

#         super().__init__(
#             domo_instance=domo_instance,
#             message=message,
#             parent_class=parent_class,
#             function_name=function_name)


@dataclass(**({"slots": True} if py310 else {}))
class SSO_Config:
    auth: dmda.DomoAuth = field(repr=False)

    login_enabled: bool = None  # False
    idp_enabled: bool = None  # False
    import_groups: bool = None  # False
    require_invitation: bool = None  # False
    enforce_allowlist: bool = None  # False
    skip_to_idp: bool = None  # False
    auth_request_endpoint: str = None
    token_endpoint: str = None
    user_info_endpoint: str = None
    public_key: str = None
    redirect_url: str = None
    certificate: str = None
    override_sso: bool = None  # False
    override_embed: bool = None  # False
    # "https://{domo_instance}}.domo.com/auth/oidc"
    well_known_config: str = None
    assertion_endpoint: str = None
    ingest_attributes: bool = None  # False

    # def __post_init__(self):
    #     self.override_sso = self.override_sso or f"https://{auth.domo_instance}.domo.com/auth/oidc"

    @classmethod
    def _from_json(cls, auth: dmda.DomoAuth, obj: dict):
        dd = obj

        if not isinstance(obj, util_dd.DictDot):
            dd = util_dd.DictDot(obj)

        return cls(
            auth=auth,
            login_enabled=dd.loginEnabled,
            idp_enabled=dd.idpEnabled,
            import_groups=dd.importGroups,
            require_invitation=dd.requireInvitation,
            enforce_allowlist=dd.enforceWhitelist,
            skip_to_idp=dd.skipToIdp,
            auth_request_endpoint=dd.authRequestEndpoint,
            token_endpoint=dd.tokenEndpoint,
            user_info_endpoint=dd.userInfoEndpoint,
            public_key=dd.publicKey,
            redirect_url=dd.redirectUrl,
            certificate=dd.certificate,
            override_sso=dd.overrideSSO,
            override_embed=dd.overrideEmbed,
            well_known_config=dd.wellKnownConfig,
            assertion_endpoint=dd.assertionEndpoint,
            ingest_attributes=dd.ingestAttributes,
        )

    def add_attribute(self, overwrite_existing: bool = False, **kwargs):
        [
            setattr(self, key, value)
            for key, value in kwargs.items()
            if value is not None
        ]
        return self

        # except TypeError as e:
        #     traceback_details = lg.get_traceback(num_stacks_to_drop=1)

        #     raise SSOConfig_InstantiationError(
        #         domo_instance=self.auth.domo_instance,
        #         parent_class=self.__class__.__name__,
        #         function_name=traceback_details.function_name)

    def to_json(self, is_include_undefined: bool = False):
        r = {
            "loginEnabled": self.login_enabled,
            "idpEnabled": self.idp_enabled,
            "importGroups": self.import_groups,
            "requireInvitation": self.require_invitation,
            "enforceWhitelist": self.enforce_allowlist,
            "skipToIdp": self.skip_to_idp,
            "authRequestEndpoint": self.auth_request_endpoint,
            "tokenEndpoint": self.token_endpoint,
            "userInfoEndpoint": self.user_info_endpoint,
            "publicKey": self.public_key,
            "redirectUrl": self.redirect_url,
            "certificate": self.certificate,
            "overrideSSO": self.override_sso,
            "overrideEmbed": self.override_embed,
            "wellKnownConfig": self.well_known_config,
            "assertionEndpoint": self.assertion_endpoint,
            "ingestAttributes": self.ingest_attributes,
        }

        if not is_include_undefined:
            return {key: value for key, value in r.items() if value is not None}

        return r

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 38
@patch_to(DomoInstanceConfig)
async def get_sso_config(
    self: DomoInstanceConfig,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    return_raw: bool = False,
):
    res = await instance_config_routes.get_sso_config(
        auth=self.auth,
        session=session,
        parent_class=self.__class__.__name__,
        debug_api=debug_api,
        debug_num_stacks_to_drop=2,
    )

    if return_raw:
        return res

    self.sso_config = SSO_Config._from_json(auth=self.auth, obj=res.response)

    return self.sso_config

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 42
@patch_to(DomoInstanceConfig)
async def update_sso_config(
    self: DomoInstanceConfig,
    login_enabled: bool = None,  # False
    idp_enabled: bool = None,  # False
    import_groups: bool = None,  # False
    require_invitation: bool = None,  # False
    enforce_allowlist: bool = None,  # False
    skip_to_idp: bool = None,  # False
    auth_request_endpoint: str = None,
    token_endpoint: str = None,
    user_info_endpoint: str = None,
    public_key: str = None,
    redirect_url: str = None,
    certificate: str = None,
    override_sso: bool = None,  # False
    override_embed: bool = None,  # False
    # "https://{domo_instance}}.domo.com/auth/oidc"
    well_known_config: str = None,
    assertion_endpoint: str = None,
    ingest_attributes: bool = None,  # False
    debug_is_test: bool = False,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
):
    update_config = await self.get_sso_config()

    update_config.add_attribute(
        overwrite_existing=True,
        login_enabled=login_enabled,
        idp_enabled=idp_enabled,
        import_groups=import_groups,
        require_invitation=require_invitation,
        enforce_allowlist=enforce_allowlist,
        skip_to_idp=skip_to_idp,
        auth_request_endpoint=auth_request_endpoint,
        token_endpoint=token_endpoint,
        user_info_endpoint=user_info_endpoint,
        public_key=public_key,
        redirect_url=redirect_url,
        certificate=certificate,
        override_sso=override_sso,
        override_embed=override_embed,
        well_known_config=well_known_config,
        assertion_endpoint=assertion_endpoint,
        ingest_attributes=ingest_attributes,
    )

    config_body = update_config.to_json()

    if debug_is_test:
        print("‚öóÔ∏è‚ö†Ô∏è This is a test, SSO Config will not be updated")
        return config_body

    res = await instance_config_routes.update_sso_config(
        auth=self.auth,
        config_body=config_body,
        parent_class=self.__class__.__name__,
        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=2,
    )

    # await asyncio.sleep(3)

    await self.get_sso_config()

    errors_obj = {
        update_key: f"expected_value: {str(update_value)  } , current_value: { str(self.sso_config[update_key])}"
        for update_key, update_value in asdict(update_config).items()
        if asdict(self.sso_config)[update_key] != update_value
    }

    if len(errors_obj.keys()) > 0:
        raise instance_config_routes.UpdateSSO_Error(
            domo_instance=self.auth.domo_instance,
            config_body=errors_obj,
            function_name=res.traceback_details.function_name,
            parent_class=self.__class__.__name,
        )

    return self.sso_config

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 46
@patch_to(DomoInstanceConfig, cls_method=True)
async def get_publications(
    cls: DomoInstanceConfig,
    auth: dmda.DomoFullAuth,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    import domolibrary.classes.DomoPublish as dmpb

    res = await publish_routes.search_publications(
        auth=auth, debug_api=debug_api, session=session
    )
    if debug_api:
        print("Getting Publish jobs")

    if res.status == 200 and not return_raw:
        return await ce.gather_with_concurrency(
            n=60,
            *[
                dmpb.DomoPublication.get_from_id(
                    publication_id=job.get("id"), auth=auth
                )
                for job in res.response
            ],
        )

    if res.status == 200 and return_raw:
        return res.response

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 50
@patch_to(DomoInstanceConfig)
async def get_allowlist(
    self: DomoInstanceConfig,
    auth: dmda.DomoFullAuth = None,  # get_allowlist requires full authentication
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
    debug_api: bool = False,
) -> list[str]:
    """retrieves the allowlist for an instance"""

    auth = auth or self.auth

    res = None
    loop = 0

    while not res and loop <= 5:
        try:
            res = await instance_config_routes.get_allowlist(
                auth=auth, debug_api=debug_api, session=session
            )
        except Exception as e:
            print(e)
        finally:
            loop += 1

    if return_raw:
        return res

    if not res.is_success:
        return None

    allowlist = res.response.get("addresses")

    self.allowlist = allowlist

    return allowlist

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 54
@patch_to(DomoInstanceConfig)
async def set_allowlist(
    self: DomoInstanceConfig,
    ip_address_ls: list[str],
    debug_api: bool = False,
    auth: dmda.DomoFullAuth = None,
    session: httpx.AsyncClient = None,
):
    auth = auth or self.auth

    await instance_config_routes.set_allowlist(
        auth=auth, ip_address_ls=ip_address_ls, debug_api=debug_api, session=session
    )

    return await self.get_allowlist(auth=auth, debug_api=debug_api, session=session)


@patch_to(
    DomoInstanceConfig,
)
async def upsert_allowlist(
    self: DomoInstanceConfig,
    ip_address_ls: list[str],
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    auth: dmda.DomoAuth = None,
):
    exist_ip_address_ls = await self.get_allowlist(
        auth=auth, debug_api=debug_api, session=session
    )
    ip_address_ls += exist_ip_address_ls

    return await self.set_allowlist(
        auth=auth,
        ip_address_ls=list(set(ip_address_ls)),
        debug_api=debug_api,
        session=session,
    )

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 59
@patch_to(DomoInstanceConfig)
async def get_grants(
    self: DomoInstanceConfig,
    auth: dmda.DomoAuth = None,
    debug_prn: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    import domolibrary.classes.DomoGrant as dmg

    auth = auth or self.auth

    return await dmg.DomoGrants.get_grants(
        auth=auth, return_raw=return_raw, session=session, debug_api=debug_api
    )

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 62
@patch_to(DomoInstanceConfig)
async def get_roles(
    self,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
):
    import domolibrary.classes.DomoRole as dmr

    auth = auth or self.auth

    return await dmr.DomoRoles.get_roles(
        auth=auth, debug_api=debug_api, return_raw=return_raw, session=session
    )

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 66
@patch_to(DomoInstanceConfig)
async def get_authorized_domains(
    self: DomoInstanceConfig,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    auth = auth or self.auth

    res = await instance_config_routes.get_authorized_domains(
        auth=auth, debug_api=debug_api, session=session, return_raw=return_raw
    )

    if return_raw:
        return res

    return res.response

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 69
@patch_to(DomoInstanceConfig, cls_method=True)
async def set_authorized_domains(
    cls: DomoInstanceConfig,
    auth: dmda.DomoAuth,
    authorized_domains: list[str],
    debug_prn: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    if debug_prn:
        print(f'üå°Ô∏è setting authorized domain with {",".join(authorized_domains)}')

    res = await instance_config_routes.set_authorized_domains(
        auth=auth,
        authorized_domain_ls=authorized_domains,
        debug_api=debug_api,
        session=session,
    )

    if res.status == 200 or res.status == 204:
        dmdic = DomoInstanceConfig(auth=auth)
        res.response = {
            "authorized_domains": await dmdic.get_authorized_domains(
                debug_api=debug_api
            ),
            "status": 200,
        }

    return res


@patch_to(DomoInstanceConfig, cls_method=True)
async def upsert_authorized_domains(
    cls: DomoInstanceConfig,
    auth: dmda.DomoAuth,
    authorized_domains: list[str],
    debug_prn: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    existing_domains = await cls.get_authorized_domains(auth=auth, debug_api=debug_api)

    authorized_domains += existing_domains

    if debug_prn:
        print(f'üå°Ô∏è upsertting authorized domain to {",".join(authorized_domains)}')

    return await cls.set_authorized_domains(
        auth=auth,
        authorized_domains=authorized_domains,
        debug_api=debug_api,
        session=session,
    )

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 71
@patch_to(DomoInstanceConfig)
async def get_authorized_custom_app_domains(
    self: DomoInstanceConfig,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    auth = auth or self.auth

    res = await instance_config_routes.get_authorized_custom_app_domains(
        auth=auth, debug_api=debug_api, session=session, return_raw=return_raw
    )

    if return_raw:
        return res

    return res.response

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 75
@patch_to(DomoInstanceConfig, cls_method=True)
async def set_authorized_custom_app_domains(
    cls: DomoInstanceConfig,
    auth: dmda.DomoAuth,
    authorized_domains: list[str],
    debug_prn: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    if debug_prn:
        print(f'üå°Ô∏è setting authorized domain with {",".join(authorized_domains)}')

    res = await instance_config_routes.set_authorized_custom_app_domains(
        auth=auth,
        authorized_custom_app_domain_ls=authorized_domains,
        debug_api=debug_api,
        session=session,
    )

    if res.status == 200 or res.status == 204:
        dmdic = DomoInstanceConfig(auth=auth)
        res.response = {
            "authorized_domains": await dmdic.get_authorized_custom_app_domains(
                debug_api=debug_api
            ),
            "status": 200,
        }

    return res


@patch_to(DomoInstanceConfig, cls_method=True)
async def upsert_authorized_custom_app_domains(
    cls: DomoInstanceConfig,
    auth: dmda.DomoAuth,
    authorized_domains: list[str],
    debug_prn: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    existing_domains = await cls.get_authorized_custom_app_domains(
        auth=auth, debug_api=debug_api
    )

    authorized_domains += existing_domains

    if debug_prn:
        print(f'üå°Ô∏è upsertting authorized domain to {",".join(authorized_domains)}')

    return await cls.set_authorized_custom_app_domains(
        auth=auth,
        authorized_custom_app_domain_ls=authorized_domains,
        debug_api=debug_api,
        session=session,
    )

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 77
@patch_to(DomoInstanceConfig, cls_method=True)
async def get_applications(
    cls,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
    debug_num_stacks_to_drop=2,
):
    import domolibrary.classes.DomoApplication as dmapp

    res = await application_routes.get_applications(
        auth=auth,
        debug_api=debug_api,
        session=session,
        parent_class=cls.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    if res.status != 200:
        return res

    return [dmapp.DomoApplication._from_json(job) for job in res.response]

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 80
@patch_to(DomoInstanceConfig)
async def generate_applications_report(
    self,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
    debug_num_stacks_to_drop=2,
):
    import domolibrary.classes.DomoApplication as dmapp

    domo_apps = await self.get_applications(
        auth=self.auth,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        return_raw=return_raw,
    )

    if return_raw:
        return domo_apps

    df = pd.DataFrame([app.__dict__ for app in domo_apps])
    df["domo_instance"] = self.auth.domo_instance

    df.drop(columns=["auth"], inplace=True)
    df.rename(
        columns={
            "id": "application_id",
            "name": "application_name",
            "description": "application_description",
            "version": "application_version",
        },
        inplace=True,
    )

    return df.sort_index(axis=1)

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 84
@dataclass
class DomoConnector:
    id: str
    label: str
    title: str
    sub_title: str
    description: str
    create_date: dt.datetime
    last_modified: dt.datetime
    publisher_name: str
    writeback_enabled: bool
    tags: list[str] = field(default_factory=list)
    capabilities: list[str] = field(default_factory=list)

    @classmethod
    def _from_str(cls, obj):
        dd = util_dd.DictDot(obj)

        return cls(
            id=dd.databaseId,
            label=dd.label,
            title=dd.title,
            sub_title=dd.subTitle,
            description=dd.description,
            create_date=cd.convert_epoch_millisecond_to_datetime(dd.createDate),
            last_modified=cd.convert_epoch_millisecond_to_datetime(dd.lastModified),
            publisher_name=dd.publisherName,
            writeback_enabled=dd.writebackEnabled,
            tags=dd.tags,
            capabilities=dd.capabilities,
        )

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 85
@patch_to(DomoInstanceConfig)
async def get_connectors(
    self: DomoInstanceConfig,
    auth: dmda.DomoAuth = None,
    search_text=None,
    additional_filters_ls=None,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: httpx.AsyncClient = None,
):
    import domolibrary.routes.datacenter as datacenter_routes

    res = await datacenter_routes.get_connectors(
        auth=auth or self.auth,
        session=session,
        search_text=search_text,
        additional_filters_ls=additional_filters_ls,
        debug_api=debug_api,
        parent_class=self.__class__.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    return [DomoConnector._from_str(obj) for obj in res.response]

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 88
@patch_to(DomoInstanceConfig)
async def get_access_tokens(
    self: DomoInstanceConfig,
    debug_api: bool = False,
    debug_num_stacks_to_drop=3,
    session: httpx.AsyncClient = None,
):
    import domolibrary.classes.DomoAccessToken as dmat

    domo_tokens = await dmat.get_access_tokens(
        auth=self.auth,
        session=session,
        debug_api=debug_api,
        parent_class=self.__class__.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    self.access_tokens = domo_tokens

    return self.access_tokens

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 90
@patch_to(DomoInstanceConfig)
async def generate_access_token(
    self: DomoInstanceConfig,
    owner: None,  # DomoUser
    duration_in_days: int,
    token_name: str,
    debug_api: bool = False,
    debug_num_stacks_to_drop=3,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    import domolibrary.classes.DomoAccessToken as dmat

    token = await dmat.DomoAccessToken.generate(
        auth=self.auth,
        session=session,
        token_name=token_name,
        debug_api=debug_api,
        parent_class=self.__class__.__name__,
        owner=owner,
        duration_in_days=duration_in_days,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        return_raw=return_raw,
    )

    return token

# %% ../../nbs/classes/50_DomoInstanceConfig.ipynb 92
@patch_to(DomoInstanceConfig)
async def regenerate_access_token(
    self,
    domo_user: None,  # domo_user
    token_name,
    session: httpx.AsyncClient = None,
    duration_in_days: int = 90,
    debug_api: bool = False,
    return_raw: bool = False,
):

    access_tokens = await self.get_access_tokens()

    match_token = next(
        (
            token
            for token in access_tokens
            if token.owner == domo_user and token.name == token_name
        ),
        None,
    )

    if match_token:
        await match_token.revoke()

    domo_access_token = await self.generate_access_token(
        owner=domo_user,
        duration_in_days=duration_in_days,
        token_name=token_name,
        debug_api=debug_api,
        debug_num_stacks_to_drop=3,
        session=session,
        return_raw=return_raw,
    )

    return domo_access_token

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoInstanceConfig_UserAttribute.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoInstanceConfig_UserAttribute.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoInstanceConfig_UserAttributes.ipynb.

# %% auto 0
__all__ = ['UserAttribute', 'UserAttributes']

# %% ../../nbs/classes/50_DomoInstanceConfig_UserAttributes.ipynb 2
from domolibrary.routes.user_attributes import (
    UserAttributes_GET_Error,
    UserAttributes_CRUD_Error,
    UserAttributes_IssuerType,
)

# %% ../../nbs/classes/50_DomoInstanceConfig_UserAttributes.ipynb 3
from dataclasses import dataclass, field

import httpx
from nbdev.showdoc import patch_to
from typing import List, Any

import domolibrary.client.DomoAuth as dmda
import domolibrary.routes.user_attributes as user_attribute_routes

import datetime as dt

# import asyncio
# import sys
# import pandas as pd


# from typing import List

# import domolibrary.utils.DictDot as util_dd
# import domolibrary.utils.chunk_execution as ce

# import domolibrary.client.DomoError as de
# import domolibrary.client.Logger as lg

# import domolibrary.routes.instance_config as instance_config_routes
# import domolibrary.routes.bootstrap as bootstrap_routes
# import domolibrary.routes.sandbox as sandbox_routes
# import domolibrary.routes.publish as publish_routes
# import domolibrary.routes.application as application_routes

# %% ../../nbs/classes/50_DomoInstanceConfig_UserAttributes.ipynb 5
@dataclass
class UserAttribute:
    """utility class that absorbs many of the domo instance configuration methods"""

    auth: dmda.DomoAuth = field(repr=False)
    id: str
    name: str
    description: str

    issuer_type: UserAttributes_IssuerType
    customer_id: str
    value_type: str

    validator: str
    validator_configuration: None

    security_voter: str
    custom: bool

    def __eq__(self, other):
        return self.id == other.id

    @classmethod
    def _from_json(cls, obj, auth):
        return cls(
            auth=auth,
            id=obj["key"],
            name=obj["title"],
            description=obj["description"],
            issuer_type=UserAttributes_IssuerType(obj["keyspace"]),
            customer_id=obj["context"],
            value_type=obj["valueType"],
            validator=obj["validator"],
            validator_configuration=obj["validatorConfiguration"],
            security_voter=obj["securityVoter"],
            custom=obj["custom"],
        )

# %% ../../nbs/classes/50_DomoInstanceConfig_UserAttributes.ipynb 6
@patch_to(UserAttribute, cls_method=True)
async def get_by_id(
    cls: UserAttribute,
    auth: dmda.DomoAuth,
    attribute_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
):
    res = await user_attribute_routes.get_user_attribute_by_id(
        auth=auth,
        attribute_id=attribute_id,
        session=session,
        debug_api=debug_api,
        parent_class=cls.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res
    return cls._from_json(obj=res.response, auth=auth)

# %% ../../nbs/classes/50_DomoInstanceConfig_UserAttributes.ipynb 9
@patch_to(UserAttribute)
async def update(
    self: UserAttribute,
    name=None,
    description=None,
    issuer_type: UserAttributes_IssuerType = None,
    data_type: str = None,
    security_voter=None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
):
    await user_attribute_routes.update_user_attribute(
        auth=self.auth,
        attribute_id=self.id,
        name=name,
        description=description,
        issuer_type=issuer_type,
        data_type=data_type,
        security_voter=security_voter,
        session=session,
        debug_api=debug_api,
        parent_class=self.__class__.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    new = await UserAttribute.get_by_id(attribute_id=self.id, auth=self.auth)

    [setattr(self, key, value) for key, value in new.__dict__.items()]

    return self

# %% ../../nbs/classes/50_DomoInstanceConfig_UserAttributes.ipynb 12
@dataclass
class UserAttributes:
    auth: dmda.DomoAuth = field(repr=False)

    attributes: List[UserAttribute] = field(default=None)

# %% ../../nbs/classes/50_DomoInstanceConfig_UserAttributes.ipynb 13
@patch_to(UserAttributes)
async def get_attributes(
    self: UserAttributes,
    issuer_type_ls: List[
        UserAttributes_IssuerType
    ] = None,  # use `UserAttributes_IssuerType` enum
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
):
    auth = self.auth

    res = await user_attribute_routes.get_user_attributes(
        auth=auth,
        session=session,
        issuer_type_ls=issuer_type_ls,
        debug_api=debug_api,
        parent_class=self.__class__.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    self.attributes = [
        UserAttribute._from_json(obj=obj, auth=auth) for obj in res.response
    ]
    return self.attributes

# %% ../../nbs/classes/50_DomoInstanceConfig_UserAttributes.ipynb 16
@patch_to(UserAttributes)
async def create(
    self: UserAttributes,
    attribute_id: str,
    name=None,
    description=f"updated via domolibrary {dt.datetime.now().strftime('%Y-%m-%d - %H:%M')}",
    data_type: str = "ANY_VALUE",
    security_voter="FULL_VIS_ADMIN_IDP",
    issuer_type: UserAttributes_IssuerType = UserAttributes_IssuerType.CUSTOM,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
):

    auth = self.auth
    attribute_id = user_attribute_routes.clean_attribute_id(attribute_id)

    res = await user_attribute_routes.create_user_attribute(
        auth=auth,
        session=session,
        issuer_type=issuer_type,
        name=name,
        attribute_id=attribute_id,
        description=description,
        data_type=data_type,
        security_voter=security_voter,
        debug_api=debug_api,
        parent_class=self.__class__.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    await self.get_attributes()

    if return_raw:
        return res

    return await UserAttribute.get_by_id(auth=auth, attribute_id=attribute_id)

# %% ../../nbs/classes/50_DomoInstanceConfig_UserAttributes.ipynb 19
@patch_to(UserAttributes)
async def upsert(
    self: UserAttributes,
    attribute_id,
    name=None,
    description=None,
    issuer_type: UserAttributes_IssuerType = None,
    data_type: str = None,
    security_voter=None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    debug_prn: bool = False,
):

    auth = self.auth
    attribute_id = user_attribute_routes.clean_attribute_id(attribute_id)

    user_attribute = None

    try:
        user_attribute = await UserAttribute.get_by_id(
            attribute_id=attribute_id,
            auth=auth,
            session=session,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            debug_api=debug_api,
        )

        if user_attribute:
            if debug_prn:
                print(f"upserting {attribute_id} in {auth.domo_instance}")

            await user_attribute.update(
                name=name,
                description=description,
                issuer_type=issuer_type,
                data_type=data_type,
                security_voter=security_voter,
                session=session,
                debug_api=debug_api,
                debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            )

        return user_attribute

    except (UserAttributes_CRUD_Error, UserAttributes_GET_Error) as e:
        if debug_prn:
            print(f"creating {attribute_id} in {auth.domo_instance}")

        return await self.create(
            attribute_id=attribute_id,
            name=name,
            description=description,
            issuer_type=issuer_type or UserAttributes_IssuerType.CUSTOM,
            data_type=data_type,
            security_voter=security_voter,
            session=session,
            debug_api=debug_api,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop + 1,
        )

    finally:
        await self.get_attributes()

# %% ../../nbs/classes/50_DomoInstanceConfig_UserAttributes.ipynb 21
@patch_to(UserAttributes)
async def delete(
    self: UserAttributes,
    attribute_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
):

    auth = self.auth

    res = await user_attribute_routes.delete_user_attribute(
        auth=auth,
        session=session,
        debug_api=debug_api,
        parent_class=self.__class__.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        attribute_id=attribute_id,
    )

    await self.get_attributes()

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoJupyter.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoJupyter.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoJupyter.ipynb.

# %% auto 0
__all__ = ['DomoJupyterWorkspace_Content', 'DomoJupyterWorkspace', 'DomoJupyter_InvalidWorkspace']

# %% ../../nbs/classes/50_DomoJupyter.ipynb 2
from ..routes.jupyter import JupyterAPI_Error

# %% ../../nbs/classes/50_DomoJupyter.ipynb 3
import os
import json

from dataclasses import dataclass, field
from typing import List
import datetime as dt

import httpx

import domolibrary.utils.DictDot as util_dd
from dateutil.parser import parse

import domolibrary.client.DomoAuth as dmda
import domolibrary.routes.jupyter as jupyter_routes


import domolibrary.client.DomoError as de
import domolibrary.utils.chunk_execution as ce

from nbdev.showdoc import patch_to

# %% ../../nbs/classes/50_DomoJupyter.ipynb 5
@dataclass
class DomoJupyterWorkspace_Content:
    name: str
    folder: str
    last_modified: dt.datetime
    file_type: str
    content: str

    auth: dmda.DomoJupyterAuth = field(repr=False)

    default_export_folder: str = "export"

    def __post_init__(self):
        dmda.test_is_jupyter_auth(self.auth)

        if self.folder.endswith(self.name):
            self.folder = self.folder.replace(self.name, "")

    @classmethod
    def _from_json(cls, obj: dict, auth: dmda.DomoJupyterAuth):
        dd = util_dd.DictDot(obj) if not isinstance(obj, util_dd.DictDot) else obj

        dc = cls(
            name=dd.name,
            folder=dd.path,
            last_modified=parse(dd.last_modified),
            file_type=dd.type,
            auth=auth,
            content=obj.get("content"),
        )

        return dc

    def export(
        self,
        output_folder: str = None,
        file_name: str = None,
        default_export_folder: str = None,
    ):
        if default_export_folder:
            self.default_export_folder = default_export_folder

        output_folder = output_folder or os.path.join(
            self.default_export_folder, self.folder
        )

        file_name = file_name or self.name

        if not os.path.exists(output_folder):
            print(output_folder)
            os.makedirs(output_folder)

        content_str = self.content
        if isinstance(self.content, dict):

            content_str = json.dumps(self.content)

        output_path = os.path.join(output_folder, file_name)
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(content_str)
            f.close()

        return output_path

    async def update(
        self,
        jupyter_folder: str = None,
        jupyter_file_name: str = None,
        debug_api: bool = False,
    ):
        if jupyter_folder and jupyter_file_name:
            content_path = f"{jupyter_folder}/{jupyter_file_name}"

        if len(self.folder) > 0:
            content_path = f"{self.folder}/{self.name}"

        else:
            content_path = self.name

            if content_path.lower().startswith(self.default_export_folder.lower()):
                content_path = content_path.replace(self.default_export_folder, "")

        content_path = "/".join(os.path.normpath(content_path).split(os.sep))

        return await jupyter_routes.update_jupyter_file(
            auth=self.auth,
            content_path=content_path,
            new_content=self.content,
            debug_api=debug_api,
            debug_num_stacks_to_drop=2,
            parent_class=self.__class__.__name__,
        )

# %% ../../nbs/classes/50_DomoJupyter.ipynb 7
@dataclass
class DomoJupyterWorkspace:
    auth: dmda.DomoJupyterAuth = field(repr=False)
    id: str
    name: str
    description: str

    created_dt: dt.datetime
    updated_dt: dt.datetime
    last_run_dt: dt.datetime

    # owner
    # cpu
    # memory

    instances: List[dict] = None
    input_configuration: list[dict] = None
    output_configuration: list[dict] = None
    account_configuration: list[dict] = None
    collection_configuration: list[dict] = None
    fileshare_configuration: list[dict] = None

    content: List[DomoJupyterWorkspace_Content] = field(default=None)

    jupyter_token: str = None
    service_location: str = None
    service_prefix: str = None

    def __post_init__(self):
        self._update_auth_params()

    def _update_auth_params(self):
        if self.instances:
            res = jupyter_routes.parse_instance_service_location_and_prefix(
                self.instances[0], self.auth.domo_instance
            )
            self.service_location = res["service_location"]
            self.service_prefix = res["service_prefix"]

        if self.service_location and self.service_prefix and self.jupyter_token:
            self.update_auth()

    def update_auth(
        self, service_location=None, service_prefix=None, jupyter_token=None
    ):

        self.service_location = service_location or self.service_location
        self.service_prefix = service_prefix or self.service_prefix
        self.jupyter_token = jupyter_token or self.jupyter_token

        if isinstance(self.auth, dmda.DomoFullAuth):
            self.auth = dmda.DomoJupyterFullAuth.convert_auth(
                auth=self.auth,
                service_location=self.service_location,
                jupyter_token=self.jupyter_token,
                service_prefix=self.service_prefix,
            )

        if isinstance(self.auth, dmda.DomoTokenAuth):
            self.auth = dmda.DomoJupyterTokenAuth.convert_auth(
                auth=self.auth,
                service_location=self.service_location,
                jupyter_token=self.jupyter_token,
                service_prefix=self.service_prefix,
            )

        self.auth.service_location = self.service_location
        self.auth.service_prefix = self.service_prefix
        self.auth.jupyter_token = self.jupyter_token

    @classmethod
    def _from_json(
        cls,
        obj,
        auth,
        jupyter_token: str = None,
    ):
        domo_workspace = cls(
            auth=auth,
            id=obj["id"],
            name=obj["name"],
            description=obj["description"],
            created_dt=obj["created"],
            updated_dt=obj["updated"],
            last_run_dt=obj["lastRun"],
            instances=obj["instances"],
            output_configuration=obj["outputConfiguration"],
            account_configuration=obj["accountConfiguration"],
            fileshare_configuration=obj["collectionConfiguration"],
            jupyter_token=jupyter_token,
        )
        return domo_workspace

# %% ../../nbs/classes/50_DomoJupyter.ipynb 8
@patch_to(DomoJupyterWorkspace, cls_method=True)
async def get_by_id(
    cls,
    workspace_id,
    auth: dmda.DomoAuth,  # this API does not require the jupyter_token, but activities inside the workspace will require additional authentication
    jupyter_token=None,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):

    res = await jupyter_routes.get_jupyter_workspace_by_id(
        workspace_id=workspace_id,
        auth=auth,
        session=session,
        debug_api=debug_api,
        parent_class=cls.__name__,
    )

    if return_raw:
        return res

    return cls._from_json(auth=auth, obj=res.response, jupyter_token=jupyter_token)

# %% ../../nbs/classes/50_DomoJupyter.ipynb 10
@patch_to(DomoJupyterWorkspace)
async def get_content(
    self,
    debug_api: bool = False,
    return_raw: bool = False,
    is_recursive: bool = True,
    content_path: str = "",
):
    res = await jupyter_routes.get_content(
        auth=self.auth,
        debug_api=debug_api,
        content_path=content_path,
        debug_num_stacks_to_drop=2,
        parent_class=self.__class__.__name__,
        is_recursive=is_recursive,
        return_raw=return_raw,
    )

    if return_raw:
        return res

    return [
        DomoJupyterWorkspace_Content._from_json(obj, auth=self.auth)
        for obj in res.response
    ]

# %% ../../nbs/classes/50_DomoJupyter.ipynb 17
class DomoJupyter_InvalidWorkspace(de.DomoError):
    def __init__(self, message, domo_instance):
        super().__init__(message, domo_instance)

# %% ../../nbs/classes/50_DomoJupyter.ipynb 18
@patch_to(DomoJupyterWorkspace, cls_method=True)
async def get_current_workspace(
    cls: DomoJupyterWorkspace,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    try:
        workspace_id = os.environ["DOMO_WORKSPACE_ID"]

    except KeyError as e:
        raise DomoJupyter_InvalidWorkspace(
            message="key error | workspace id not found.  This only works in Domo Jupyter Workspaces",
            domo_instance=auth.domo_instance,
        )

    return await cls.get_by_id(
        workspace_id=workspace_id, auth=auth, debug_api=debug_api, session=session
    )


@patch_to(DomoJupyterWorkspace)
async def get_accounts(
    self: DomoJupyterWorkspace,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
):
    import domolibrary.classes.DomoAccount as dmac

    async def _get_accounts(account_id, auth, props, session, debug_api):
        domo_account = await dmac.DomoAccount.get_by_id(
            account_id=account_id, auth=auth, session=session, debug_api=debug_api
        )
        domo_account.alias = props["alias"]
        return domo_account

    self.domo_accounts_config = await ce.gather_with_concurrency(
        *[
            _get_accounts(
                account_id=account_obj["account_id"],
                auth=self.auth,
                props=account_obj,
                session=session,
                debug_api=debug_api,
            )
            for account_obj in self.account_configuration
        ],
        n=5
    )
    return self.domo_accounts_config

# %% ../../nbs/classes/50_DomoJupyter.ipynb 19
@patch_to(DomoJupyterWorkspace)
async def download_workspace_content(
    self: DomoJupyterWorkspace, base_export_folder=None
) -> str:
    """retrieves content from Domo Jupyter Workspace and downloads to a local folder"""

    base_export_folder = base_export_folder or f"{self.auth.domo_instance}/{self.name}"

    all_content = await self.get_content()
    all_content = [
        content for content in all_content if content.file_type != "directory"
    ]

    return [
        content.export(default_export_folder=base_export_folder)
        for content in all_content
    ]

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoLineage.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoLineage.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoLineage.ipynb.

# %% auto 0
__all__ = ['DomoLineage_Type', 'DomoLineage']

# %% ../../nbs/classes/50_DomoLineage.ipynb 2
from dataclasses import dataclass, field
from enum import Enum
from typing import List

import re
import httpx

import domolibrary.client.DomoAuth as dmda
import domolibrary.classes.DomoDatacenter as dmdc

import domolibrary.routes.datacenter as datacenter_routes

import domolibrary.utils.chunk_execution as ce

from nbdev.showdoc import patch_to

# %% ../../nbs/classes/50_DomoLineage.ipynb 4
class DomoLineage_Type(Enum):
    DomoDataflow = "DATAFLOW"
    DomoDataset = "DATA_SOURCE"
    DomoPublication = "PUBLICATION"


@dataclass
class DomoLineage:
    parent: any = field(repr=False)

    auth: dmda.DomoAuth = field(repr=False, default=None)

    page_id_ls: List[str] = field(default_factory=list)
    card_id_ls: List[str] = field(default_factory=list)

    dataflow_id_ls: List[str] = field(default_factory=list)
    dataset_id_ls: List[str] = field(default_factory=list)

    entity_ls: List[any] = field(default_factory=list)

    def __post_init__(self):
        self.auth = self.auth or self.parent.auth

# %% ../../nbs/classes/50_DomoLineage.ipynb 5
@patch_to(DomoLineage)
async def get_entity_lineage_upstream(
    self: DomoLineage,
    entity_id=None,
    entity_type=None,
    auth: dmda.DomoAuth = None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_prn: bool = False,
    return_raw: bool = False,
):
    import domolibrary.classes.DomoDataflow as dmdf
    import domolibrary.classes.DomoDataset as dmds

    entity_id = entity_id or self.parent.id
    entity_type = entity_type or DomoLineage_Type[self.parent.__class__.__name__].value

    auth = auth or self.auth

    res = await datacenter_routes.get_lineage_upstream(
        auth=auth,
        entity_type=entity_type,
        entity_id=entity_id,
        session=session,
        debug_api=debug_api,
    )
    if return_raw or res.status != 200:
        return res

    ## reset
    self.entity_ls = []
    self.dataset_id_ls = []
    self.dataflow_id_ls = []

    for key, item in res.response.items():
        entity_type = item["type"]
        entity_id = item["id"]

        if entity_type == "DATA_SOURCE":
            if entity_id not in self.dataset_id_ls:
                self.dataset_id_ls.append(entity_id)

                domo_ds = await dmds.DomoDataset.get_from_id(
                    auth=auth, dataset_id=entity_id
                )

                self.entity_ls.append(domo_ds)

        if entity_type == "DATAFLOW":
            if entity_id not in self.dataflow_id_ls:
                self.dataflow_id_ls.append(entity_id)

                domo_df = await dmdf.DomoDataflow.get_from_id(
                    auth=auth, dataflow_id=entity_id
                )

                self.entity_ls.append(domo_df)

    return self.entity_ls

# %% ../../nbs/classes/50_DomoLineage.ipynb 7
@patch_to(DomoLineage)
async def _get_page_card_ids(self: DomoLineage):
    import domolibrary.classes.DomoPage as dmpg

    if not self.parent.content_page_id_ls or len(self.parent.content_page_id_ls) == 0:
        return None

    page_card_ls = await ce.gather_with_concurrency(
        n=60,
        *[
            dmpg.DomoPage.get_cards(page_id=page_id, auth=self.parent.auth)
            for page_id in self.parent.content_page_id_ls
        ]
    )

    if not page_card_ls or len(page_card_ls) == 0:
        return

    if not self.card_id_ls:
        self.card_id_ls = []

    for page in page_card_ls:
        if page and len(page) > 0:
            for card in page:
                if card.id not in self.card_id_ls:
                    self.card_id_ls.append(card.id)

    return self.card_id_ls

# %% ../../nbs/classes/50_DomoLineage.ipynb 9
@patch_to(DomoLineage)
def _get_content_list_ls(self: DomoLineage, regex_pattern_ls=None):
    regex_pattern_ls = regex_pattern_ls or [".*_id_ls$", "^content_.*"]

    content_list_ls = [
        content_list
        for content_list in dir(self.parent)
        if all([re.match(pattern, content_list) for pattern in regex_pattern_ls])
    ]

    result = []
    for content_name in content_list_ls:
        if (
            not getattr(self.parent, content_name)
            or len(getattr(self.parent, content_name)) == 0
        ):
            continue

        base_name = content_name
        [
            base_name := re.sub(regex_pattern.replace(".*", ""), "", base_name)
            for regex_pattern in regex_pattern_ls
        ]

        result.append(
            {
                "list_name": content_name,
                "entity_name": base_name,
                "regex_pattern_ls": regex_pattern_ls,
            }
        )
    return result


@patch_to(DomoLineage)
def _reset_lineage_and_sync_parent(self):

    content_list = self._get_content_list_ls()

    for content_obj in content_list:

        parent_content = getattr(self.parent, content_obj.get("list_name"))

        lineage_content_name = f"{content_obj.get('entity_name')}_id_ls"

        setattr(self, lineage_content_name, parent_content)
    return self


@patch_to(DomoLineage)
async def get(
    self: DomoLineage,
    debug_prn: bool = False,
    debug_api: bool = False,
    auth: dmda.DomoAuth = None,
    session=httpx.AsyncClient,
):

    auth = auth or self.parent.auth

    self._reset_lineage_and_sync_parent()

    if self.page_id_ls:
        await self._get_page_card_ids()


#     if self.card_id_ls and len(self.card_id_ls) > 0:
#         if debug_prn:
#             print(f'üèÅ getting card lineage for repo {self.id}')
#         await self._get_entity_ls_lineage(domo_entity=dmdc.DomoEntity.CARD,
#                                           full_auth=full_auth,
#                                           debug_prn=debug_prn, debug=debug, session=session)

#     if self.dataflow_id_ls and len(self.dataflow_id_ls) > 0:
#         if debug_prn:
#             print(f'üèÅ getting dataflow lineage for repo {self.id}')

#         await self._get_entity_ls_lineage(domo_entity=dmdc.DomoEntity.DATAFLOW,
#                                           full_auth=full_auth,
#                                           debug_prn=debug_prn, debug=debug, session=session)

#     if self.dataset_id_ls and len(self.dataset_id_ls) > 0:
#         if debug_prn:
#             print(f'üèÅ getting dataset lineage for repo {self.id}')

#         await self._get_entity_ls_lineage(domo_entity=dmdc.DomoEntity.DATASET,
#                                           full_auth=full_auth,
#                                           debug_prn=debug_prn, debug=debug, session=session)

#     return self

# %% ../../nbs/classes/50_DomoLineage.ipynb 11
@patch_to(DomoLineage)
def _flatten_lineage(self):
    attribute_ls = _get_content_list_ls(self, [".*_id_ls$"])

    output_ls = []

    for attribute in attribute_ls:
        ls_name = attribute.get("list_name")
        entity_name = attribute.get("entity_name")
        entity_type = dmdc.DomoEntity[entity_name.upper()].value

        row_ls = [
            {"entity_type": entity_type, "entity_id": row}
            for row in getattr(self, ls_name)
        ]
        output_ls += row_ls

    return output_ls

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoPage.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoPage.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoPage.ipynb.

# %% auto 0
__all__ = ['DomoPage', 'DomoPages', 'Page_NoAccess']

# %% ../../nbs/classes/50_DomoPage.ipynb 2
from ..routes.page import PageRetrieval_byId_Error

# %% ../../nbs/classes/50_DomoPage.ipynb 3
from nbdev.showdoc import patch_to
from dataclasses import dataclass, field
from typing import List

import httpx

import domolibrary.client.Logger as lg
import domolibrary.client.DomoError as de
import domolibrary.client.DomoAuth as dmda
import domolibrary.classes.DomoPage_Content as dmpg_c
import domolibrary.routes.page as page_routes

import domolibrary.utils.DictDot as util_dd
import domolibrary.utils.chunk_execution as ce

# %% ../../nbs/classes/50_DomoPage.ipynb 6
@dataclass(
    # frozen = True
)
class DomoPage:
    id: int
    title: str = None
    top_page_id: int = None
    parent_page_id: int = None
    auth: dmda.DomoAuth = field(default=None, repr=False)
    is_locked: bool = None

    collections: list = field(default_factory=list)

    owners: list = field(default_factory=list)
    cards: list = field(default_factory=list)

    custom_attributes: dict = field(default_factory=dict)

    # parent_page: dict = None  # DomoPage
    # top_page: dict = None  # DomoPage
    # children: list = field(default_factory=list)
    # parent_hierarchy: [dict] = None
    # flat_children: list = None

    layout: dmpg_c.PageLayout = field(default_factory=dict)

    def display_url(self):
        return f"https://{self.auth.domo_instance}.domo.com/page/{self.id}"

    async def _get_domo_owners_from_dd(self, owners: util_dd.DictDot):
        if not owners or len(owners) == 0:
            return []

        import domolibrary.classes.DomoUser as dmu
        import domolibrary.classes.DomoGroup as dmg

        domo_groups = []
        domo_users = []

        owner_group_ls = [
            owner.id for owner in owners if owner.type == "GROUP" and owner.id
        ]

        if len(owner_group_ls) > 0:
            domo_groups = await ce.gather_with_concurrency(
                n=60,
                *[
                    dmg.DomoGroup.get_by_id(group_id=group_id, auth=self.auth)
                    for group_id in owner_group_ls
                ],
            )

        owner_user_ls = [
            owner.id for owner in owners if owner.type == "USER" and owner.id
        ]

        if len(owner_user_ls) > 0:
            domo_users = await dmu.DomoUsers.by_id(
                user_ids=owner_user_ls, only_allow_one=False, auth=self.auth
            )

        owner_ce = (domo_groups or []) + (domo_users or [])

        res = []
        for owner in owner_ce:
            if isinstance(owner, list):
                [res.append(member) for member in owner]
            else:
                res.append(owner)

        return res

# %% ../../nbs/classes/50_DomoPage.ipynb 7
@patch_to(DomoPage, cls_method=True)
async def _from_adminsummary(cls, page_obj, auth: dmda.DomoAuth):
    import domolibrary.classes.DomoCard as dmc

    dd = page_obj

    if isinstance(page_obj, dict):
        dd = util_dd.DictDot(page_obj)

    pg = cls(
        id=int(dd.id or dd.pageId),
        title=dd.title or dd.pageTitle,
        parent_page_id=int(dd.parentPageId) if dd.parentPageId else None,
        top_page_id=int(dd.topPageId) if dd.topPageId else None,
        collections=dd.collections,
        is_locked=dd.locked,
        auth=auth,
    )

    if dd.page and dd.page.owners and len(dd.page.owners) > 0:
        pg.owners = await pg._get_domo_owners_from_dd(dd.page.owners)

    if dd.cards and len(dd.cards) > 0:
        pg.cards = await ce.gather_with_concurrency(
            n=60,
            *[dmc.DomoCard.get_from_id(id=card.id, auth=auth) for card in dd.cards],
        )

    return pg

# %% ../../nbs/classes/50_DomoPage.ipynb 8
@patch_to(DomoPage, cls_method=True)
async def _from_bootstrap(cls: DomoPage, page_obj, auth: dmda.DomoAuth = None):
    dd = page_obj
    if isinstance(page_obj, dict):
        dd = util_dd.DictDot(page_obj)

    pg = cls(id=int(dd.id), title=dd.title, auth=auth)

    if isinstance(dd.owners, list) and len(dd.owners) > 0:
        pg.owners = await pg._get_domo_owners_from_dd(dd.owners)

    if isinstance(dd.children, list) and len(dd.children) > 0:
        pg.children = await ce.gather_with_concurrency(
            n=60,
            *[
                cls._from_bootstrap(page_obj=child_dd, auth=auth)
                for child_dd in dd.children
                if child_dd.type == "page"
            ],
        )

        [print(other_dd) for other_dd in dd.children if other_dd.type != "page"]

    return pg

# %% ../../nbs/classes/50_DomoPage.ipynb 10
@dataclass
class DomoPages:
    @classmethod
    async def get_pages(
        cls,
        auth=dmda.DomoAuth,
        return_raw: bool = False,
        debug_loop: bool = False,
        debug_api: bool = False,
        session: httpx.AsyncClient = None,
    ):
        """use admin_summary to retrieve all pages in an instance -- regardless of user access
        NOTE: some Page APIs will not return results if page access isn't explicitly shared
        """
        is_close_session = False if session else True

        session = session or httpx.AsyncClient()

        try:
            res = await page_routes.get_pages_adminsummary(
                auth=auth, debug_loop=False, debug_api=False, session=session
            )

            if return_raw:
                return res

            if not res.is_success:
                raise Exception("unable to retrieve pages")

            return await ce.gather_with_concurrency(
                n=60,
                *[
                    DomoPage._from_adminsummary(page_obj, auth=auth)
                    for page_obj in res.response
                ],
            )

        finally:
            if is_close_session:
                await session.aclose()

# %% ../../nbs/classes/50_DomoPage.ipynb 14
@patch_to(DomoPage, cls_method=True)
async def _from_content_stacks_v3(cls: DomoPage, page_obj, auth: dmda.DomoAuth = None):
    # import domolibrary.classes.DomoCard as dc

    dd = page_obj
    if isinstance(page_obj, dict):
        dd = util_dd.DictDot(page_obj)

    pg = cls(
        id=int(dd.id),
        title=dd.title,
        parent_page_id=int(dd.page.parentPageId) if dd.page.parentPageId else None,
        collections=dd.collections,
        auth=auth,
    )

    if hasattr(dd, "pageLayoutV4") and dd.pageLayoutV4 is not None:
        pg.layout = dmpg_c.PageLayout._from_json(dd=dd.pageLayoutV4)

    if dd.page.owners and len(dd.page.owners) > 0:
        pg.owners = await pg._get_domo_owners_from_dd(dd.page.owners)

    # if dd.cards and len(dd.cards) > 0:
    #     pg.cards = await asyncio.gather(
    #         *[dc.DomoCard.get_from_id(id=card.id, auth=auth) for card in dd.cards])

    return pg


class DomoPage_GetRecursive(de.DomoError):
    def __init__(
        self,
        include_recursive_children,
        include_recursive_parents,
        page_id,
        domo_instance,
        function_name,
        parent_class,
    ):
        super().__init__(
            domo_instance=domo_instance,
            function_name=function_name,
            parent_class=parent_class,
            message=f"error retrieving {page_id} can only trace parents OR children recursively but not both. include_recursive_children : {include_recursive_children}, include_recursive_parents: {include_recursive_parents}",
        )


@patch_to(DomoPage, cls_method=True)
async def get_by_id(
    cls: DomoPage,
    page_id: str,
    auth: dmda.DomoAuth,
    return_raw: bool = False,
    debug_api: bool = False,
    include_layout: bool = False,
    # if True, will drill down to all the Children.  Set to False to prevent calculating children
    include_recursive_children: bool = True,
    include_recursive_parents: bool = False,
):
    # can only trace upstream or downstream but not both
    if include_recursive_children and include_recursive_parents:
        traceback_details = lg.get_traceback()

        raise DomoPage_GetRecursive(
            include_recursive_children=include_recursive_children,
            include_recursive_parents=include_recursive_parents,
            page_id=page_id,
            domo_instance=auth.domo_instance,
            function_name=traceback_details.function_name,
            parent_class=cls.__name__,
        )

    res = await page_routes.get_page_by_id(
        auth=auth, page_id=page_id, debug_api=debug_api, include_layout=include_layout
    )

    if return_raw:
        return res

    if not res.is_success:
        return None

    pg = await cls._from_content_stacks_v3(page_obj=res.response, auth=auth)

    pg.custom_attributes["parent_page"] = None
    pg.custom_attributes["top_page"] = None

    if pg.parent_page_id and include_recursive_parents:
        pg.custom_attributes["parent_page"] = await cls.get_by_id(
            auth=auth,
            page_id=pg.parent_page_id,
            include_recursive_parents=include_recursive_parents,
            include_recursive_children=False,
        )

        if pg.custom_attributes["parent_page"]:
            pg.custom_attributes["parent_hierarchy"] = pg.get_parent_hierarchy()

            pg.custom_attributes["top_page"] = pg.custom_attributes["parent_hierarchy"][
                -1
            ]["page"]
            pg.top_page_id = pg.custom_attributes["parent_hierarchy"][-1]["page"].id

    if include_recursive_children:
        await pg.get_children(
            include_recursive_children=include_recursive_children,
        )
        pg.flat_children = pg.flatten_children()

    return pg


@patch_to(DomoPage)
def get_parent_hierarchy(self: DomoPage, path=None, hierarchy=0, results=None):
    results = results or []

    path = path or self.title

    results.append({"hierarchy": hierarchy, "path": path, "page": self})

    if self.custom_attributes["parent_page"]:
        path = f"{path} > {self.custom_attributes['parent_page'].title}"
        self.custom_attributes["parent_page"].get_parent_hierarchy(
            path, hierarchy + 1, results
        )

    return results


@patch_to(DomoPage)
async def get_children(self: DomoPage, include_recursive_children: bool = False):
    all_pages = await DomoPages.get_pages(auth=self.auth)

    self.children = await ce.gather_with_concurrency(
        n=10,
        *[
            DomoPage.get_by_id(
                page_id=page.id,
                auth=self.auth,
                include_recursive_children=include_recursive_children,
                include_recursive_parents=False,
            )
            for page in all_pages
            if page.parent_page_id == self.id
        ],
    )

    return self.children


@patch_to(DomoPage)
def flatten_children(self: DomoPage, path=None, hierarchy=0, results=None):
    results = results or []

    path = f"{path} > {self.title}" if path else self.title

    results.append({"hierarchy": hierarchy, "path": path, "page": self})

    if self.children:
        [
            child.flatten_children(path, hierarchy + 1, results)
            for child in self.children
        ]

    return results

# %% ../../nbs/classes/50_DomoPage.ipynb 22
class Page_NoAccess(de.DomoError):
    def __init__(self, page_id, page_title, domo_instance, function_name, parent_class):
        super().__init__(
            function_name=function_name,
            parent_class=parent_class,
            domo_instance=domo_instance,
            message=f'authenticated user doesn\'t have access to {page_id} - "{page_title}" contact owners to share access',
        )

# %% ../../nbs/classes/50_DomoPage.ipynb 23
@patch_to(DomoPage)
async def test_page_access(
    self: DomoPage,
    suppress_no_access_error: bool = False,  # suppresses error if user doesn't have access
    debug_api: bool = False,
    return_raw: bool = False,
):
    """throws an error if user doesn't have access to the page
    API returns the owners of the page
    """

    res = await page_routes.get_page_access_test(auth=self.auth, page_id=self.id)

    try:
        page_access = res.response.get("pageAccess")

        if not page_access:
            raise Page_NoAccess(
                page_id=self.id,
                page_title=self.title,
                domo_instance=self.auth.domo_instance,
                function_name=res.traceback_details.function_name,
                parent_class=self.__class__.__name__,
            )

    except Page_NoAccess as e:
        print(e)

        if not suppress_no_access_error:
            raise e

    return res

# %% ../../nbs/classes/50_DomoPage.ipynb 27
@patch_to(DomoPage)
async def get_accesslist(
    self,
    auth: dmda.DomoAuth = None,
    return_raw: bool = False,
    debug_api: bool = False,
):
    auth = auth or self.auth

    res = await page_routes.get_page_access_list(
        auth=auth,
        is_expand_users=True,
        page_id=self.id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=2,
        parent_class=self.__class__.__name__,
    )

    if return_raw:
        return res

    if not res.is_success:
        raise Exception("error getting access list")

    import domolibrary.classes.DomoUser as dmu
    import domolibrary.classes.DomoGroup as dmg

    s = {
        "explicit_shared_user_count": res.response.get("explicitSharedUserCount"),
        "total_user_count": res.response.get("totalUserCount"),
    }

    user_ls = res.response.get("users", None)
    domo_users = []
    if user_ls and isinstance(user_ls, list) and len(user_ls) > 0:
        domo_users = await dmu.DomoUsers.by_id(
            user_ids=[user.get("id") for user in user_ls],
            only_allow_one=False,
            auth=auth,
        )

    group_ls = res.response.get("groups", None)
    domo_groups = []
    if group_ls and isinstance(group_ls, list) and len(group_ls) > 0:
        domo_groups = await ce.gather_with_concurrency(
            n=60,
            *[
                dmg.DomoGroup.get_by_id(group_id=group.get("id"), auth=auth)
                for group in group_ls
            ],
        )

    res = await self.test_page_access(suppress_no_access_error=True)
    owner_ls = res.response["owners"]  # from test_page_access

    for domo_user in domo_users:
        # isExplicitShare is set by the get_access_list API response
        domo_user.custom_attributes["is_explicit_share"] = next(
            (
                user_obj["isExplicitShare"]
                for user_obj in user_ls
                if int(user_obj.get("id")) == int(domo_user.id)
            )
        )

        # group membership is determined by get_access_list API response
        domo_user.custom_attributes["group_membership"] = [
            domo_group
            for group_obj in group_ls
            for domo_group in domo_groups
            if int(domo_user.id)
            in [int(user_obj["id"]) for user_obj in group_obj.get("users")]
            and domo_group.id == group_obj["id"]
        ]

        # isOwner determined by test_access API response and group membership
        domo_user.custom_attributes["is_owner"] = False

        # test ownership as a user
        match_owner = next(
            (
                owner_obj
                for owner_obj in owner_ls
                if int(owner_obj["id"]) == int(domo_user.id)
                and owner_obj["type"] == "USER"
            ),
            None,
        )

        match_group = next(
            (
                owner_obj
                for owner_obj in owner_ls
                if int(owner_obj["id"])
                in [
                    int(domo_group.id)
                    for domo_group in domo_user.custom_attributes["group_membership"]
                ]
                and owner_obj["type"] == "GROUP"
            ),
            None,
        )

        if match_owner or match_group:
            domo_user.custom_attributes["is_owner"] = True

    # group ownership is confirmed test_access API
    for domo_group in domo_groups:
        match_owner = next(
            (
                owner_obj
                for owner_obj in owner_ls
                if int(owner_obj["id"]) == int(domo_group.id)
                and owner_obj["type"] == "GROUP"
            ),
            None,
        )

        domo_group.custom_attributes["is_owner"] = True if match_owner else False

    return {
        **s,
        "domo_users": domo_users,
        "domo_groups": domo_groups,
    }

# %% ../../nbs/classes/50_DomoPage.ipynb 30
@patch_to(DomoPage)
async def share(
    self: DomoPage,
    auth: dmda.DomoAuth = None,
    domo_users: list = None,  # DomoUsers to share page with,
    domo_groups: list = None,  # DomoGroups to share page with
    message: str = None,  # message for automated email
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    import domolibrary.routes.datacenter as datacenter_routes

    if domo_groups:
        domo_groups = domo_groups if isinstance(domo_groups, list) else [domo_groups]
    if domo_users:
        domo_users = domo_users if isinstance(domo_users, list) else [domo_users]

    res = await datacenter_routes.share_resource(
        auth=auth or self.auth,
        resource_ids=[self.id],
        resource_type=datacenter_routes.ShareResource_Enum.PAGE,
        group_ids=[group.id for group in domo_groups] if domo_groups else None,
        user_ids=[user.id for user in domo_users] if domo_users else None,
        message=message,
        debug_api=debug_api,
        session=session,
    )

    return res

# %% ../../nbs/classes/50_DomoPage.ipynb 33
@patch_to(DomoPage, cls_method=True)
async def get_cards(
    cls,
    auth: dmda.DomoAuth,
    page_id,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    import domolibrary.classes.DomoCard as dc

    res = await page_routes.get_page_definition(
        auth=auth, page_id=page_id, debug_api=debug_api, session=session
    )

    if res.status != 200:
        raise Exception(
            f"unable to retrieve page definition for {page_id} in {auth.domo_instance}"
        )

    if len(res.response.get("cards")) == 0:
        return []

    return await ce.gather_with_concurrency(
        n=60,
        *[
            dc.DomoCard.get_by_id(card_id=card["id"], auth=auth)
            for card in res.response.get("cards")
        ],
    )


@patch_to(DomoPage, cls_method=True)
async def get_datasets(
    cls,
    auth: dmda.DomoAuth,
    page_id,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    import domolibrary.classes.DomoDataset as dmds

    res = await page_routes.get_page_definition(
        auth=auth, page_id=page_id, debug_api=debug_api, session=session
    )

    if res.status != 200:
        raise Exception(
            f"unable to retrieve datasets for page {page_id} in {auth.domo_instance}"
        )

    if len(res.response.get("cards")) == 0:
        return []

    return await ce.gather_with_concurrency(
        n=60,
        *[
            dmds.DomoDataset.get_from_id(dataset_id=ds.get("dataSourceId"), auth=auth)
            for card in res.response.get("cards")
            for ds in card.get("datasources")
        ],
    )

# %% ../../nbs/classes/50_DomoPage.ipynb 36
from datetime import datetime
from domolibrary.utils import convert


@patch_to(DomoPage, cls_method=True)
async def update_layout(
    cls, auth: dmda.DomoAuth, body: dict, layout_id: str, debug_api: bool = False
):
    datetime_now = datetime.now()
    start_time_epoch = convert.convert_datetime_to_epoch_millisecond(datetime_now)

    res_writelock = await page_routes.put_writelock(
        auth=auth,
        layout_id=layout_id,
        user_id=auth.user_id,
        epoch_time=start_time_epoch,
    )
    if res_writelock.status == 200:
        res = await page_routes.update_page_layout(
            auth=auth, body=body, layout_id=layout_id, debug_api=debug_api
        )

        if not res.is_success:
            return False

        res_writelock = await page_routes.delete_writelock(
            auth=auth, layout_id=layout_id
        )
        if res_writelock.status != 200:
            return False

    else:
        return False

    return True

# %% ../../nbs/classes/50_DomoPage.ipynb 39
@patch_to(DomoPage, cls_method=True)
async def add_page_owner(
    cls,
    auth: dmda.DomoAuth,
    page_id_ls: List[int],  # Page IDs to be updated by owner,
    group_id_ls: List[int],  # DomoGroup IDs to share page with
    user_id_ls: List[int],  # DomoUser IDs to share page with
    note: str = None,  # message for automated email
    send_email: bool = False,  # send or not email to the new owners
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    res = await page_routes.add_page_owner(
        auth=auth,
        page_id_ls=page_id_ls,
        group_id_ls=group_id_ls,
        user_id_ls=user_id_ls,
        note=note,
        send_email=send_email,
        debug_api=debug_api,
        session=session,
    )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoPage_Content.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoPage_Content.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoPage_Content.ipynb.

# %% auto 0
__all__ = []

# %% ../../nbs/classes/50_DomoPage_Content.ipynb 2
from nbdev.showdoc import patch_to
from dataclasses import dataclass, field

import asyncio
import httpx

import domolibrary.client.DomoAuth as dmda

import domolibrary.routes.page as page_routes

import domolibrary.utils.DictDot as util_dd
import domolibrary.utils.chunk_execution as ce

# %% ../../nbs/classes/50_DomoPage_Content.ipynb 6
@dataclass
class PageLayoutTemplate:
    content_key: int
    x: int
    y: int
    width: int
    height: int
    type: str
    virtual: bool
    virtual_appendix: bool

    @classmethod
    def _from_json(cls, dd):
        return cls(
            content_key=dd.contentKey,
            x=dd.x,
            y=dd.y,
            width=dd.width,
            height=dd.height,
            type=dd.type,
            virtual=dd.virtual,
            virtual_appendix=dd.virtualAppendix,
        )

    def get_body(self):
        return {
            "contentKey": self.content_key,
            "x": self.x,
            "y": self.y,
            "width": self.width,
            "height": self.height,
            "type": self.type,
            "virtual": self.virtual,
            "virtualAppendix": self.virtual_appendix,
        }

# %% ../../nbs/classes/50_DomoPage_Content.ipynb 7
@dataclass
class PageLayoutBackground:
    id: int
    crop_height: int
    crop_width: int
    x: int
    y: str
    data_file_id: int
    image_brightness: int
    image_height: int
    image_width: int
    selected_color: str
    text_color: str
    type: str
    is_darkMode: bool
    alpha: float
    src: str

    @classmethod
    def _from_json(cls, dd):
        if dd is not None:
            return cls(
                id=dd.id,
                crop_height=dd.cropHeight,
                crop_width=dd.cropWidth,
                x=dd.x,
                y=dd.y,
                data_file_id=dd.dataFileId,
                image_brightness=dd.imageBrightness,
                image_height=dd.imageHeight,
                image_width=dd.imageWidth,
                selected_color=dd.selectedColor,
                text_color=dd.textColor,
                type=dd.type,
                is_darkMode=dd.darkMode,
                alpha=dd.alpha,
                src=dd.src,
            )
        else:
            return None

    def get_body(self):
        return {
            "id": self.id,
            "cropHeight": self.crop_height,
            "cropWidth": self.crop_width,
            "x": self.x,
            "y": self.y,
            "dataFileId": self.data_file_id,
            "imageBrightness": self.image_brightness,
            "imageHeight": self.image_height,
            "imageWidth": self.image_width,
            "selectedColor": self.selected_color,
            "textColor": self.text_color,
            "type": self.type,
            "darkMode": self.is_darkMode,
            "alpha": self.alpha,
            "src": self.src,
        }

# %% ../../nbs/classes/50_DomoPage_Content.ipynb 9
@dataclass
class PageLayoutContent:
    accept_date_filter: bool
    accept_filters: bool
    accept_segments: bool
    card_id: int
    card_urn: str
    compact_interaction_default: bool
    content_key: int
    fit_to_frame: bool
    has_summary: bool
    hide_border: bool
    hide_description: bool
    hide_footer: bool
    hide_margins: bool
    hide_summary: bool
    hide_timeframe: bool
    hide_title: bool
    hide_wrench: bool
    id: int
    summary_number_only: bool
    type: str
    text: str
    background_id: int
    background: PageLayoutBackground

    @classmethod
    def _from_json(cls, dd):
        return cls(
            accept_date_filter=dd.acceptDateFilter,
            accept_filters=dd.acceptFilters,
            accept_segments=dd.acceptSegments,
            card_id=dd.cardId,
            card_urn=dd.cardUrn,
            compact_interaction_default=dd.compactInteractionDefault,
            content_key=dd.contentKey,
            fit_to_frame=dd.fitToFrame,
            has_summary=dd.hasSummary,
            hide_border=dd.hideBorder,
            hide_description=dd.hideDescription,
            hide_footer=dd.hideFooter,
            hide_margins=dd.hideMargins,
            hide_summary=dd.hideSummary,
            hide_timeframe=dd.hideTimeframe,
            hide_title=dd.hideTitle,
            hide_wrench=dd.hideWrench,
            id=dd.id,
            summary_number_only=dd.summaryNumberOnly,
            type=dd.type,
            text=dd.text,
            background_id=dd.backgroundId,
            background=PageLayoutBackground._from_json(dd=dd.background),
        )

    def get_body(self):
        body = {
            "acceptDateFilter": self.accept_date_filter,
            "acceptFilters": self.accept_filters,
            "acceptSegments": self.accept_segments,
            "cardId": self.card_id,
            "cardUrn": self.card_urn,
            "compactInteractionDefault": self.compact_interaction_default,
            "contentKey": self.content_key,
            "fitToFrame": self.fit_to_frame,
            "hasSummary": self.has_summary,
            "hideBorder": self.hide_border,
            "hideDescription": self.hide_description,
            "hideFooter": self.hide_footer,
            "hideMargins": self.hide_margins,
            "hideSummary": self.hide_summary,
            "hideTimeframe": self.hide_timeframe,
            "hideTitle": self.hide_title,
            "hideWrench": self.hide_wrench,
            "id": self.id,
            "summaryNumberOnly": self.summary_number_only,
            "type": self.type,
            "text": self.text,
            "backgroundId": self.background_id,
        }

        if self.background is not None:
            body["background"] = self.background.get_body()
        return body

# %% ../../nbs/classes/50_DomoPage_Content.ipynb 10
@dataclass
class PageLayoutStandard:
    aspect_ratio: float
    width: int
    frame_margin: int
    frame_padding: int
    type: str
    template: list[PageLayoutTemplate]

    @classmethod
    def _from_json(cls, dd):
        obj = cls(
            aspect_ratio=dd.aspectRatio,
            width=dd.width,
            frame_margin=dd.frameMargin,
            frame_padding=dd.framePadding,
            type=dd.type,
            template=[],
        )

        if dd.template is not None:
            for template_item in dd.template:
                dc = PageLayoutTemplate._from_json(dd=template_item)
                if dc not in obj.template:
                    obj.template.append(dc)
        return obj

# %% ../../nbs/classes/50_DomoPage_Content.ipynb 12
@dataclass
class PageLayoutCompact:
    aspect_ratio: float
    width: int
    frame_margin: int
    frame_padding: int
    type: str
    template: list[PageLayoutTemplate]

    @classmethod
    def _from_json(cls, dd):
        obj = cls(
            aspect_ratio=dd.aspectRatio,
            width=dd.width,
            frame_margin=dd.frameMargin,
            frame_padding=dd.framePadding,
            type=dd.type,
            template=[],
        )
        if dd.template is not None:
            for template_item in dd.template:
                dc = PageLayoutTemplate._from_json(dd=template_item)
                if dc not in obj.template:
                    obj.template.append(dc)
        return obj

# %% ../../nbs/classes/50_DomoPage_Content.ipynb 14
@dataclass
class PageLayout:
    id: str
    page_id: int
    is_print_friendly: bool
    is_enabled: bool
    is_dynamic: bool
    has_page_breaks: bool
    content: list[PageLayoutContent]
    standard: PageLayoutStandard
    compact: PageLayoutCompact
    background: PageLayoutBackground

    @classmethod
    def _from_json(cls, dd):
        obj = cls(
            id=dd.layoutId,
            page_id=dd.pageUrn,
            is_print_friendly=dd.printFriendly,
            is_enabled=dd.enabled,
            is_dynamic=dd.isDynamic,
            content=[],
            has_page_breaks=dd.hasPageBreaks,
            standard=PageLayoutStandard._from_json(dd=dd.standard),
            compact=PageLayoutCompact._from_json(dd=dd.compact),
            background=PageLayoutBackground._from_json(dd=dd.background),
        )
        if dd.content is not None:
            for content_item in dd.content:
                dc = PageLayoutContent._from_json(dd=content_item)
                if dc not in obj.content:
                    obj.content.append(dc)
        return obj

    @classmethod
    def generate_new_background_body(cls):
        background_body = {
            "selectedColor": "#EEE000",
            "textColor": "#4A4A4A",
            "type": "COLOR",
            "darkMode": False,
            "alpha": 1,
        }

        return background_body

    def get_body(self):
        body = {
            "layoutId": self.id,
            "pageUrn": self.page_id,
            "printFriendly": self.is_print_friendly,
            "enabled": self.is_enabled,
            "isDynamic": self.is_dynamic,
            "hasPageBreaks": self.has_page_breaks,
            "standard": {
                "aspectRatio": self.standard.aspect_ratio,
                "width": self.standard.width,
                "frameMargin": self.standard.frame_margin,
                "framePadding": self.standard.frame_padding,
                "type": self.standard.type,
            },
            "compact": {
                "aspectRatio": self.compact.aspect_ratio,
                "width": self.compact.width,
                "frameMargin": self.compact.frame_margin,
                "framePadding": self.compact.frame_padding,
                "type": self.compact.type,
            },
        }
        if self.background is not None:
            body["background"] = self.background.get_body()

        if self.content == [] or self.content is None:
            body["content"] = []
        else:
            temp_list = []
            for content_item in self.content:
                temp_list.append(content_item.get_body())
            body["content"] = temp_list

        if self.standard.template is None or self.standard.template == []:
            body["standard"]["template"] = []
        else:
            temp_list = []
            for template_item in self.standard.template:
                temp_list.append(template_item.get_body())
            body["standard"]["template"] = temp_list

        if self.compact.template is None or self.compact.template == []:
            body["compact"]["template"] = []
        else:
            temp_list = []
            for template_item in self.compact.template:
                temp_list.append(template_item.get_body())
            body["compact"]["template"] = temp_list
        return body

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoPDP.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoPDP.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoPDP.ipynb.

# %% auto 0
__all__ = ['PDP_Parameter', 'PDP_Policy', 'Dataset_PDP_Policies', 'SearchPDP_NotFound']

# %% ../../nbs/classes/50_DomoPDP.ipynb 2
import httpx

from nbdev.showdoc import patch_to

from dataclasses import dataclass

import domolibrary.utils.DictDot as util_dd
import domolibrary.utils.chunk_execution as ce

import domolibrary.routes.pdp as pdp_routes

import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

# %% ../../nbs/classes/50_DomoPDP.ipynb 6
@dataclass
class PDP_Parameter:
    column_name: str
    column_values_ls: list
    operator: str = (
        "EQUALS"
        or "GREATER_THAN"
        or "LESS_THAN"
        or "GREATER_THAN_EQUAL"
        or "LESS_THAN_EQUAL"
        or "BETWEEN"
    )
    ignore_case: bool = True
    type: str = (
        "COLUMN" or "DYNAMIC"
    )  # column sets parameter on data vs dynamic creates on Domo Trusted Attribute

# %% ../../nbs/classes/50_DomoPDP.ipynb 7
@patch_to(PDP_Parameter)
def generate_parameter_simple(obj):

    return pdp_routes.generate_policy_parameter_simple(
        column_name=obj.name,
        type=obj.type,
        column_values_ls=obj.values,
        operator=obj.operator,
        ignore_case=obj.ignoreCase,
    )


@patch_to(PDP_Parameter)
def generate_body_from_parameter(self):

    return pdp_routes.generate_policy_parameter_simple(
        column_name=self.column_name,
        type=self.type,
        column_values_ls=self.column_values_ls,
        operator=self.operator,
        ignore_case=self.ignore_case,
    )

# %% ../../nbs/classes/50_DomoPDP.ipynb 10
@dataclass
class PDP_Policy:
    dataset_id: str
    filter_group_id: str
    name: str
    # resources: list
    parameters_ls: list[dict]
    user_ls: list[str]
    group_ls: list[str]
    virtual_user_ls: list[str]

    @classmethod
    async def _from_json(cls, obj, auth: dmda.DomoAuth):
        dd = util_dd.DictDot(obj)

        import domolibrary.classes.DomoUser as dmu
        import domolibrary.classes.DomoGroup as dmg

        return cls(
            dataset_id=dd.dataSourceId,
            filter_group_id=dd.filterGroupId,
            name=dd.name,
            # resources=dd.resources,
            parameters_ls=dd.parameters,
            user_ls=(
                await ce.gather_with_concurrency(
                    n=60,
                    *[
                        dmu.DomoUser.get_by_id(user_id=id, auth=auth)
                        for id in dd.userIds
                    ],
                )
                if dd.userIds
                else None
            ),
            group_ls=(
                await ce.gather_with_concurrency(
                    n=60,
                    *[
                        dmg.DomoGroup.get_by_id(group_id=id, auth=auth)
                        for id in dd.groupIds
                    ],
                )
                if dd.groupIds
                else None
            ),
            virtual_user_ls=dd.virtualUserIds,
        )

    @classmethod
    async def upsert_policy(
        cls,
        auth: dmda.DomoAuth,
        dataset_id: str,
        # body sent to the API (uses camelCase instead of snake_case)
        policy_definition: dict,
        debug_api: bool = False,
        debug_prn: bool = False,
    ):

        # print(policy_definition)
        policy_id = policy_definition.get("filterGroupId")
        if policy_id:
            if debug_prn:
                print(f"Updating policy {policy_id} in {auth.domo_instance}")
            res = await pdp_routes.update_policy(
                auth=auth,
                dataset_id=dataset_id,
                policy_id=policy_id,
                body=policy_definition,
                debug_api=debug_api,
            )
            return res
        else:
            if debug_prn:
                print(f"Policy does not exist. Creating policy in {auth.domo_instance}")
            res = await pdp_routes.create_policy(
                auth=auth,
                dataset_id=dataset_id,
                body=policy_definition,
                debug_api=debug_api,
            )
            return res

# %% ../../nbs/classes/50_DomoPDP.ipynb 12
@patch_to(PDP_Policy)
def generate_body_from_policy(
    self: PDP_Policy,
    # params: list[dict] = ''
):
    if not self.parameters_ls:
        raise Exception("generate_body_from_policy: no parameters")

    self.parameters_ls = [
        PDP_Parameter.generate_parameter_simple(param) for param in self.parameters_ls
    ]

    return pdp_routes.generate_policy_body(
        policy_name=self.name,
        dataset_id=self.dataset_id,
        parameters_ls=self.parameters_ls,
        policy_id=self.filter_group_id,
        user_ids=self.user_ls,
        group_ids=self.group_ls,
        virtual_user_ids=self.virtual_user_ls,
    )

# %% ../../nbs/classes/50_DomoPDP.ipynb 14
class Dataset_PDP_Policies:

    dataset = None  # domo dataset class
    policies: list[PDP_Policy] = None
    auth = None

    def __init__(self, dataset):
        self.dataset = dataset
        self.policies = []

# %% ../../nbs/classes/50_DomoPDP.ipynb 16
@patch_to(Dataset_PDP_Policies)
async def get_policies(
    self: Dataset_PDP_Policies,
    include_all_rows: bool = True,
    auth: dmda.DomoAuth = None,
    dataset_id: str = None,
    return_raw: bool = False,
    debug_api: bool = False,
):

    dataset_id = dataset_id or self.dataset.id
    auth = auth or self.dataset.auth

    res = await pdp_routes.get_pdp_policies(
        auth=auth,
        dataset_id=dataset_id,
        debug_api=debug_api,
        include_all_rows=include_all_rows,
    )

    if return_raw:
        return res

    if res.status == 200:
        domo_policy = await ce.gather_with_concurrency(
            n=60,
            *[
                PDP_Policy._from_json(policy_obj, auth=auth)
                for policy_obj in res.response
            ]
        )
        self.policies = domo_policy
        return domo_policy

# %% ../../nbs/classes/50_DomoPDP.ipynb 25
class SearchPDP_NotFound(de.DomoError):
    def __init__(
        self, domo_instance, dataset_id, message="not found", function_name="search_pdp"
    ):

        super().__init__(
            domo_instance=domo_instance,
            entity_id=dataset_id,
            message=message,
            function_name=function_name,
        )


@patch_to(Dataset_PDP_Policies, cls_method=True)
async def search_pdp_policies(
    cls: Dataset_PDP_Policies,
    auth: dmda.DomoAuth,
    search: str,
    dataset_id: str = None,
    search_method: str = "id" or "name",
    is_exact_match: bool = True,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):

    all_pdp_policies = await Dataset_PDP_Policies(cls).get_policies(
        auth=auth, dataset_id=dataset_id, debug_api=debug_api
    )

    if return_raw:
        return all_pdp_policies

    if search_method == "name":
        if is_exact_match:
            policy_search = next(
                (policy for policy in all_pdp_policies if policy.name == search), None
            )
            # print(policy_search)

            if not policy_search:
                raise SearchPDP_NotFound(
                    dataset_id=dataset_id,
                    message=f'There is no policy named "{search}" on dataset_id {dataset_id}',
                    domo_instance=auth.domo_instance,
                )

            return policy_search
        else:
            policy_search = [
                policy
                for policy in all_pdp_policies
                if search.lower() in policy.name.lower()
            ]
            if not policy_search:
                raise SearchPDP_NotFound(
                    dataset_id=dataset_id,
                    message=f'There is no policy name containing "{search}" on dataset_id {dataset_id}',
                    domo_instance=auth.domo_instance,
                )

            return policy_search
    else:
        policy_search = next(
            (policy for policy in all_pdp_policies if policy.filter_group_id == search),
            None,
        )

    if not policy_search:
        raise SearchPDP_NotFound(
            dataset_id=dataset_id,
            message=f'There is no policy id "{search}" on dataset_id {dataset_id}',
            domo_instance=auth.domo_instance,
        )

    return policy_search

# %% ../../nbs/classes/50_DomoPDP.ipynb 29
@patch_to(PDP_Policy)
async def delete_policy(
    self: PDP_Policy,
    auth: dmda.DomoAuth,
    policy_id: str = None,
    dataset_id: str = None,
    debug_api: bool = False,
):

    dataset_id = dataset_id or self.dataset_id
    policy_id = policy_id or self.filter_group_id

    res = await pdp_routes.delete_policy(
        auth=auth, dataset_id=dataset_id, policy_id=policy_id, debug_api=debug_api
    )

    return res

# %% ../../nbs/classes/50_DomoPDP.ipynb 33
@patch_to(Dataset_PDP_Policies)
async def toggle_dataset_pdp(
    self: Dataset_PDP_Policies,
    auth: dmda.DomoAuth = None,
    dataset_id: str = None,
    is_enable: bool = True,  # True will enable pdp, False will disable pdp
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    auth = auth or self.dataset.auth

    return await pdp_routes.toggle_pdp(
        auth=auth,
        dataset_id=dataset_id or self.dataset.id,
        is_enable=is_enable,
        debug_api=debug_api,
        session=session,
    )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoPublish.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoPublish.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoPublish.ipynb.

# %% auto 0
__all__ = ['DomoPublication_Subscription', 'DomoPublication_Content', 'DomoPublication_UnexpectedContentType', 'DomoPublication',
           'DomoPublications']

# %% ../../nbs/classes/50_DomoPublish.ipynb 2
from dataclasses import dataclass, field
from typing import Optional, List

import datetime as dt
import pandas as pd
import asyncio
import httpx

import uuid

from nbdev.showdoc import patch_to

import domolibrary.utils.DictDot as util_dd
import domolibrary.client.DomoAuth as dmda
import domolibrary.routes.publish as publish_routes

import domolibrary.classes.DomoLineage as dmdl

import domolibrary.utils.chunk_execution as ce

# %% ../../nbs/classes/50_DomoPublish.ipynb 5
@dataclass
class DomoPublication_Subscription:
    auth: dmda.DomoAuth
    subscription_id: str
    publication_id: str
    domain: str
    created_dt: Optional[dt.datetime] = (None,)

    publication = None

    @classmethod
    def _from_json(cls, json, auth: dmda.DomoAuth):

        dd = json
        if not isinstance(dd, util_dd.DictDot):
            dd = util_dd.DictDot(json)

        return cls(
            auth=auth,
            subscription_id=dd.id or dd.subscriptionId,
            publication_id=dd.publicationId,
            domain=dd.domain or dd.publisherDomain,
            created_dt=(
                dt.datetime.fromtimestamp(dd.created / 1000) if dd.created else None,
            ),
        )

# %% ../../nbs/classes/50_DomoPublish.ipynb 7
@patch_to(DomoPublication_Subscription)
async def get_content_details(
    self, debug_api: bool = False, debug_num_stacks_to_drop=2
):

    res = await publish_routes.get_subscriber_content_details(
        auth=self.auth,
        publication_id=self.publication_id,
        subscriber_instance=self.domain,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        debug_api=debug_api,
        parent_class=self.__class__.__name__,
    )

    return res

# %% ../../nbs/classes/50_DomoPublish.ipynb 9
@dataclass
class DomoPublication_Content:
    content_id: str
    entity_type: str
    entity_id: str
    entity_domain: str
    is_v2: bool
    is_direct_content: bool
    subscriber_content_id: str = None
    subscriber_insance: str = None

    @classmethod
    def _from_json(cls, obj: dict):

        dd = obj
        if not isinstance(dd, util_dd.DictDot):
            dd = util_dd.DictDot(obj)

        dmpc = cls(
            content_id=dd.id,
            entity_type=dd.content.type,
            entity_id=dd.content.domoObjectId,
            entity_domain=dd.content.domain,
            is_v2=dd.isV2,
            is_direct_content=dd.useDirectContent,
        )

        return dmpc

    def to_api_json(self):
        temp_dict = {
            "domain": self.entity_domain,
            "domoObjectId": self.entity_id,
            "customerId": self.entity_domain,
            "type": self.entity_type,
        }
        return temp_dict

# %% ../../nbs/classes/50_DomoPublish.ipynb 11
class DomoPublication_UnexpectedContentType(Exception):
    def __init__(self, publication_id, content_type, domo_instance):
        super().__init__(
            f"DomoPublication_Instantiation: Unexpected content type {content_type} in publication {publication_id} in {domo_instance}"
        )

# %% ../../nbs/classes/50_DomoPublish.ipynb 12
@dataclass
class DomoPublication:
    id: str
    name: str
    description: str
    is_v2: bool
    created_dt: dt.datetime

    auth: dmda.DomoAuth = field(default=None, repr=False)

    subscription_authorizations: List[DomoPublication_Subscription] = field(
        default_factory=list
    )
    content: List[DomoPublication_Content] = field(default_factory=list)

    content_page_id_ls: List[str] = field(default_factory=list)
    content_dataset_id_ls: List[str] = field(default_factory=list)

    lineage: dmdl.DomoLineage = None

    def __post_init__(self):
        self.lineage = dmdl.DomoLineage(parent=self)

    @classmethod
    def _from_json(cls, obj, auth: dmda.DomoAuth = None):

        dd = util_dd.DictDot(obj)

        domo_pub = cls(
            id=dd.id,
            name=dd.name,
            description=dd.description,
            created_dt=(
                dt.datetime.fromtimestamp(dd.created / 1000) if dd.created else None
            ),
            is_v2=dd.isV2,
            auth=auth,
        )

        if dd.subscriptionAuthorizations and len(dd.subscriptionAuthorizations) > 0:
            domo_pub.subscription_authorizations = [
                DomoPublication_Subscription._from_json(sub, auth=auth)
                for sub in dd.subscriptionAuthorizations
            ]

        # publish only supports sharing pages and datasets
        if dd.children and len(dd.children) > 0:
            for child in dd.children:

                dmpc = DomoPublication_Content._from_json(child)
                domo_pub.content.append(dmpc)

                if dmpc.entity_type == "PAGE":
                    domo_pub.content_page_id_ls.append(dmpc.entity_id)

                elif dmpc.entity_type == "DATASET":
                    domo_pub.content_dataset_id_ls.append(dmpc.entity_id)

                else:
                    raise DomoPublication_UnexpectedContentType(
                        publication_id=domo_pub.id,
                        content_type=dmpc.entity_type,
                        domo_instance=auth.domo_instance,
                    )

        return domo_pub

# %% ../../nbs/classes/50_DomoPublish.ipynb 13
@patch_to(DomoPublication, cls_method=True)
async def get_from_id(
    cls,
    publication_id=None,
    auth: dmda.DomoAuth = None,
    timeout=10,
    debug_api: bool = False,
):

    auth = auth or cls.auth

    publication_id = publication_id or cls.publication_id

    res = await publish_routes.get_publication_by_id(
        auth=auth, publication_id=publication_id, timeout=timeout, debug_api=debug_api
    )

    if not res.is_success:
        return None

    return cls._from_json(obj=res.response, auth=auth)

# %% ../../nbs/classes/50_DomoPublish.ipynb 17
@patch_to(DomoPublication_Subscription)
async def get_publication(self, debug_api: bool = False, debug_num_stacks_to_drop=2):
    self.publication = await DomoPublication.get_from_id(
        publication_id=self.publication_id,
        auth=self.auth,
        debug_api=debug_api,
        # parent_class=self.__class__.__name__,
        # debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )
    return self.publication


@patch_to(DomoPublication_Subscription)
async def get_content_details(
    self, debug_api: bool = False, debug_num_stacks_to_drop=2
):
    publication = self.publication
    if not publication:
        publication = await self.get_publication()

    publication_content = publication.content

    res = await publish_routes.get_subscriber_content_details(
        auth=self.auth,
        publication_id=self.publication_id,
        subscriber_instance=self.domain,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        debug_api=debug_api,
        # parent_class=self.__class__.__name__,
    )

    for content in publication_content:
        subscriber_obj = next(
            (
                subscriber_obj
                for subscriber_obj in res.response
                if subscriber_obj["publisherObjectId"] == content.entity_id
                and subscriber_obj["contentType"] == content.entity_type
            ),
            None,
        )

        content.subscriber_content_id = subscriber_obj["subscriberObjectId"]
        content.subscriber_insance = subscriber_obj["subscriberDomain"]

    self.content = publication_content

    return self.content

# %% ../../nbs/classes/50_DomoPublish.ipynb 20
@dataclass
class DomoPublications:
    @classmethod
    async def get_subscription_summaries(
        cls,
        auth: dmda.DomoAuth,
        session: httpx.AsyncClient = None,
        return_raw: bool = False,
        debug_api: bool = False,
    ):
        """get instances subscription summaries"""

        res = await publish_routes.get_subscription_summaries(
            auth=auth, session=session, debug_api=debug_api
        )

        if return_raw:
            return res

        if not res.is_success:
            return res

        sub_ls = res.response

        return [
            DomoPublication_Subscription._from_json(sub, auth=auth) for sub in sub_ls
        ]

# %% ../../nbs/classes/50_DomoPublish.ipynb 23
@patch_to(DomoPublications, cls_method=True)
async def search_publications(
    cls: DomoPublications,
    auth=dmda.DomoAuth,
    search_term: str = None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    return_raw: bool = False,
):
    res = await publish_routes.search_publications(
        auth=auth,
        search_term=search_term,
        session=session,
        debug_api=debug_api,
    )

    if return_raw:
        return res

    if not res.is_success or (res.is_success and len(res.response) == 0):
        return None

    return await ce.gather_with_concurrency(
        n=60,
        *[
            DomoPublication.get_from_id(publication_id=sub_obj["id"], auth=auth)
            for sub_obj in res.response
        ]
    )

# %% ../../nbs/classes/50_DomoPublish.ipynb 25
@patch_to(DomoPublication, cls_method=False)
def convert_content_to_dataframe(self, return_raw: bool = False):

    output_ls = [
        {
            "plubication_id": self.id,
            "publication_name": self.name,
            "is_v2": self.is_v2,
            "publish_created_dt": self.created_dt,
            "entity_type": row.type,
            "entity_id": row.id,
        }
        for row in self.content_entity_ls
    ]

    if return_raw:
        return output_ls

    return pd.DataFrame(output_ls)


@patch_to(DomoPublication, cls_method=False)
def convert_lineage_to_dataframe(self, return_raw: bool = False):

    flat_lineage_ls = self.lineage._flatten_lineage()

    output_ls = [
        {
            "plubication_id": self.id,
            "publication_name": self.name,
            "is_v2": self.is_v2,
            "publish_created_dt": self.created_dt,
            "entity_type": row.get("entity_type"),
            "entity_id": row.get("entity_id"),
        }
        for row in flat_lineage_ls
    ]

    if return_raw:
        return output_ls

    return pd.DataFrame(output_ls)

# %% ../../nbs/classes/50_DomoPublish.ipynb 26
@patch_to(DomoPublication, cls_method=True)
async def create_publication(
    cls,
    name: str,
    content_ls: List[DomoPublication_Content],
    subscription_ls: List[DomoPublication_Subscription],
    unique_id: str = None,
    description: str = None,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
):

    if not isinstance(subscription_ls, list):
        subscription_ls = [subscription_ls]

    auth = auth or cls.auth
    domain_ls = []
    content_json_ls = []
    for sub in subscription_ls:
        domain_ls.append(sub.domain)
    for content_item in content_ls:
        content_json_ls.append(content_item.to_api_json())

    if not unique_id:
        unique_id = str(uuid.uuid4())
    if not description:
        description = ""

    body = publish_routes.generate_publish_body(
        url=f"{auth.domo_instance}.domo.com",
        sub_domain_ls=domain_ls,
        content_ls=content_json_ls,
        name=name,
        unique_id=unique_id,
        description=description,
        is_new=True,
    )

    res = await publish_routes.create_publish_job(auth=auth, body=body)
    if debug_api:
        print("Create the new Publish job")
    if res.status != 200:
        print(res)
        await asyncio.sleep(2)
        res = await publish_routes.get_publication_by_id(
            auth=auth, publication_id=unique_id
        )
        if res.status != 200:
            return None
        else:
            return cls._from_json(obj=res.response, auth=auth)

    return cls._from_json(obj=res.response, auth=auth)

# %% ../../nbs/classes/50_DomoPublish.ipynb 28
@patch_to(DomoPublication, cls_method=True)
async def update_publication(
    cls,
    name: str,
    content_ls: List[DomoPublication_Content],
    subscription_ls: List[DomoPublication_Subscription],
    publication_id: str,
    description: str = None,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
):

    if not isinstance(subscription_ls, list):
        subscription_ls = [subscription_ls]

    auth = auth or cls.auth
    domain_ls = []
    content_json_ls = []
    for sub in subscription_ls:
        domain_ls.append(sub.domain)
    for content_item in content_ls:
        content_json_ls.append(content_item.to_api_json())

    if not description:
        description = ""
    body = publish_routes.generate_publish_body(
        url=f"{auth.domo_instance}.domo.com",
        sub_domain_ls=domain_ls,
        content_ls=content_json_ls,
        name=name,
        unique_id=publication_id,
        description=description,
        is_new=False,
    )

    res = await publish_routes.udpate_publish_job(
        auth=auth, publication_id=publication_id, body=body
    )
    if debug_api:
        print("Update Publish job by id")
    if res.status != 200:
        print(res)
        await asyncio.sleep(2)
        res = await publish_routes.get_publication_by_id(
            auth=auth, publication_id=publication_id
        )
        if res.status != 200:
            return None
        else:
            return cls._from_json(obj=res.response, auth=auth)

    return cls._from_json(obj=res.response, auth=auth)

# %% ../../nbs/classes/50_DomoPublish.ipynb 30
@patch_to(DomoPublication, cls_method=True)
async def get_subscription_invites_list(
    cls, auth: dmda.DomoAuth, debug_api: bool = False
):

    res = await publish_routes.get_subscription_invititations(
        auth=auth, debug_api=debug_api
    )
    if debug_api:
        print("Getting Publish subscription invites")

    if res.status == 200:
        return res.response
    else:
        return None


# | export
@patch_to(DomoPublication, cls_method=True)
async def accept_invite_by_id(
    cls, auth: dmda.DomoAuth, subscription_id: str, debug_api: bool = False
):

    res = await publish_routes.accept_invite_by_id(
        auth=auth, subscription_id=subscription_id, debug_api=debug_api
    )

    if res.status == 200:
        return res.response
    else:
        return None

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoRole.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoRole.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoRole.ipynb.

# %% auto 0
__all__ = ['DomoRole', 'SetRoleGrants_MissingGrants', 'AddUser_Error', 'DeleteRole_Error', 'DomoRoles', 'SearchRole_NotFound',
           'CreateRole_Error']

# %% ../../nbs/classes/50_DomoRole.ipynb 2
from dataclasses import dataclass, field
from typing import List
import httpx
import asyncio

from nbdev.showdoc import patch_to

import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

import domolibrary.utils.DictDot as util_dd
import domolibrary.routes.role as role_routes

import domolibrary.classes.DomoUser as dmu
import domolibrary.classes.DomoGrant as dmg

# %% ../../nbs/classes/50_DomoRole.ipynb 4
@dataclass
class DomoRole:
    auth: dmda.DomoAuth = field(repr=False)

    id: str
    name: str = None
    description: str = None
    is_system_role: bool = False
    is_default_role: bool = False

    grant_ls: List[dmg.DomoGrant] = field(default_factory=list)
    membership_ls: list = field(default_factory=list)

    def __post_init__(self):
        self.is_system_role = True if self.id <= 5 else 0

        if self.grant_ls:
            self.grant_ls = self._valid_grant_ls(self.grant_ls)

    @staticmethod
    def _valid_grant_ls(grant_ls) -> List[dmg.DomoGrant]:
        if isinstance(grant_ls[0], str):
            return [dmg.DomoGrant(grant_str) for grant_str in grant_ls]

        elif isinstance(grant_ls[0], dmg.DomoGrant):
            return grant_ls

    # @classmethod
    # def _from_str(cls, id, name, description=None, auth: DomoAuth = None):

    #     return cls(id=id,
    #             name=name,
    #             description=description,
    #             auth=auth
    #             )

    @classmethod
    def _from_json(cls, obj, auth=dmda.DomoAuth, is_default_role=None):
        dd = obj
        if not isinstance(dd, util_dd.DictDot):
            dd = util_dd.DictDot(obj)

        return cls(
            id=dd.id,
            name=dd.name,
            description=dd.description,
            auth=auth,
            is_default_role=is_default_role,
        )

# %% ../../nbs/classes/50_DomoRole.ipynb 5
@patch_to(DomoRole, cls_method=True)
async def get_by_id(
    cls: DomoRole,
    role_id: int,
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    return_raw: bool = False,
):
    res = await role_routes.get_role_by_id(
        role_id=role_id,
        auth=auth,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
        parent_class=cls.__name__,
    )

    if return_raw:
        return res.response

    return cls._from_json(res.response, auth=auth)

# %% ../../nbs/classes/50_DomoRole.ipynb 9
@patch_to(DomoRole)
async def get_grants(
    self: DomoRole,
    auth: dmda.DomoAuth = None,
    role_id: str = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    auth = auth or self.auth
    role_id = role_id or self.id
    res = await role_routes.get_role_grants(
        auth=auth,
        role_id=role_id,
        debug_api=debug_api,
        session=session,
        parent_class=self.__class__.__name__,
    )

    if return_raw:
        return res

    self.grant_ls = [dmg.DomoGrant(obj) for obj in res.response]

    return self.grant_ls

# %% ../../nbs/classes/50_DomoRole.ipynb 12
class SetRoleGrants_MissingGrants(de.DomoError):
    def __init__(self, role_id, missing_grants: List[str], domo_instance):
        super().__init__(
            domo_instance=domo_instance,
            entity_id=role_id,
            message=f"failed to add grants: {', '.join(missing_grants)}",
        )

# %% ../../nbs/classes/50_DomoRole.ipynb 13
@patch_to(DomoRole)
async def set_grants(
    self: DomoRole,
    grant_ls: List[dmg.DomoGrant],
    role_id: str = None,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: bool = 2,
    session: httpx.AsyncClient = None,
):
    auth = auth or self.auth
    role_id = role_id or self.id

    domo_grants = self._valid_grant_ls(grant_ls)

    # dmic = dic.DomoInstanceConfig(auth = auth)
    # all_grants = await dmic.get_grants()

    # filtered_grant_ls = []

    # for domo_grant in all_grants:
    #     if domo_grant.id in grant_ls:
    #         filtered_grant_ls.append(domo_grant.id)

    #         if domo_grant.depends_on_ls:
    #             for parent_grant_id in domo_grant.depends_on_ls:
    #                 match_grant = next(( domo_grant for domo_grant in all_grants if parent_grant_id == domo_grant.id ))
    #                 if match_grant:
    #                     filtered_grant_ls.append(match_grant.id)

    # set grants
    res = await role_routes.set_role_grants(
        auth=auth,
        role_id=role_id,
        role_grant_ls=[domo_grant.id for domo_grant in domo_grants],
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
        parent_class=self.__class__.__name__,
    )

    # validate grants
    await asyncio.sleep(2)

    all_grants = await self.get_grants(auth=auth, debug_api=debug_api, session=session)

    missing_grants = [grant.id for grant in domo_grants if grant not in all_grants]

    if missing_grants:
        raise SetRoleGrants_MissingGrants(
            role_id=role_id,
            missing_grants=missing_grants,
            domo_instance=auth.domo_instance,
        )

    return domo_grants

# %% ../../nbs/classes/50_DomoRole.ipynb 17
@patch_to(DomoRole)
async def get_membership(
    self,
    role_id=None,
    auth: dmda.DomoAuth = None,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    auth = auth or self.auth
    role_id = role_id or self.id

    res = await role_routes.get_role_membership(
        auth=auth, role_id=role_id, debug_api=debug_api, session=session
    )

    if return_raw:
        return res.response

    membership_ls = [
        dmu.DomoUser._from_search_json(user_obj=obj, auth=auth) for obj in res.response
    ]

    self.membership_ls = membership_ls

    return membership_ls

# %% ../../nbs/classes/50_DomoRole.ipynb 20
class AddUser_Error(de.DomoError):
    def __init__(self, role_id, domo_instance, user_id, user_name=None):
        user_str = f"{user_id} - {user_name}" if user_name else user_id
        super().__init__(
            domo_instance=domo_instance,
            message=f"unable to add {user_str} to role {role_id}",
        )

# %% ../../nbs/classes/50_DomoRole.ipynb 21
@patch_to(DomoRole)
async def add_user(
    self,
    user: dmu.DomoUser,
    role_id: str = None,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    role_id = role_id or self.id
    auth = auth or self.auth

    await role_routes.role_membership_add_users(
        auth=auth,
        role_id=role_id,
        user_list=[user.id],
        debug_api=debug_api,
        session=session,
    )

    domo_members = await self.get_membership(
        auth=auth or self.auth, role_id=role_id or self.id, debug_api=debug_api
    )
    self.membership_ls = domo_members

    if user not in domo_members:
        raise AddUser_Error(
            role_id=role_id,
            domo_instance=auth.domo_instance,
            user_id=user.id,
            user_name=user.display_name,
        )

    return domo_members

# %% ../../nbs/classes/50_DomoRole.ipynb 25
@patch_to(DomoRole)
async def update_role_metadata(
    self: DomoRole,
    auth: dmda.DomoAuth = None,
    role_name=None,
    role_description: str = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    auth = auth or self.auth
    role_name = role_name or self.name

    res = await role_routes.update_role_metadata(
        role_id=self.id,
        role_name=role_name,
        role_description=role_description or self.description,
        auth=auth,
        debug_api=debug_api,
        session=session,
    )

    if return_raw:
        return res

    role_ls = await role_routes.get_roles(auth=auth)

    domo_role = next(
        (
            DomoRole._from_json(role, auth=auth)
            for role in role_ls.response
            if role.get("name") == role_name
        ),
        None,
    )

    return domo_role

# %% ../../nbs/classes/50_DomoRole.ipynb 29
class DeleteRole_Error(de.DomoError):
    def __init__(self, role_id, domo_instance):
        super().__init__(
            message=f"role: {role_id} not found", domo_instance=domo_instance
        )

# %% ../../nbs/classes/50_DomoRole.ipynb 30
@patch_to(DomoRole, cls_method=True)
async def delete_role(
    cls: DomoRole,
    role_id: int,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    domo_res = await role_routes.get_roles(auth=auth)

    domo_role = next(
        (role for role in domo_res.response if role.get("id") == role_id), None
    )

    if not domo_role:
        raise DeleteRole_Error(role_id=role_id, domo_instance=auth.domo_instance)

    return await role_routes.delete_role(
        role_id=role_id, auth=auth, debug_api=debug_api, session=session
    )

# %% ../../nbs/classes/50_DomoRole.ipynb 34
@dataclass
class DomoRoles:
    auth: dmda.DomoAuth

# %% ../../nbs/classes/50_DomoRole.ipynb 35
@patch_to(DomoRoles, cls_method=True)
async def get_roles(
    cls: DomoRoles,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    res = await role_routes.get_roles(auth=auth, session=session, debug_api=debug_api)

    if return_raw:
        return res

    default_role_res = await role_routes.get_default_role(
        auth=auth, session=session, debug_api=debug_api
    )

    return [
        DomoRole._from_json(
            role,
            auth,
            is_default_role=str(default_role_res.response) == str(role.get("id")),
        )
        for role in res.response
    ]

# %% ../../nbs/classes/50_DomoRole.ipynb 38
class SearchRole_NotFound(de.DomoError):
    def __init__(
        self, domo_instance, role_id, message="not found", function_name="search_role"
    ):
        super().__init__(
            domo_instance=domo_instance,
            message=message,
            entity_id=role_id,
            function_name=function_name,
        )

# %% ../../nbs/classes/50_DomoRole.ipynb 39
@patch_to(DomoRoles, cls_method=True)
async def search_role(
    cls: DomoRoles,
    auth: dmda.DomoAuth,
    role_name: str = None,
    role_id: str = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    all_roles = await DomoRoles.get_roles(
        auth=auth, debug_api=debug_api, session=session, return_raw=return_raw
    )

    if return_raw:
        return all_roles

    if role_name:
        domo_role = next((role for role in all_roles if role.name == role_name), None)

    if role_id:
        domo_role = next(
            (role for role in all_roles if str(role.id) == str(role_id)), None
        )

    if not domo_role:
        raise SearchRole_NotFound(domo_instance=auth.domo_instance, role_id=role_name)

    return domo_role

# %% ../../nbs/classes/50_DomoRole.ipynb 43
class CreateRole_Error(de.DomoError):
    def __init__(
        self, domo_instance, role_id, message, status, function_name="create_role"
    ):
        super().__init__(
            domo_instance=domo_instance,
            message=message,
            status=status,
            entity_id=role_id,
            function_name=function_name,
        )

# %% ../../nbs/classes/50_DomoRole.ipynb 44
@patch_to(DomoRoles, cls_method=True)
async def create_role(
    cls: DomoRoles,
    auth: dmda.DomoAuth,
    name: str,
    description: str = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    res = await role_routes.create_role(
        auth=auth,
        name=name,
        description=description,
        debug_api=debug_api,
        session=session,
    )

    if not res.is_success:
        role_res = await cls.get_roles(auth=auth)

        domo_role = next((role for role in role_res if role.name == name))

        if domo_role:
            raise CreateRole_Error(
                domo_instance=auth.domo_instance,
                role_id=name,
                message="role already exists",
                status=res.status,
            )

        raise CreateRole_Error(
            domo_instance=auth.domo_instance,
            role_id=name,
            message=res.response,
            status=res.status,
        )

    return await DomoRoles.search_role(auth=auth, role_name=name)

# %% ../../nbs/classes/50_DomoRole.ipynb 47
@patch_to(DomoRoles, cls_method=True)
async def upsert_role(
    cls: DomoRoles,
    auth: dmda.DomoAuth,
    name: str,
    description: str = None,
    grant_ls: List[dmg.DomoGrant] = None,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    domo_role = None

    try:
        domo_role = await DomoRoles.search_role(
            role_name=name,
            auth=auth,
            debug_api=debug_api,
            session=session,
        )

        if domo_role:
            await domo_role.update_role_metadata(
                role_name=name, role_description=description, session=session
            )

    except SearchRole_NotFound as e:
        if debug_prn:
            print(f"No role match -- creating new role in {auth.domo_instance} - {e}")

        domo_role = await DomoRoles.create_role(
            auth=auth,
            name=name,
            description=description,
            debug_api=debug_api,
            session=session,
        )

    if grant_ls:
        grant_ls = domo_role._valid_grant_ls(grant_ls)
        await domo_role.set_grants(grant_ls=grant_ls)

    return domo_role

# %% ../../nbs/classes/50_DomoRole.ipynb 50
@patch_to(DomoRoles, cls_method=True)
async def get_default_role(
    cls,
    auth: dmda.DomoAuth,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: httpx.AsyncClient = None,
):
    res = await role_routes.get_default_role(
        auth=auth,
        session=session,
        parent_class=cls.__name__,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        debug_api=debug_api,
    )
    if return_raw:
        return res

    return await DomoRole.get_by_id(
        role_id=res.response,
        auth=auth,
        debug_api=debug_api,
        # parent_class = cls.__name__,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

# %% ../../nbs/classes/50_DomoRole.ipynb 52
@patch_to(DomoRole)
async def set_as_default_role(
    self: DomoRole, debug_api: bool = False, session: httpx.AsyncClient = None
):
    return await role_routes.set_default_role(
        auth=self.auth, role_id=self.id, debug_api=debug_api, session=session
    )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoSandbox.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoSandbox.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoSandbox.ipynb.

# %% auto 0
__all__ = ['InvalidRepositoryError', 'DomoRepository', 'DomoSandbox']

# %% ../../nbs/classes/50_DomoSandbox.ipynb 2
from dataclasses import dataclass

import datetime as dt
import pandas as pd

import dateutil.parser as dtut

import domolibrary.utils.DictDot as util_dd
import domolibrary.client.DomoAuth as dmda
import domolibrary.routes.sandbox as sandbox_routes

import domolibrary.classes.DomoLineage as dmdl

# %% ../../nbs/classes/50_DomoSandbox.ipynb 3
class InvalidRepositoryError(Exception):
    pass


@dataclass
class DomoRepository:
    id: str
    name: str
    last_updated_dt: dt.datetime
    commit_dt: dt.datetime
    commit_version: str
    auth: dmda.DomoAuth = None
    content_page_id_ls: list[str] = None
    content_card_id_ls: list[str] = None
    content_dataflow_id_ls: list[str] = None
    content_view_id_ls: list[str] = None

    def __post_init__(self):
        self.lineage = dmdl.DomoLineage(parent=self)

    @classmethod
    def _from_json(cls, obj, auth=None):

        dd = util_dd.DictDot(obj)

        return cls(
            id=dd.id,
            auth=auth,
            name=dd.name,
            content_page_id_ls=dd.repositoryContent.pageIds,
            content_card_id_ls=dd.repositoryContent.cardIds,
            content_dataflow_id_ls=dd.repositoryContent.dataflowIds,
            content_view_id_ls=dd.repositoryContent.viewIds,
            last_updated_dt=dtut.parse(dd.updated).replace(tzinfo=None),
            commit_dt=dtut.parse(dd.lastCommit.completed).replace(tzinfo=None),
            commit_version=dd.lastCommit.commitName,
        )

    @classmethod
    async def get_from_id(cls, repository_id: str, auth: dmda.DomoFullAuth):
        res = await sandbox_routes.get_repo_from_id(
            repository_id=repository_id, auth=auth
        )

        if res.status == 404:
            raise InvalidRepositoryError

        return cls._from_json(res.response, auth=auth)

    def convert_lineage_to_dataframe(self, return_raw: bool = False):

        flat_lineage_ls = self.lineage._flatten_lineage()

        output_ls = [
            {
                "sandbox_id": self.id,
                "sandbox_name": self.name,
                "version": self.commit_version,
                "commit_dt": self.commit_dt,
                "last_updated_dt": self.last_updated_dt,
                "entity_type": row.get("entity_type"),
                "entity_id": row.get("entity_id"),
            }
            for row in flat_lineage_ls
        ]

        if return_raw:
            return output_ls

        return pd.DataFrame(output_ls)


@dataclass
class DomoSandbox:
    @classmethod
    async def get_repositories(cls, auth):
        res = await sandbox_routes.get_shared_repos(auth)

        if res.status != 200:
            return None

        domo_repos = [
            DomoRepository._from_json(obj, auth=auth)
            for obj in res.response.get("repositories")
        ]

        return domo_repos

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoStream.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoStream.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoStream.ipynb.

# %% auto 0
__all__ = ['custom_query', 'StreamConfig', 'DomoStream']

# %% ../../nbs/classes/50_DomoStream.ipynb 3
from dataclasses import dataclass, field
from typing import List, Optional
from abc import ABC, abstractmethod
import dateutil.parser as dtut
from typing import Union

import datetime as dt
import re


import httpx

from nbdev.showdoc import patch_to

import domolibrary.utils.convert as cd
import domolibrary.utils.DictDot as util_dd
import domolibrary.client.DomoAuth as dmda
import domolibrary.classes.DomoDataset as dmds
import domolibrary.classes.DomoDatacenter as dmdc
import domolibrary.client.DomoError as de
import domolibrary.routes.stream as stream_routes

# %% ../../nbs/classes/50_DomoStream.ipynb 6
custom_query = ["enteredCustomQuery", "query", "customQuery"]


@dataclass
class StreamConfig:
    name: str
    type: str
    value: str
    value_clean: str = None


@dataclass
class DomoStream:
    id: str
    dataset_id: str
    transport_description: str
    transport_version: int
    update_method: str
    data_provider_name: str
    data_provider_key: str
    account_id: str = None
    account_display_name: str = None
    account_userid: str = None

    configuration: list[StreamConfig] = field(default_factory=list)
    configuration_tables: list[str] = field(default_factory=list)
    configuration_query: str = None

    @classmethod
    async def get_stream_by_id(
        cls,
        auth: dmda.DomoAuth,
        stream_id: str,
        session: Optional[httpx.AsyncClient] = None,
    ):

        if stream_id is None:
            return None

        res = await stream_routes.get_stream_by_id(
            auth=auth, stream_id=stream_id, session=session
        )

        if res.status != 200:
            error_str = f"get_stream_by_id: error retrieving stream {stream_id} from {auth.domo_instance}"
            print(error_str)

            return None

        dd = util_dd.DictDot(res.response)

        sd = cls(
            id=dd.id,
            transport_description=dd.transport.description,
            transport_version=dd.transport.version,
            update_method=dd.updateMethod,
            data_provider_name=dd.dataProvider.name,
            data_provider_key=dd.dataProvider.key,
            dataset_id=dd.dataSource.id,
        )
        if dd.account:
            sd.account_id = dd.account.id
            sd.account_display_name = dd.account.displayName
            sd.account_userid = dd.account.userId

        sd.configuration = []

        for config in dd.configuration:
            sc = StreamConfig(name=config.name, type=config.type, value=config.value)

            if sc.name in custom_query:
                sc.value_clean = sc.value.replace("\n", " ")
                sc.value_clean = re.sub(" +", " ", sc.value_clean)
                sd.configuration_query = sc.value_clean

                try:
                    for table in dtut.parse(sc.value).tables:
                        sd.configuration_tables.append(table)
                    sd.configuration_tables = sorted(list(set(sd.configuration_tables)))

                except Exception as e:
                    print("ALERT: unable to parse table")
                    sd.configuration_tables = ["unable to auto-parse query"]

            sd.configuration.append(sc)
        return sd

    @classmethod
    async def create_stream(
        cls,
        cnfg_body,
        auth: dmda.DomoAuth = None,
        session: Optional[httpx.AsyncClient] = None,
        debug_api: bool = False,
    ):
        return await stream_routes.create_stream(
            auth=auth, body=cnfg_body, session=session, debug_api=debug_api
        )

    @classmethod
    async def update_stream(
        cls,
        cnfg_body,
        stream_id,
        auth: dmda.DomoAuth = None,
        session: Optional[httpx.AsyncClient] = None,
        debug_api: bool = False,
    ):

        return await stream_routes.update_stream(
            auth=auth,
            stream_id=stream_id,
            body=cnfg_body,
            session=session,
            debug_api=debug_api,
        )

    @classmethod
    async def upsert_connector(
        cls,
        cnfg_body,
        match_name=None,
        auth: dmda.DomoAuth = None,
        session: Optional[httpx.AsyncClient] = None,
        debug_api: bool = False,
    ):
        search_body = dmdc.DomoDatacenter.generate_search_datacenter_body_by_name(
            entity_name=match_name
        )

        search_res = await dmdc.DomoDatacenter.search_datacenter(
            auth=auth, body=search_body, session=session, debug_api=debug_api
        )

        existing_ds_obj = next(
            (ds for ds in search_res if ds.get("name").lower() == match_name.lower()),
            None,
        )

        # if debug_api:
        #     print(
        #         f"existing_ds - {existing_ds.id if existing_ds else ' not found '}")

        if existing_ds_obj:
            existing_ds = await dmds.DomoDataset.get_from_id(
                dataset_id=existing_ds.get("databaseId"), auth=auth
            )
            return await cls.update_stream(
                cnfg_body,
                stream_id=existing_ds.stream_id,
                auth=auth,
                session=session,
                debug_api=False,
            )
        else:
            return await cls.create_stream(
                cnfg_body, auth=auth, session=session, debug_api=debug_api
            )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\classes\DomoUser.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\classes\DomoUser.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoUser.ipynb.

# %% auto 0
__all__ = ['CreateUser_MissingRole', 'DeleteUser_Error', 'DownloadAvatar_NoAvatarKey', 'DomoUser', 'DomoUsers']

# %% ../../nbs/classes/50_DomoUser.ipynb 2
from domolibrary.routes.user import (
    UserProperty,
    UserProperty_Type,
    GetUser_Error,
    SearchUser_NoResults,
    User_CrudError,
    ResetPassword_PasswordUsed,
    DownloadAvatar_Error,
)

from ..utils.Image import Image, are_same_image, domo_default_img

# %% ../../nbs/classes/50_DomoUser.ipynb 3
import datetime as dt
from dataclasses import dataclass, field
from typing import Optional, List
import httpx

from nbdev.showdoc import patch_to
import asyncio
from pprint import pprint

import domolibrary.utils.DictDot as util_dd
from domolibrary.utils.convert import test_valid_email

import domolibrary.client.DomoAuth as dmda
import domolibrary.client.Logger as lc
import domolibrary.client.DomoError as de
import domolibrary.routes.user as user_routes

# %% ../../nbs/classes/50_DomoUser.ipynb 7
class CreateUser_MissingRole(de.DomoError):
    def __init__(self, domo_instance, email_address):
        super().__init__(
            domo_instance=domo_instance,
            message=f"error creating user {email_address} missing role_id",
        )


class DeleteUser_Error(de.DomoError):
    def __init__(self, domo_instance, email_address):
        super().__init__(
            domo_instance=domo_instance,
            message=f"error deleting user {email_address}.",
        )


class DownloadAvatar_NoAvatarKey(de.DomoError):
    def __init__(
        self,
        domo_instance,
        user_id,
    ):
        super().__init__(
            domo_instance,
            message=f"This profile {user_id} doesn't have an avatar uploaded - unable to download",
        )

# %% ../../nbs/classes/50_DomoUser.ipynb 9
@dataclass
class DomoUser:
    """a class for interacting with a Domo User"""

    id: str
    display_name: str = None
    email_address: str = None
    role_id: str = None
    department: str = None
    title: str = None
    avatar_key: str = None

    phone_number: str = None
    web_landing_page: str = None
    web_mobile_landing_page: str = None
    employee_id: str = None
    employee_number: str = None
    hire_date: str = None
    reports_to: str = None

    publisher_domain: str = None
    subscriber_domain: str = None
    virtual_user_id: str = None

    custom_attributes: dict = field(default_factory=dict)

    role: dict = None  # DomoRole

    auth: Optional[dmda.DomoAuth] = field(repr=False, default=None)

    def __post_init__(self):
        self.id = str(self.id)

    def __eq__(self, other):
        if not isinstance(other, DomoUser):
            return False

        return self.id == other.id

    @classmethod
    def _from_search_json(cls, auth, user_obj):
        user_dd = util_dd.DictDot(user_obj)

        return cls(
            auth=auth,
            id=str(user_dd.id or user_dd.userId),
            display_name=user_dd.displayName,
            title=user_dd.title,
            department=user_dd.department,
            email_address=user_dd.emailAddress or user_dd.email,
            role_id=user_dd.roleId,
            avatar_key=user_dd.avatarKey,
            phone_number=user_dd.phoneNumber,
            web_landing_page=user_dd.webLandingPage,
            web_mobile_landing_page=user_dd.webMobileLandingPage,
            employee_id=user_dd.employeeId,
            employee_number=user_dd.employeeNumber,
            hire_date=user_dd.hireDate,
            reports_to=user_dd.reportsTo,
        )

    @classmethod
    def _from_virtual_json(cls, auth, user_obj):
        user_dd = util_dd.DictDot(user_obj)

        return cls(
            id=user_dd.id,
            auth=auth,
            publisher_domain=user_dd.publisherDomain,
            subscriber_domain=user_dd.subscriberDomain,
            virtual_user_id=user_dd.virtualUserId,
        )

    @classmethod
    def _from_bootstrap_json(cls, auth, user_obj):
        dd = user_obj
        if isinstance(user_obj, dict):
            dd = util_dd.DictDot(user_obj)

        return cls(id=dd.id, display_name=dd.displayName, auth=auth)

# %% ../../nbs/classes/50_DomoUser.ipynb 11
@patch_to(DomoUser)
async def get_role(
    self: DomoUser,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: httpx.AsyncClient = None,
):
    import domolibrary.classes.DomoRole as dmr

    self.role = await dmr.DomoRole.get_by_id(
        role_id=self.role_id,
        auth=self.auth,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
    )

    return self.role

# %% ../../nbs/classes/50_DomoUser.ipynb 12
@patch_to(DomoUser, cls_method=True)
async def get_by_id(
    cls: DomoUser,
    user_id,
    auth: dmda.DomoAuth,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: httpx.AsyncClient = None,
):
    """
    searches and returns a domo user
    will throw an error if no user returned with an option to suppress_no_results_error
    """

    res = await user_routes.get_by_id(
        auth=auth,
        user_id=user_id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
        parent_class=cls.__name__,
    )

    if return_raw:
        return res

    if not res.is_success:
        return None

    domo_user = cls._from_search_json(user_obj=res.response, auth=auth)

    await domo_user.get_role()

    return domo_user

# %% ../../nbs/classes/50_DomoUser.ipynb 16
@patch_to(DomoUser)
async def download_avatar(
    self: DomoUser,
    pixels: int = 300,
    folder_path="./images",
    img_name=None,  # will default to user_id
    auth: dmda.DomoAuth = None,
    is_download_image: bool = True,  # option to prevent downloading the image file
    debug_api: bool = False,
    return_raw: bool = False,
):
    """downloads a user's avatar to a folder
    and returns the byte representation of the image
    """
    auth = auth or self.auth

    # if not self.avatar_key:
    #     raise DownloadAvatar_NoAvatarKey(
    #         domo_instance=auth.domo_instance, user_id=self.id
    #     )

    res = await user_routes.download_avatar(
        auth=self.auth,
        user_id=self.id,
        pixels=pixels,
        folder_path=folder_path,
        img_name=img_name,
        is_download_image=is_download_image,
        debug_api=debug_api,
    )

    if return_raw:
        return res

    self.avatar = Image.from_bytestr(data=res.response)

    return self.avatar

    # return res.response

# %% ../../nbs/classes/50_DomoUser.ipynb 20
@patch_to(DomoUser)
async def upload_avatar(
    self,
    avatar: Image,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    avatar.crop_square()

    res = await user_routes.upload_avatar(
        auth=self.auth,
        user_id=self.id,
        img_bytestr=avatar.to_bytes(),
        img_type=avatar.format,
        debug_api=debug_api,
        parent_class=self.__class__.__name__,
        session=session,
    )

    if return_raw:
        return res

    await asyncio.sleep(2)

    return await self.download_avatar(debug_api=debug_api)

# %% ../../nbs/classes/50_DomoUser.ipynb 22
@patch_to(DomoUser)
async def upsert_avatar(
    self,
    avatar: Image,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
):
    avatar.crop_square()

    res = "images are the same"
    if not are_same_image(domo_default_img, avatar):

        res = await user_routes.upload_avatar(
            auth=self.auth,
            user_id=self.id,
            img_bytestr=avatar.to_bytes(),
            img_type=avatar.format,
            debug_api=debug_api,
            parent_class=self.__class__.__name__,
            session=session,
        )

        if return_raw:
            return res

    await asyncio.sleep(2)

    return await self.download_avatar(debug_api=debug_api)

# %% ../../nbs/classes/50_DomoUser.ipynb 23
@patch_to(DomoUser)
async def reset_password(self: DomoUser, new_password: str, debug_api: bool = False):
    """reset your password, will respect password restrictions set up in the Domo UI"""

    res = await user_routes.reset_password(
        auth=self.auth, user_id=self.id, new_password=new_password, debug_api=debug_api
    )

    return res

# %% ../../nbs/classes/50_DomoUser.ipynb 25
@patch_to(DomoUser, cls_method=True)
async def request_password_reset(
    cls,
    domo_instance: str,
    email: str,
    locale: str = "en-us",
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    """request password reset email.  Note: does not require authentication."""

    return await user_routes.request_password_reset(
        domo_instance=domo_instance,
        email=email,
        locale=locale,
        debug_api=debug_api,
        session=session,
    )

# %% ../../nbs/classes/50_DomoUser.ipynb 26
@patch_to(DomoUser)
async def set_user_landing_page(
    self: DomoUser,
    page_id: str,
    user_id: str = None,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
):
    res = await user_routes.set_user_landing_page(
        auth=auth or self.auth,
        page_id=page_id,
        user_id=self.id or user_id,
        debug_api=debug_api,
    )

    if res.status != 200:
        return False

    return True

# %% ../../nbs/classes/50_DomoUser.ipynb 28
@patch_to(DomoUser)
async def update_properties(
    self: DomoUser,
    property_ls: List[
        UserProperty
    ],  # use the UserProperty class to define a list of user properties to update, see user route documentation to see a list of UserProperty_Types that can be updated
    return_raw: bool = False,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    auth = auth or self.auth

    res = await user_routes.update_user(
        auth=auth,
        user_id=self.id,
        user_property_ls=property_ls,
        debug_api=debug_api,
        session=session,
    )
    if return_raw:
        return res

    self = await DomoUser.get_by_id(user_id=self.id, auth=auth)

    return self

# %% ../../nbs/classes/50_DomoUser.ipynb 33
@dataclass
class DomoUsers:
    """a class for searching for Users"""

    logger: Optional[lc.Logger] = None

    @classmethod
    def _users_to_domo_user(cls, user_ls, auth: dmda.DomoAuth):
        return [
            DomoUser._from_search_json(auth=auth, user_obj=user_obj)
            for user_obj in user_ls
        ]

    @classmethod
    def _users_to_virtual_user(cls, user_ls, auth: dmda.DomoAuth):
        return [
            DomoUser._from_virtual_json(auth=auth, user_obj=user_obj)
            for user_obj in user_ls
        ]

    def _generate_logger(self, logger: Optional[lc.Logger] = None):
        self.logger = logger or self.logger or lc.Logger(app_name="domo_users")

# %% ../../nbs/classes/50_DomoUser.ipynb 35
@patch_to(DomoUsers, cls_method=True)
async def all_users(
    cls: DomoUsers,
    auth: dmda.DomoAuth,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    logger: Optional[lc.Logger] = None,
) -> List[DomoUser]:
    """retrieves all users from Domo"""

    res = await user_routes.get_all_users(
        auth=auth,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=cls.__name__,
    )

    if return_raw:
        return res

    if not res.is_success:
        return None

    users_ls = res.response

    return cls._users_to_domo_user(user_ls=users_ls, auth=auth)

# %% ../../nbs/classes/50_DomoUser.ipynb 39
@patch_to(DomoUsers, cls_method=True)
async def by_id(
    cls: DomoUsers,
    auth: dmda.DomoAuth,
    user_ids: list[str],  # can search for one or multiple users
    only_allow_one: bool = True,
    debug_num_stacks_to_drop=2,
    debug_api: bool = False,
    return_raw: bool = False,
) -> list:

    res = await user_routes.search_users_by_id(
        return_raw=False,
        user_ids=user_ids,
        debug_api=debug_api,
        auth=auth,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=cls.__name__,
    )

    if return_raw:
        return res

    domo_users = cls._users_to_domo_user(user_ls=res.response, auth=auth)

    if only_allow_one:
        return domo_users[0]

    return domo_users

# %% ../../nbs/classes/50_DomoUser.ipynb 42
@patch_to(DomoUsers, cls_method=True)
def util_match_domo_users_to_emails(
    cls: DomoUsers, domo_users: list[DomoUser], user_email_ls: list[str]
) -> list:
    """pass in an array of user emails to match against an array of Domo User"""

    matches = []
    for idx, email in enumerate(user_email_ls):
        match_user = next(
            (
                domo_user
                for domo_user in domo_users
                if email.lower() == domo_user.email_address.lower()
            ),
            None,
        )
        if match_user:
            matches.append(match_user)
    return matches


@patch_to(DomoUsers, cls_method=True)
def util_match_users_obj_to_emails(
    cls: DomoUsers, user_ls: list[dict], user_email_ls: list[str]
) -> list:
    """pass in an array of user emails to match against an array of Domo User"""

    matches = []
    for idx, email in enumerate(user_email_ls):
        match_user = next(
            (
                user_obj
                for user_obj in user_ls
                if email.lower() == user_obj.get("emailAddress").lower()
            ),
            None,
        )
        if match_user:
            matches.append(match_user)
    return matches


@patch_to(DomoUsers, cls_method=True)
async def by_email(
    cls: DomoUsers,
    email_ls: list[str],
    auth: dmda.DomoAuth,
    only_allow_one: bool = True,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
) -> list:

    res = await user_routes.search_users_by_email(
        user_email_ls=email_ls,
        auth=auth,
        return_raw=False,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=cls.__name__,
    )

    if return_raw:
        return res

    domo_users = cls._users_to_domo_user(res.response, auth=auth)

    if only_allow_one:
        return cls.util_match_domo_users_to_emails(domo_users, email_ls)[0]

    return domo_users

# %% ../../nbs/classes/50_DomoUser.ipynb 46
@patch_to(DomoUsers, cls_method=True)
async def virtual_user_by_subscriber_instance(
    cls: DomoUsers,
    subscriber_instance_ls: str,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    return_raw: bool = False,
):
    res = await user_routes.search_virtual_user_by_subscriber_instance(
        auth=auth,
        subscriber_instance_ls=subscriber_instance_ls,
        debug_api=debug_api,
    )

    if return_raw:
        return res

    if not res.is_success:
        return None

    user_ls = res.response

    domo_users = cls._users_to_virtual_user(user_ls, auth=auth)
    return domo_users

# %% ../../nbs/classes/50_DomoUser.ipynb 51
@patch_to(DomoUsers, cls_method=True)
async def create_user(
    cls: DomoUsers,
    auth: dmda.DomoAuth,
    display_name,
    email_address,
    role_id,
    password: str = None,
    send_password_reset_email: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    """class method that creates a new Domo user"""

    res = await user_routes.create_user(
        auth=auth,
        display_name=display_name,
        email_address=email_address,
        role_id=role_id,
        debug_api=debug_api,
        session=session,
    )

    u = await DomoUser.get_by_id(
        auth=auth,
        user_id=res.response.get("id") or res.response.get("userId"),
    )

    if password:
        await u.reset_password(new_password=password)

    elif send_password_reset_email:
        await u.request_password_reset(
            domo_instance=auth.domo_instance, email=u.email_address
        )

    return u

# %% ../../nbs/classes/50_DomoUser.ipynb 54
@patch_to(DomoUsers, cls_method=True)
async def upsert_user(
    cls: DomoUsers,
    auth: dmda.DomoAuth,
    email_address: str,
    display_name: str = None,
    role_id: str = None,
    debug_api: bool = False,
    debug_prn: bool = False,
    session: httpx.AsyncClient = None,
):
    test_valid_email(email_address)

    try:
        domo_user = await cls.by_email(
            email_ls=[email_address],
            auth=auth,
            only_allow_one=True,
            debug_api=debug_api,
        )

        if domo_user:
            user_property_ls = []
            if display_name:
                user_property_ls.append(
                    user_routes.UserProperty(
                        user_routes.UserProperty_Type.display_name, display_name
                    )
                )

            if role_id:
                user_property_ls.append(
                    user_routes.UserProperty(
                        user_routes.UserProperty_Type.role_id, role_id
                    )
                )

            if user_property_ls:
                await user_routes.update_user(
                    user_id=domo_user.id,
                    user_property_ls=user_property_ls,
                    auth=auth,
                    debug_api=debug_api,
                )
        return await DomoUser.get_by_id(auth=auth, user_id=domo_user.id)

    except SearchUser_NoResults as e:
        if debug_prn:
            print(f"No user match -- creating new user in {auth.domo_instance}")

        if not role_id:
            raise CreateUser_MissingRole(
                domo_instance=auth.domo_instance, email_address=email_address
            ) from e

        return await cls.create_user(
            auth=auth,
            display_name=display_name or f"{email_address} - via dl {dt.date.today()}",
            email_address=email_address,
            role_id=role_id,
            debug_api=debug_api,
            session=session,
        )

    # finally:
    #     if grant_ls:
    #         grant_ls = domo_role._valid_grant_ls(grant_ls)
    #         await domo_role.set_grants(grant_ls=grant_ls)

# %% ../../nbs/classes/50_DomoUser.ipynb 56
@patch_to(DomoUser)
async def delete_user(
    self: DomoUser,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=2,
    parent_class=None,
):
    auth = auth or self.auth

    res = await user_routes.delete_user(
        auth=auth,
        user_id=self.id,
        debug_api=debug_api,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise DeleteUser_Error(account_id=self.id, domo_instance=auth.domo_instance)

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\client\DomoAuth.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\client\DomoAuth.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/client/95_DomoAuth.ipynb.

# %% auto 0
__all__ = ['DomoAuth', 'DomoFullAuth', 'test_is_full_auth', 'DomoTokenAuth', 'DomoDeveloperAuth', 'DomoJupyterAuth',
           'DomoJupyterFullAuth', 'DomoJupyterTokenAuth', 'test_is_jupyter_auth']

# %% ../../nbs/client/95_DomoAuth.ipynb 2
from domolibrary.routes.auth import (
    AccountLockedError,
    InvalidAuthTypeError,
    InvalidCredentialsError,
    InvalidInstanceError,
    NoAccessTokenReturned,
)

# %% ../../nbs/client/95_DomoAuth.ipynb 3
from dataclasses import dataclass, field
from typing import Optional, Union
from urllib.parse import urlparse


import httpx

import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.Logger as lg
import domolibrary.client.DomoError as de

import domolibrary.routes.auth as auth_routes

# %% ../../nbs/client/95_DomoAuth.ipynb 7
@dataclass
class _DomoAuth_Required:
    """required parameters for all Domo Auth classes"""

    domo_instance: str

    def __post_init__(self):
        if self.domo_instance:
            self.set_manual_login()

    def set_manual_login(self):
        self.url_manual_login = (
            f"https://{self.domo_instance}.domo.com/auth/index?domoManualLogin=true"
        )
        return self.url_manual_login

    async def who_am_i(
        self, debug_api: bool = False, session: httpx.AsyncClient = None
    ):

        auth_header = self.auth_header or await self.generate_auth_header()

        res = await auth_routes.who_am_i(
            domo_instance=self.domo_instance,
            auth_header=auth_header,
            parent_class=self.__class__.__name__,
        )

        return res

    async def print_is_token(self, token_name=None) -> None:

        if not self.token:
            await self.get_auth_token()

        self.token_name = token_name or self.token_name
        token_str = f"{self.token_name} " or ""

        if not self.token:
            print(f"üöß failed to retrieve {token_str}token from {self.domo_instance}")
            return False

        print(f"üéâ {token_str }token retrieved from {self.domo_instance} ‚öôÔ∏è")
        return True


@dataclass
class _DomoAuth_Optional:
    """parameters are defined after initialization"""

    auth_header: dict = field(default_factory=lambda: {}, repr=False)
    token: str = field(default=None, repr=False)
    token_name: str = field(default=None)
    user_id: str = field(default=None, repr=False)

    is_valid_token: bool = None

    url_manual_login: Optional[str] = None

    async def get_auth_token(self) -> Union[str, None]:
        """placeholder method"""
        pass

    async def generate_auth_header(self) -> Union[dict, None]:
        """returns auth header appropriate for this authentication method"""
        pass

# %% ../../nbs/client/95_DomoAuth.ipynb 8
@dataclass
class DomoAuth(_DomoAuth_Optional, _DomoAuth_Required):
    """abstract DomoAuth class"""

# %% ../../nbs/client/95_DomoAuth.ipynb 12
@dataclass
class _DomoFullAuth_Required:
    """mix requied parameters for DomoFullAuth"""

    domo_username: str
    domo_password: str = field(repr=False)

# %% ../../nbs/client/95_DomoAuth.ipynb 13
@dataclass
class DomoFullAuth(_DomoAuth_Optional, _DomoFullAuth_Required, _DomoAuth_Required):
    """use for full authentication token"""

    async def _generate_auth_header(self, token: str = None) -> dict:
        token = token or self.token or await self.get_auth_token()

        self.token = token

        self.auth_header = {"x-domo-authentication": token}

        return self.auth_header

    async def generate_auth_header(self, token: str = None) -> dict:
        return await self._generate_auth_header(token=token)

    async def get_auth_token(
        self,
        session: Optional[httpx.AsyncClient] = None,
        return_raw: bool = False,
        debug_api: bool = False,
    ) -> str:
        """returns `token` if valid credentials provided else raises Exception and returns None"""

        res = await auth_routes.get_full_auth(
            domo_instance=self.domo_instance,
            domo_username=self.domo_username,
            domo_password=self.domo_password,
            session=session,
            debug_api=debug_api,
            parent_class=self.__class__.__name__,
        )

        if return_raw:
            return res

        self.is_valid_token = True

        token = str(res.response.get("sessionToken"))
        self.token = token
        self.user_id = str(res.response.get("userId"))

        await self.generate_auth_header()

        self.token_name = self.token_name or "full_auth"

        return self.token

# %% ../../nbs/client/95_DomoAuth.ipynb 18
def test_is_full_auth(
    auth, function_name=None, num_stacks_to_drop=1  # pass q for route pass 2 for class
):

    tb = lg.get_traceback(num_stacks_to_drop=num_stacks_to_drop)

    function_name = function_name or tb.function_name

    if auth.__class__.__name__ != "DomoFullAuth":
        raise InvalidAuthTypeError(
            function_name=function_name,
            domo_instance=auth.domo_instance,
            required_auth_type=DomoFullAuth,
        )

# %% ../../nbs/client/95_DomoAuth.ipynb 20
@dataclass
class _DomoTokenAuth_Required:
    """mix requied parameters for DomoFullAuth"""

    domo_access_token: str = field(repr=False)

    async def who_am_i(
        self, debug_api: bool = False, session: httpx.AsyncClient = None
    ):

        auth_header = self.auth_header or await self.generate_auth_header()

        res = await auth_routes.who_am_i(
            domo_instance=self.domo_instance,
            auth_header=auth_header,
            parent_class=self.__class__.__name__,
        )

        return res

# %% ../../nbs/client/95_DomoAuth.ipynb 21
@dataclass
class DomoTokenAuth(_DomoAuth_Optional, _DomoTokenAuth_Required, _DomoAuth_Required):
    """
    use for access_token authentication.
    Tokens are generated in domo > admin > access token
    Necessary in cases where direct sign on is not permitted
    """

    async def _generate_auth_header(self) -> dict:
        """returns auth_header for validating API requests using access_tokens / developer tokens"""

        "is this being executed as part of get_auth_token chain? if yes, suppress not validated error"
        traceback_details = lg.get_traceback(num_stacks_to_drop=0)
        function_name = traceback_details.function_name

        if len(traceback_details.traceback_stack) >= 3:
            function_name = traceback_details.traceback_stack[-3][2]

        if not function_name == "get_auth_token" and not self.token:
            print(
                "warning this token has not been validated by who_am_i, run get_auth_token first"
            )

        self.auth_header = {
            "x-domo-developer-token": self.token or self.domo_access_token
        }
        return self.auth_header

    async def generate_auth_header(self):
        return await self._generate_auth_header()

    async def get_auth_token(
        self, session: Optional[httpx.AsyncClient] = None, debug_api: bool = False
    ) -> str:
        """
        updates internal attributes
        having an access_token assumes pre-authenticaiton
        """

        res = await self.who_am_i()

        assert res.is_success

        self.is_valid_token = True

        self.token = self.domo_access_token
        self.user_id = res.response.get("id")

        self.auth_header = await self.generate_auth_header()

        if not self.token_name:
            self.token_name = "token_auth"

        return self.token

# %% ../../nbs/client/95_DomoAuth.ipynb 26
@dataclass
class _DomoDeveloperAuth_Required:
    """mix requied parameters for DomoDeveloperAuth"""

    domo_client_id: str
    domo_client_secret: str = field(repr=False)


@dataclass
class _DomoDeveloperAuth_Optional:
    """mix optional parameters for DomoDeveloperAuth"""

    domo_instance: str = None  # because api.domo.com apis don't require domo_instance

# %% ../../nbs/client/95_DomoAuth.ipynb 27
@dataclass
# (init=False)
class DomoDeveloperAuth(
    _DomoDeveloperAuth_Optional, _DomoAuth_Optional, _DomoDeveloperAuth_Required
):
    """use for full authentication token"""

    # def __init__(self, domo_client_id: str, domo_client_secret: str):
    #     self.domo_client_id = domo_client_id
    #     self.domo_client_secret = domo_client_secret
    #     self.domo_instance = ""

    async def generate_auth_header(self) -> dict:
        token = self.token or await self.get_auth_token()

        self.auth_header = {"Authorization": "bearer " + token}
        return self.auth_header

    async def get_auth_token(
        self, session: Optional[httpx.AsyncClient] = None, debug_api: bool = False
    ) -> str:

        res = await auth_routes.get_developer_auth(
            domo_client_id=self.domo_client_id,
            domo_client_secret=self.domo_client_secret,
            session=session,
            debug_api=debug_api,
            parent_class=self.__class__.__name__,
        )
        assert res.is_success

        self.is_valid_token = True

        self.token = str(res.response.get("access_token"))
        self.user_id = res.response.get("userId")
        self.domo_instance = res.response.get("domain")
        self.set_manual_login()

        self.auth_header = await self.generate_auth_header()

        self.token_name = self.token_name or "developer_auth"

        return self.token

# %% ../../nbs/client/95_DomoAuth.ipynb 31
@dataclass
class _DomoJupyter_Optional:
    def __post_init__(self):

        self.jupyter_token = self.jupyter_token or input(
            "jupyter token: # retrieve this by monitoring domo jupyter network traffic.  it is the Authorization header"
        )
        self.service_location = self.service_location or input(
            "service_location:  # retrieve from domo jupyter env"
        )
        self.service_prefix = self.service_prefix or input(
            "service prefix: # retrieve from domo jupyter env"
        )

        self._test_prereq()
        self.set_manual_login()


@dataclass
class _DomoJupyter_Required:
    jupyter_token: str
    service_location: str
    service_prefix: str

    def get_jupyter_token_flow(self):
        """stub"""
        print("hello world i am a jupyter_token")

    def _test_prereq(self):
        if not self.jupyter_token:
            raise Exception("DomoJupyterAuth objects must have a jupyter_token")

        if not self.service_location:
            raise Exception("DomoJupyterAuth objects must have a service_location")

        if not self.service_prefix:
            raise Exception("DomoJupyterAuth objects must have a service_prefix")

        if (
            not self.jupyter_token
            or not self.service_location
            or not self.service_prefix
        ):
            raise Exception(
                "DomoJupyterAuth objects must have jupyter_token, service_location and service_prefix"
            )

# %% ../../nbs/client/95_DomoAuth.ipynb 32
@dataclass
class DomoJupyterAuth(_DomoJupyter_Optional, _DomoJupyter_Required):
    """base class"""

# %% ../../nbs/client/95_DomoAuth.ipynb 34
@dataclass
class DomoJupyterFullAuth(_DomoJupyter_Optional, DomoFullAuth, _DomoJupyter_Required):

    @classmethod
    def convert_auth(
        cls, auth: DomoFullAuth, jupyter_token, service_location, service_prefix
    ):
        """converts DomoFullAuth to DomoJupyterFullAuth
        i.e. adds DomoJupyter specific auth fields
        eventually can add DomoJupyter specific auth flow for generating auth token
        """
        c = cls(
            domo_instance=auth.domo_instance,
            domo_username=auth.domo_username,
            domo_password=auth.domo_password,
            jupyter_token=jupyter_token,
            service_location=service_location,
            service_prefix=service_prefix,
        )

        return c

    async def generate_auth_header(self, token: str = None) -> dict:
        await self._generate_auth_header(token)

        self.auth_header.update(
            {
                "authorization": f"Token {self.jupyter_token}",
            }
        )

        return self.auth_header

# %% ../../nbs/client/95_DomoAuth.ipynb 38
@dataclass
class DomoJupyterTokenAuth(_DomoJupyter_Optional, DomoTokenAuth, _DomoJupyter_Required):
    @classmethod
    def convert_auth(
        cls, auth: DomoTokenAuth, jupyter_token, service_location, service_prefix
    ):
        """converts DomoTokenAuth to DomoJupyterTokenAuth
        i.e. adds DomoJupyter specific auth fields
        eventually can add DomoJupyter specific auth flow for generating auth token
        """
        return cls(
            domo_instance=auth.domo_instance,
            domo_access_token=auth.domo_access_token,
            jupyter_token=jupyter_token,
            service_location=service_location,
            service_prefix=service_prefix,
        )

    async def generate_auth_header(self) -> dict:
        await self._generate_auth_header()

        self.auth_header.update(
            {
                "authorization": f"Token {self.jupyter_token}",
            }
        )

        return self.auth_header

# %% ../../nbs/client/95_DomoAuth.ipynb 42
def test_is_jupyter_auth(
    auth: DomoJupyterAuth,
    function_name=None,
    required_auth_type_ls=[DomoJupyterFullAuth, DomoJupyterTokenAuth],
):

    tb = lg.get_traceback()

    if auth.__class__.__name__ not in [
        auth_type.__name__ for auth_type in required_auth_type_ls
    ]:
        raise InvalidAuthTypeError(
            function_name=tb.function_name,
            domo_instance=auth.domo_instance,
            required_auth_type_ls=required_auth_type_ls,
        )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\client\DomoError.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\client\DomoError.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/client/DomoError.ipynb.

# %% auto 0
__all__ = ['DomoError', 'AuthNotProvidedError', 'DatasetNotProvidedError']

# %% ../../nbs/client/DomoError.ipynb 2
from typing import Optional

# %% ../../nbs/client/DomoError.ipynb 3
class DomoError(Exception):
    """base exception"""

    def __init__(
        self,
        entity_id: Optional[str] = None,
        function_name: Optional[str] = None,
        status: Optional[int] = None,  # API request status
        message: str = "error",  # <domo_instance>.domo.com
        domo_instance: Optional[str] = None,
        parent_class: str = None,
        is_exception_not_error: bool = False,
    ):
        function_str = ""

        if function_name:
            function_str = f"{function_name} || "

        if parent_class and function_name:
            function_str = f"{parent_class}.{function_str}"
        if parent_class and not function_name:
            function_str = f"{parent_class} || "
        function_str = f"function: {function_str}"

        entity_str = f"{entity_id} || " if entity_id else ""
        instance_str = f" at {domo_instance}" if domo_instance else ""
        status_str = f"status {status} || " if status else ""
        prefix = "üõë " if not is_exception_not_error else "‚ö†Ô∏è "

        self.message = f"{prefix} {self.__class__.__name__} {prefix}- {function_str}{entity_str}{status_str}{message}{instance_str}"
        super().__init__(self.message)

# %% ../../nbs/client/DomoError.ipynb 6
class AuthNotProvidedError(DomoError):
    def __init__(
        self,
        entity_id,
        function_name,
        message="valid Auth object not provided",
        status=None,
        domo_instance=None,
    ):

        super().__init__(
            entity_id=entity_id,
            function_name=function_name,
            status=status,
            message=message,
            domo_instance=domo_instance,
        )

# %% ../../nbs/client/DomoError.ipynb 7
class DatasetNotProvidedError(DomoError):
    def __init__(
        self,
        function_name,
        message="dataset_id not provided",
        domo_instance=None,
        entity_id=None,
        status=None,
    ):

        super().__init__(
            entity_id=entity_id,
            function_name=function_name,
            status=status,
            message=message,
            domo_instance=domo_instance,
        )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\client\get_data.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\client\get_data.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/client/10_get_data.ipynb.

# %% auto 0
__all__ = ['create_aiohttp_session', 'create_headers', 'get_data_aiohttp', 'GetData_Error', 'get_data', 'get_data_stream',
           'LooperError', 'looper', 'looper_aiohttp', 'RouteFunction_ResponseTypeError', 'route_function']

# %% ../../nbs/client/10_get_data.ipynb 2
from typing import Callable, Optional, Union, Tuple, Any
from functools import wraps
import time

import httpx
import aiohttp
import asyncio
import json

from pprint import pprint

import domolibrary.client.DomoAuth as dmda
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoError as de
import domolibrary.client.Logger as dl

# %% ../../nbs/client/10_get_data.ipynb 4
async def create_aiohttp_session(
    session: aiohttp.ClientSession = None,
) -> Tuple[aiohttp.ClientSession, bool]:
    is_close_session = False
    if session is None:
        is_close_session = True
        session = aiohttp.ClientSession()
    return session, is_close_session


def create_headers(
    auth: dmda.DomoAuth,  # The authentication object containing the Domo API token.
    content_type: dict = None,  # The content type for the request. Defaults to None.
    headers: dict = None,  # Any additional headers for the request. Defaults to None.
) -> dict:  # The headers for the request.
    """
    Creates default headers for interacting with Domo APIs.
    """
    if headers is None:
        headers = {}
    headers = {
        "Content-Type": content_type or "application/json",
        "Connection": "keep-alive",
        "accept": "application/json, text/plain",
        **headers,
    }
    if auth:
        headers.update(**auth.auth_header)
    return headers

# %% ../../nbs/client/10_get_data.ipynb 5
async def get_data_aiohttp(
    url: str,
    method: str,
    auth: dmda.DomoAuth,
    content_type: Optional[dict] = None,
    headers: Optional[dict] = None,
    # if no session passed by default will create and close session during execution
    session: Optional[aiohttp.ClientSession] = None,
    body: Union[dict, str, None] = None,
    params: Optional[dict] = None,
    debug_api: bool = False,
    process_stream: bool = False,
    stream_chunks: int = 10,
) -> rgd.ResponseGetData:
    """async wrapper for asyncio requests"""

    if auth and not auth.token:
        await auth.get_auth_token()

    session, is_close_session = await create_aiohttp_session(session)
    headers = create_headers(auth, content_type, headers)

    if debug_api:
        pprint(
            {
                "method": method,
                "url": url,
                "headers": headers,
                "json": body,
                "params": params,
            }
        )

    try:
        if headers.get("Content-Type") == "application/json":
            res = await session.request(
                method=method.upper(),
                url=url,
                headers=headers,
                json=body,
                params=params,
            )

        elif body is not None:
            res = await session.request(
                method=method.upper(),
                url=url,
                headers=headers,
                data=body,
                params=params,
            )

        else:
            res = await session.request(
                method=method.upper(), url=url, headers=headers, params=params
            )
        return await rgd.ResponseGetData._from_aiohttp_response(
            res, auth=auth, process_stream=process_stream, stream_chunks=stream_chunks
        )

    except Exception as e:
        print(e)

    finally:
        if is_close_session:
            await session.close()

# %% ../../nbs/client/10_get_data.ipynb 8
class GetData_Error(de.DomoError):
    def __init__(self, message, url):
        super().__init__(message=message, domo_instance=url)

# %% ../../nbs/client/10_get_data.ipynb 9
def create_httpx_session(
    session: httpx.AsyncClient = None, is_verify: bool = False
) -> Tuple[httpx.AsyncClient, bool]:
    is_close_session = False
    if session is None:
        is_close_session = True
        session = httpx.AsyncClient(verify=is_verify)
    return session, is_close_session


async def handle_error(e, url, attempt, max_attempt):
    print(f"‚ÑπÔ∏è get_data error - {e} at {url}")
    attempt += 1
    if attempt == max_attempt:
        raise GetData_Error(url=url, message=e) from e
    await asyncio.sleep(5)
    return attempt

# %% ../../nbs/client/10_get_data.ipynb 10
async def get_data(
    url: str,
    method: str,
    auth: dmda.DomoAuth,
    content_type: Optional[dict] = None,
    headers: Optional[dict] = None,
    body: Union[dict, str, None] = None,
    params: Optional[dict] = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
    is_follow_redirects: bool = False,
    timeout=10,
    parent_class: str = None,  # name of the parent calling class
    num_stacks_to_drop: int = 2,  # number of stacks to drop from the stack trace.  see `domolibrary.client.Logger.TracebackDetails`.  use 2 with class > route structure.  use 1 with route based approach
    debug_traceback: bool = False,
    is_verify: bool = False,
) -> rgd.ResponseGetData:
    """async wrapper for asyncio requests"""

    if debug_api:
        print("üêõ debugging get_data")

    if auth and not auth.token:
        await auth.get_auth_token()

    headers = create_headers(auth=auth, content_type=content_type, headers=headers)

    session, is_close_session = create_httpx_session(
        session=session, is_verify=is_verify
    )

    traceback_details = dl.get_traceback(
        num_stacks_to_drop=num_stacks_to_drop,
        root_module="<module>",
        parent_class=parent_class,
        debug_traceback=debug_traceback,
    )

    if debug_api:
        pprint(
            {
                "parent_class": parent_class,
                "function_name": traceback_details.function_name,
                "method": method,
                "url": url,
                "headers": headers,
                "body": body,
                "params": params,
            }
        )

    attempt = 1
    max_attempt = 4

    while attempt <= max_attempt:
        try:
            if isinstance(body, dict) or isinstance(body, list):
                if debug_api:
                    print("get_data: sending json")

                if method.lower() == "delete":
                    res = httpx.request(
                        method="DELETE",
                        url=url,
                        headers=headers,
                        content=json.dumps(body),
                        params=params,
                        follow_redirects=is_follow_redirects,
                        timeout=timeout,
                    )
                else:
                    res = await getattr(session, method.lower())(
                        url=url,
                        headers=headers,
                        json=body,
                        params=params,
                        follow_redirects=is_follow_redirects,
                        timeout=timeout,
                    )

            elif body:
                if debug_api:
                    print("get_data: sending data")

                res = await getattr(session, method.lower())(
                    url=url,
                    headers=headers,
                    data=body,
                    params=params,
                    follow_redirects=is_follow_redirects,
                    timeout=timeout,
                )

            else:
                if debug_api:
                    print("get_data: no body")

                res = await getattr(session, method.lower())(
                    url=url,
                    headers=headers,
                    params=params,
                    follow_redirects=is_follow_redirects,
                    timeout=timeout,
                )

            if debug_api:
                print("get_data_response", res)

            if return_raw:
                return res

            return rgd.ResponseGetData._from_httpx_response(
                res, auth=auth, traceback_details=traceback_details
            )

        except (httpx.TransportError, RuntimeError) as e:
            attempt = await handle_error(e, url, attempt, max_attempt)
            session = httpx.AsyncClient()

        finally:
            if is_close_session:
                await session.aclose()

# %% ../../nbs/client/10_get_data.ipynb 15
async def get_data_stream(
    url: str,
    auth: dmda.DomoAuth,
    method: str = "GET",
    content_type: Optional[dict] = None,
    headers: Optional[dict] = None,
    # body: Union[dict, str, None] = None,
    params: Optional[dict] = None,
    debug_api: bool = False,
    timeout: int = 10,
    parent_class: str = None,  # name of the parent calling class
    num_stacks_to_drop: int = 2,  # number of stacks to drop from the stack trace.  see `domolibrary.client.Logger.TracebackDetails`.  use 2 with class > route structure.  use 1 with route based approach
    debug_traceback: bool = False,
    session: httpx.AsyncClient = None,
    is_verify: bool = False,
) -> rgd.ResponseGetData:
    """async wrapper for asyncio requests"""

    create_httpx_session(session=session, is_verify=is_verify)
    if debug_api:
        print("üêõ debugging get_data")

    if auth and not auth.token:
        await auth.get_auth_token()

    if headers is None:
        headers = {}

    headers = {
        "Content-Type": content_type or "application/json",
        "Connection": "keep-alive",
        "accept": "application/json, text/plain",
        **headers,
    }

    if auth:
        headers.update(**auth.auth_header)

    traceback_details = dl.get_traceback(
        num_stacks_to_drop=num_stacks_to_drop,
        root_module="<module>",
        parent_class=parent_class,
        debug_traceback=debug_traceback,
    )

    if debug_api:
        pprint(
            {
                "method": method,
                "url": url,
                "headers": headers,
                # "body": body,
                "params": params,
                "traceback_details": traceback_details,
            }
        )

    attempt = 1
    max_attempt = 3

    content = bytearray()

    try:
        async with session or httpx.AsyncClient(verify=False) as client:
            async with client.stream(method, url=url, headers=headers) as res:
                if res.status_code == 200:
                    async for chunk in res.aiter_bytes():
                        content += chunk

                return rgd.ResponseGetData(
                    status=res.status_code,
                    response=content,
                    is_success=True,
                    auth=auth,
                    traceback_details=traceback_details,
                )

    except httpx.TransportError as e:
        print(f"‚ÑπÔ∏è get_data error - {e} at {url}")
        attempt += 1

        if attempt == max_attempt:
            raise GetData_Error(url=url, message=e) from e

        await asyncio.sleep(5)

# %% ../../nbs/client/10_get_data.ipynb 19
class LooperError(Exception):
    def __init__(self, loop_stage: str, message):
        super().__init__(f"{loop_stage} - {message}")

# %% ../../nbs/client/10_get_data.ipynb 20
async def looper(
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient,
    url,
    offset_params,
    arr_fn: callable,
    loop_until_end: bool = False,  # usually you'll set this to true.  it will override maximum
    method="POST",
    body: dict = None,
    fixed_params: dict = None,
    offset_params_in_body: bool = False,
    body_fn=None,
    limit=1000,
    skip=0,
    maximum=0,
    debug_api: bool = False,
    debug_loop: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
    timeout: bool = 10,
    wait_sleep: int = 0,
    is_verify: bool = False,
) -> rgd.ResponseGetData:
    is_close_session = False

    session, is_close_session = create_httpx_session(session, is_verify=is_verify)

    allRows = []
    isLoop = True

    res = None

    if maximum and maximum <= limit and not loop_until_end:
        limit = maximum

    while isLoop:
        params = fixed_params or {}

        if offset_params_in_body:
            body.update(
                {offset_params.get("offset"): skip, offset_params.get("limit"): limit}
            )

        else:
            params.update(
                {offset_params.get("offset"): skip, offset_params.get("limit"): limit}
            )

        if body_fn:
            try:
                body = body_fn(skip, limit, body)

            except Exception as e:
                await session.aclose()
                raise LooperError(
                    loop_stage="processing body_fn", message=str(e)
                ) from e

        if debug_loop:
            print(f"\nüöÄ Retrieving records {skip} through {skip + limit} via {url}")
            # pprint(params)

        res = await get_data(
            auth=auth,
            url=url,
            method=method,
            params=params,
            session=session,
            body=body,
            debug_api=debug_api,
            timeout=timeout,
            parent_class=parent_class,
            num_stacks_to_drop=debug_num_stacks_to_drop,
        )

        if not res.is_success:
            if is_close_session:
                await session.aclose()

            return res

        try:
            newRecords = arr_fn(res)

        except Exception as e:
            await session.aclose()
            raise LooperError(loop_stage="processing arr_fn", message=str(e)) from e

        allRows += newRecords

        if len(newRecords) == 0:
            isLoop = False

        if maximum and len(allRows) >= maximum and not loop_until_end:
            isLoop = False

        if debug_loop:
            print({"all_rows": len(allRows), "new_records": len(newRecords)})
            print(f"skip: {skip}, limit: {limit}")

        if maximum and skip + limit > maximum and not loop_until_end:
            limit = maximum - len(allRows)

        skip += len(newRecords)
        time.sleep(wait_sleep)

    if debug_loop:
        print(
            f"\nüéâ Success - {len(allRows)} records retrieved from {url} in query looper\n"
        )

    if is_close_session:
        await session.aclose()

    return await rgd.ResponseGetData._from_looper(res=res, array=allRows)

# %% ../../nbs/client/10_get_data.ipynb 24
async def looper_aiohttp(
    auth: dmda.DomoAuth,
    session: aiohttp.ClientSession,
    url,
    offset_params,
    arr_fn: callable,
    loop_until_end: bool = False,
    method="POST",
    body: dict = None,
    fixed_params: dict = None,
    offset_params_in_body: bool = False,
    body_fn=None,
    limit=1000,
    skip=0,
    maximum=2000,
    debug_api: bool = False,
    debug_loop: bool = False,
) -> rgd.ResponseGetData:
    is_close_session = False

    if not session:
        session = aiohttp.ClientSession()
        is_close_session = True

    allRows = []
    isLoop = True

    res = None

    if maximum < limit:
        limit = maximum

    while isLoop:
        params = fixed_params or {}

        if offset_params_in_body:
            body[offset_params.get("offset")] = skip
            body[offset_params.get("limit")] = limit

        else:
            params[offset_params.get("offset")] = skip
            params[offset_params.get("limit")] = limit

        if body_fn:
            try:
                body = body_fn(skip, limit)

            except Exception as e:
                await session.aclose()
                raise LooperError(
                    loop_stage="processing body_fn", message=str(e)
                ) from e

        if debug_loop:
            print(f"\nüöÄ Retrieving records {skip} through {skip + limit} via {url}")
            # pprint(params)

        res = await get_data_aiohttp(
            auth=auth,
            url=url,
            method=method,
            params=params,
            session=session,
            body=body,
            debug_api=debug_api,
        )

        if not res.is_success:
            if is_close_session:
                await session.aclose()
            return res

        try:
            newRecords = arr_fn(res)

        except Exception as e:
            await session.close()
            raise LooperError(loop_stage="processing arr_fn", message=str(e)) from e

        allRows += newRecords

        if loop_until_end and len(newRecords) != 0:
            maximum = maximum + limit

        if debug_loop:
            print({"all_rows": len(allRows), "new_records": len(newRecords)})

        if len(allRows) >= maximum or len(newRecords) == 0:
            if debug_loop:
                print(
                    f"\nüéâ Success - {len(allRows)} records retrieved from {url} in query looper\n"
                )

            break

        skip += len(newRecords)

        if skip + limit > maximum:
            limit = maximum - len(allRows)

            if debug_loop:
                print(f"skip: {skip}, limit: {limit}")

    if is_close_session:
        await session.close()

    return await rgd.ResponseGetData._from_looper(res=res, array=allRows)

# %% ../../nbs/client/10_get_data.ipynb 26
class RouteFunction_ResponseTypeError(TypeError):
    def __init__(self, result):
        super().__init__(
            f"Expected function to return an instance of ResponseGetData got {type(result)} instead.  Refactor function to return ResponseGetData class"
        )


def route_function(func: Callable[..., Any]) -> Callable[..., Any]:
    """
    Decorator for route functions to ensure they receive certain arguments.
    If these arguments are not provided, default values are used.

    Args:
        func (Callable[..., Any]): The function to decorate.

    Returns:
        Callable[..., Any]: The decorated function.

    The decorated function takes the following arguments:
        *args (Any): Positional arguments for the decorated function.
        parent_class (str, optional): The parent class. Defaults to None.
        debug_num_stacks_to_drop (int, optional): The number of stacks to drop for debugging. Defaults to 1.
        debug_api (bool, optional): Whether to debug the API. Defaults to False.
        session (httpx.AsyncClient, optional): The HTTPX client session. Defaults to None.
        **kwargs (Any): Additional keyword arguments for the decorated function.
    """

    @wraps(func)
    async def wrapper(
        *args: Any,
        parent_class: str = None,
        debug_num_stacks_to_drop: int = 1,
        debug_api: bool = False,
        session: httpx.AsyncClient = None,
        **kwargs: Any,
    ) -> Any:
        result = await func(
            *args,
            parent_class=parent_class,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            debug_api=debug_api,
            session=session,
            **kwargs,
        )

        if not isinstance(result, rgd.ResponseGetData):
            raise RouteFunction_ResponseTypeError(result)

        return result

    return wrapper

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\client\Logger.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\client\Logger.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/client/95_Logger.ipynb.

# %% auto 0
__all__ = ['TracebackDetails', 'get_traceback', 'Logger']

# %% ../../nbs/client/95_Logger.ipynb 2
import datetime as dt

from typing import Optional, List
from dataclasses import dataclass, field

import traceback

from nbdev.showdoc import patch_to

# %% ../../nbs/client/95_Logger.ipynb 5
@dataclass
class TracebackDetails:
    """result of _get_traceback_details function"""

    function_name: str
    file_name: str
    function_trail: str

    traceback_stack: [traceback.FrameSummary] = None
    parent_class: str = None

    def __init__(
        self,
        traceback_stack: [traceback.FrameSummary],
        parent_class=None,  # pass ParentClass.__name__
        debug_traceback: bool = False,
    ):
        self.function_trail = " -> ".join([line[2] for line in traceback_stack])

        self.function_name = traceback_stack[-1][2]
        self.file_name = traceback_stack[-1][0]
        self.parent_class = parent_class
        self.traceback_stack = traceback_stack


def get_traceback(
    root_module: str = "<module>",
    # drop entries from the top of stack to exclude the functions that retrieve the traceback
    num_stacks_to_drop=0,
    parent_class: str = None,
    debug_traceback: bool = False,
) -> TracebackDetails:  # returns a filtered list of FrameSummaries from traceback
    """method that retrieves traceback"""

    import traceback

    traceback_stack = traceback.extract_stack()

    # find the last module index
    module_index = 0

    for index, tb_line in enumerate(traceback_stack):
        function_name = tb_line[2]

        if function_name == root_module:
            module_index = index

    num_stacks_to_drop += 1  # adjust for init

    if module_index + num_stacks_to_drop >= len(traceback_stack) - 1:
        print("adjusting num_stacks_to_drop, consider revising `get_traceback` call")
        print(
            {
                "stack_length": len(traceback_stack),
                "module_index": module_index,
                "num_stacks_to_drop_passed": num_stacks_to_drop,
            }
        )
        num_stacks_to_drop -= 1

    filtered_traceback_stack = traceback_stack[module_index:-num_stacks_to_drop]

    if debug_traceback:
        print(
            {
                "len orig stack": len(traceback_stack),
                "len filtered stack": len(filtered_traceback_stack),
                "root_module_name": root_module,
                "root_module_index": module_index,
                "stacks_to_drop": num_stacks_to_drop,
            }
        )

    return TracebackDetails(
        traceback_stack=filtered_traceback_stack,
        parent_class=parent_class,
        debug_traceback=debug_traceback,
    )

# %% ../../nbs/client/95_Logger.ipynb 8
class Logger:
    """log class with user customizeable output method"""

    root_module: str
    app_name: str

    logs: List[dict]
    breadcrumb: Optional[list]

    entity_id: Optional[str]
    domo_instance: Optional[str]
    # function to call with write_logs method.
    output_fn: Optional[callable] = None

    def __init__(
        self,
        app_name: str,  # name of the app for grouping logs
        root_module: Optional[str] = "<module>",  # root module for stack trace
        output_fn: Optional[
            callable
        ] = None,  # function to call with write_logs method.
        entity_id: Optional[str] = None,
        domo_instance: Optional[str] = None,
    ):
        self.app_name = app_name
        self.output_fn = output_fn
        self.root_module = root_module
        self.logs = []
        self.breadcrumb = []
        self.domo_instance = domo_instance
        self.entity_id = entity_id

    def _add_crumb(self, crumb):
        if crumb not in self.breadcrumb:
            self.breadcrumb.append(crumb)

    def _remove_crumb(self, crumb):
        if crumb in self.breadcrumb:
            self.breadcrumb.remove(crumb)

    def get_traceback(
        self,
        root_module: str = "<module>",
        # drop entries from the top of stack to exclude the functions that retrieve the traceback
        num_stacks_to_drop=0,
        parent_class: str = None,
    ):
        parent_class = parent_class or self.__class__.__name__

        num_stacks_to_drop += 1

        return get_traceback(
            root_module=root_module,
            num_stacks_to_drop=num_stacks_to_drop,
            parent_class=parent_class,
        )

# %% ../../nbs/client/95_Logger.ipynb 13
@patch_to(Logger)
def _add_log(
    self: Logger,
    message: str,
    type_str: str,
    debug_log: bool = False,
    num_stacks_to_drop=3,
    entity_id: Optional[str] = None,
    domo_instance: Optional[str] = None,
) -> dict:
    """internal method to append message to log"""

    traceback_details = self.get_traceback(num_stacks_to_drop=num_stacks_to_drop)

    if debug_log:
        print(traceback_details.__dict__)

    new_row = {
        "date_time": dt.datetime.now(),
        "application": self.app_name,
        "log_type": type_str,
        "log_message": message,
        "breadcrumb": "->".join(self.breadcrumb),
        "domo_instance": domo_instance or self.domo_instance,
        "entity_id": entity_id or self.entity_id,
    }

    new_row.update(
        {
            "function_name": traceback_details.function_name,
            "file_name": traceback_details.file_name,
            "function_trail": traceback_details.function_trail,
        }
    )

    if debug_log:
        print(new_row)

    self.logs.append(new_row)

    return new_row


@patch_to(Logger)
def log_info(
    self: Logger,
    message,
    entity_id: Optional[str] = None,
    domo_instance: Optional[str] = None,
    debug_log=False,
    num_stacks_to_drop=3,
):
    """log an informational message"""
    return self._add_log(
        message=message,
        entity_id=entity_id,
        domo_instance=domo_instance,
        type_str="Info",
        num_stacks_to_drop=num_stacks_to_drop,
        debug_log=debug_log,
    )


@patch_to(Logger)
def log_error(
    self: Logger,
    message,
    entity_id: Optional[str] = None,
    domo_instance: Optional[str] = None,
    debug_log=False,
    num_stacks_to_drop=3,
):
    """log an error message"""

    return self._add_log(
        message=message,
        entity_id=entity_id,
        domo_instance=domo_instance,
        type_str="Error",
        num_stacks_to_drop=num_stacks_to_drop,
        debug_log=debug_log,
    )


@patch_to(Logger)
def log_warning(
    self: Logger,
    message,
    entity_id: Optional[str] = None,
    domo_instance: Optional[str] = None,
    debug_log=False,
    num_stacks_to_drop=3,
):
    """log a warning message"""

    return self._add_log(
        message=message,
        entity_id=entity_id,
        domo_instance=domo_instance,
        type_str="Warning",
        num_stacks_to_drop=num_stacks_to_drop,
        debug_log=debug_log,
    )

# %% ../../nbs/client/95_Logger.ipynb 16
@patch_to(Logger)
def output_log(self: Logger):
    """calls the user defined output function"""
    return self.output_fn(self.logs)

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\client\ResponseGetData.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\client\ResponseGetData.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/client/99_ResponseGetData.ipynb.

# %% auto 0
__all__ = ['STREAM_FILE_PATH', 'BlockedByVPN', 'ResponseGetData', 'find_ip']

# %% ../../nbs/client/99_ResponseGetData.ipynb 2
import re
from bs4 import BeautifulSoup

from dataclasses import dataclass, field
from typing import Optional, Any

import orjson

import asyncio
import requests
import httpx
import aiohttp

from nbdev.showdoc import patch_to

import domolibrary.client.DomoError as de
import domolibrary.client.Logger as dl

# %% ../../nbs/client/99_ResponseGetData.ipynb 5
class BlockedByVPN(de.DomoError):
    def __init__(
        self,
        domo_instance: Optional[str] = None,
        ip_address: str = None,
        function_name: str = "get_data",
    ):
        ip_address_str = f"from {ip_address}" if ip_address else ""
        message = f"request blocked {ip_address_str} - check VPN settings"

        super().__init__(
            message=message, domo_instance=domo_instance, function_name=function_name
        )

# %% ../../nbs/client/99_ResponseGetData.ipynb 6
@dataclass
class ResponseGetData:
    """preferred response class for all API Requests"""

    status: int
    response: Any
    is_success: bool
    auth: dict = field(repr=False, default=None)
    parent_class: str = None
    traceback_details: any = field(default=None, repr=False)

    def set_response(self, response):
        self.response = response

# %% ../../nbs/client/99_ResponseGetData.ipynb 11
@patch_to(ResponseGetData, cls_method=True)
def _from_requests_response(
    cls, res: requests.Response  # requests response object
) -> ResponseGetData:
    """returns ResponseGetData"""

    # JSON responses
    if res.ok and "application/json" in res.headers.get("Content-Type", {}):
        return cls(status=res.status_code, response=res.json(), is_success=True)

    # default text responses
    elif res.ok:
        return cls(status=res.status_code, response=res.text, is_success=True)

    # errors
    return cls(status=res.status_code, response=res.reason, is_success=False)

# %% ../../nbs/client/99_ResponseGetData.ipynb 16
def find_ip(html, html_tag: str = "p"):
    ip_address_regex = r"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})"
    soup = BeautifulSoup(html, "html.parser")

    return re.findall(ip_address_regex, str(soup.find(html_tag)))[0]

# %% ../../nbs/client/99_ResponseGetData.ipynb 17
@patch_to(ResponseGetData, cls_method=True)
def _from_httpx_response(
    cls,
    res: requests.Response,  # requests response object
    auth: Optional[any] = None,
    parent_class: str = None,
    traceback_details: dl.TracebackDetails = field(repr=False, default=None),
) -> ResponseGetData:
    """returns ResponseGetData"""

    # JSON responses
    ok = True if res.status_code <= 399 and res.status_code >= 200 else False

    if ok and "<title>Domo - Blocked</title>" in res.text:
        ip_address = find_ip(res.text)

        raise BlockedByVPN(auth.domo_instance, ip_address)

    if ok and "application/json" in res.headers.get("Content-Type", {}):
        try:
            return cls(
                status=res.status_code,
                response=res.json(),
                is_success=True,
                auth=auth,
                traceback_details=traceback_details,
                parent_class=parent_class,
            )

        except Exception as e:
            return cls(
                status=res.status_code,
                response=res.text,
                is_success=True,
                auth=auth,
                traceback_details=traceback_details,
                parent_class=parent_class,
            )

    # default text responses
    elif ok:
        return cls(
            status=res.status_code,
            response=res.text,
            is_success=True,
            auth=auth,
            traceback_details=traceback_details,
            parent_class=parent_class,
        )

    # errors
    return cls(
        status=res.status_code,
        response=res.reason_phrase,
        is_success=False,
        auth=auth,
        traceback_details=traceback_details,
        parent_class=parent_class,
    )

# %% ../../nbs/client/99_ResponseGetData.ipynb 19
STREAM_FILE_PATH = "__large-file.json"


async def _write_stream(
    res: httpx.Response, file_name: str = STREAM_FILE_PATH, stream_chunks=10
):
    print(type(res), type(res.content), stream_chunks)

    index = 0
    with open(file_name, "wb") as fd:
        async for chunk in res.content.iter_chunked(1024):
            index += 1
            print(f"writing chunk - {index}")
            fd.write(chunk)

            print(res.content.at_eof())

    print("done writing stream")

    return None


async def _read_stream(file_name: str):
    with open(file_name, "rb") as f:
        return f.read()

# %% ../../nbs/client/99_ResponseGetData.ipynb 20
@patch_to(ResponseGetData, cls_method=True)
async def _from_aiohttp_response(
    cls: ResponseGetData,
    res: aiohttp.ClientResponse,  # requests response object
    auth: Optional[any] = None,
    process_stream: bool = False,
    stream_chunks: int = 10,
    debug_api: bool = False,
    response_file_name: str = None,
    traceback_details: dl.TracebackDetails = None,
) -> ResponseGetData:
    """async method returns ResponseGetData"""
    if debug_api:
        print(f"ResponseGetData: res.ok = {res.ok} , res.status = {res.status}")

    try:
        data = None

        if process_stream:
            await _write_stream(res=res, stream_chunks=stream_chunks)
            data = await _read_stream(response_file_name)

        else:
            data = await res.text()

        if debug_api:
            print("converting to text complete")

    except asyncio.TimeoutError as e:
        print(f"ResponseGetDataError: {str(e)} , trying content.read")

        data = await res.content.read()

    if res.ok and "application/json" in res.headers.get("Content-Type", {}):
        try:
            return cls(
                status=res.status,
                response=orjson.loads(data),
                is_success=True,
                auth=auth,
                traceback_details=traceback_details,
            )
        except Exception as e:
            return cls(
                status=res.status,
                response=data,
                is_success=True,
                auth=auth,
                traceback_details=traceback_details,
            )

    elif res.ok:
        return cls(
            status=res.status,
            response=data,
            is_success=True,
            auth=auth,
            traceback_details=traceback_details,
        )

    # response is error
    else:
        return cls(
            status=res.status,
            response=res.reason,
            is_success=False,
            auth=auth,
            traceback_details=traceback_details,
        )

# %% ../../nbs/client/99_ResponseGetData.ipynb 25
@patch_to(ResponseGetData, cls_method=True)
async def _from_looper(
    cls: ResponseGetData, res: ResponseGetData, array: list  # requests response object
) -> ResponseGetData:
    """async method returns ResponseGetData"""

    if res.is_success:
        res.response = array
        return res

    # response is error
    else:
        return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\integrations\Automation.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\integrations\Automation.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/integrations/Automation.ipynb.

# %% auto 0
__all__ = ['remove_partition_by_x_days', 'get_company_domains']

# %% ../../nbs/integrations/Automation.ipynb 2
import datetime as dt
from dataclasses import dataclass
import pandas as pd

import domolibrary.client.DomoAuth as dmda
import domolibrary.classes.DomoDataset as dmds

# %% ../../nbs/integrations/Automation.ipynb 3
async def remove_partition_by_x_days(
    auth: dmda.DomoFullAuth,
    dataset_id: str,
    x_last_days: int = 0,
    separator: str = None,
    date_index: int = 0,
    date_format: str = "%Y-%m-%d",
):
    domo_ds = dmds.DomoDataset(auth=auth, id=dataset_id)

    list_partition = await domo_ds.list_partitions(auth=auth, dataset_id=dataset_id)

    today = dt.date.today()
    days_ago = today - dt.timedelta(days=x_last_days)
    for i in list_partition:
        compare_date = ""
        if separator is not None and separator != "":
            compare_date = i["partitionId"].split(separator)[date_index]
        else:
            compare_date = i["partitionId"]

        try:
            d = dt.datetime.strptime(compare_date, date_format).date()
        except ValueError:
            d = None
        if d is not None and d < days_ago:
            print(
                auth.domo_instance,
                ": üöÄ  Removing partition key : ",
                (i["partitionId"]),
                " in ",
                dataset_id,
            )
            await domo_ds.delete_partition(
                dataset_partition_id=i["partitionId"], dataset_id=dataset_id, auth=auth
            )

# %% ../../nbs/integrations/Automation.ipynb 5
async def get_company_domains(
    auth: dmda.DomoFullAuth,
    dataset_id: str,
    handle_err_fn: callable,
    sql: str = "select domain from table",
    global_admin_username: str = None,
    global_admin_password: str = None,
    execution_env: str = None,
    debug_api: bool = False,
) -> pd.DataFrame:
    ds = await dmds.DomoDataset.get_from_id(
        auth=auth, id=dataset_id, debug_api=debug_api
    )

    print(f"‚öôÔ∏è START - Retrieving company list \n{ds.display_url()}")
    print(f"‚öôÔ∏è SQL = {sql}")

    df = await ds.query_dataset_private(
        auth=auth,
        dataset_id=dataset_id,
        sql=sql,
        loop_until_end=True,
        debug_api=debug_api,
    )

    df["domo_instance"] = df["domain"].apply(lambda x: x.replace(".domo.com", ""))

    if global_admin_username:
        df["domo_username"] = global_admin_username
    if global_admin_password:
        df["domo_password"] = global_admin_password

    if execution_env:
        df["env"] = execution_env or "manual"

    if df.empty:
        raise Exception("no companies retrieved")
        return False

    print(
        f"\n‚öôÔ∏è SUCCESS üéâ Retrieved company list \nThere are {len(df.index)} companies to update"
    )

    return df

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\integrations\DomoJupyter.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\integrations\DomoJupyter.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/integrations/DomoJupyter.ipynb.

# %% auto 0
__all__ = ['GetJupyter_ErrorRetrievingAccount', 'GetJupyter_ErrorRetrievingAccountProperty', 'get_jupyter_account',
           'NoConfigCompanyError', 'GetInstanceConfig', 'InvalidAccountTypeError', 'DomoJupyterAccount_InstanceAuth',
           'is_v2', 'process_row', 'GetDomains_Query_AuthMatch_Error', 'InvalidAccountNameError',
           'GenerateAuth_InvalidDomoInstanceList', 'GenerateAuth_CredentialsNotProvided']

# %% ../../nbs/integrations/DomoJupyter.ipynb 2
import pandas as pd
from dataclasses import dataclass, field
from typing import Optional, Tuple, List
from enum import Enum


import re
import time
import json


from nbdev.showdoc import patch_to

import domolibrary.client.DomoAuth as dmda
import domolibrary.client.Logger as lc
import domolibrary.classes.DomoDataset as dmds
import domolibrary.utils.chunk_execution as ce

# %% ../../nbs/integrations/DomoJupyter.ipynb 5
class GetJupyter_ErrorRetrievingAccount(Exception):
    def __init__(self, account_name):
        self.message = f"failure to retrieve DomoDomoJupyter Account {account_name}"
        super().__init__(self.message)


class GetJupyter_ErrorRetrievingAccountProperty(Exception):
    def __init__(self, account_name, property_name):
        self.message = f"failure to retrieve {property_name} DomoDomoJupyter Account {account_name}"
        super().__init__(self.message)


def get_jupyter_account(
    account_name: str,  # name of account as it appears in the
    domojupyter_fn: callable,
    maximum_retry: int = 10,
) -> Tuple[
    List, dict
]:  # returns account properties list and a dictionary of the properties.
    """import a domojupyter account, will loop until success"""
    account_properties = None

    retry_attempt = 0
    while not account_properties and retry_attempt <= maximum_retry:
        try:
            account_properties = domojupyter_fn.get_account_property_keys(account_name)
            retry_attempt += 1

        except Exception as e:
            print(f"Error:  retry attempt {retry_attempt} - {account_name}: {e}")
            time.sleep(2)

    if not account_properties:
        raise GetJupyter_ErrorRetrievingAccount(account_name=account_name)

    obj = {}

    retry_attempt = 0
    for index, prop in enumerate(account_properties):
        value = None

        while not value and retry_attempt <= maximum_retry:
            try:
                value = domojupyter_fn.get_account_property_value(
                    account_name, account_properties[index]
                )

            except Exception as e:
                print(f"trying again - {prop} - {e}")
                time.sleep(2)

        if not value:
            raise GetJupyter_ErrorRetrievingAccountProperty(
                account_name=account_name, property_name=prop
            )

        obj.update({prop: value})

    return account_properties, obj

# %% ../../nbs/integrations/DomoJupyter.ipynb 6
class NoConfigCompanyError(Exception):
    def __init__(self, sql, domo_instance):
        message = f'SQL "{sql}" returned no results in {domo_instance}'
        self.message = message
        super().__init__(self.message)


class GetInstanceConfig:
    config: pd.DataFrame = None
    logger: lc.Logger = None

    def __init__(self, logger: Optional[lc.Logger] = None):
        self.logger = logger or lc.Logger(app_name="GetInstanceConfig")

    async def _retrieve_company_ds(
        self,
        config_auth: dmda.DomoAuth,
        dataset_id: str,
        sql: str,
        debug_prn: bool = False,
        debug_api: bool = False,
        debug_log: bool = False,
        debug_num_stacks_to_drop: int = 2,
    ) -> List[dict]:  # list of config query
        """wrapper for `DomoDataset.query_dataset_private` retrieves company configuration dataset and stores it as config"""

        ds = await dmds.DomoDataset.get_from_id(
            auth=config_auth,
            dataset_id=dataset_id,
            debug_api=debug_api,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            parent_class=self.__class__.__name__,
        )

        message = (
            f"‚öôÔ∏è START - Retrieving company list \n{ds.display_url()} using \n{sql}"
        )

        if debug_prn:
            print(message)

        self.logger.log_info(message, debug_log=debug_log)

        config_df = await ds.query_dataset_private(
            auth=config_auth,
            dataset_id=dataset_id,
            sql=sql,
            debug_api=debug_api,
            loop_until_end=True,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            parent_class=self.__class__.__name__,
            is_return_dataframe=False,
        )
        if len(config_df) == 0:
            raise NoConfigCompanyError(sql, domo_instance=config_auth.domo_instance)

        self.config = config_df

        message = f"\n‚öôÔ∏è SUCCESS üéâ Retrieved company list \nThere are {len(config_df)} companies to update"

        if debug_prn:
            print(message)
        self.logger.log_info(message, debug_log=debug_log)

        return config_df

# %% ../../nbs/integrations/DomoJupyter.ipynb 9
class InvalidAccountTypeError(Exception):
    """raised when account type is not expected type"""

    def __init__(self, account_name, account_type):

        self.message = f"account: {account_name} is not {account_type}"
        super().__init__(self.message)


@dataclass
class DomoJupyterAccount_InstanceAuth:
    """class for interacting with DomoJupyterAccount objects and generating a DomoAuth object"""

    account_name: str

    domo_username: str = None

    display_name: str = field(repr=False, default=None)

    domo_instance: str = field(repr=False, default=None)
    domo_instance_ls: list = field(repr=False, default=None)

    raw_cred: dict = field(repr=False, default=None)
    domo_password: str = field(repr=False, default=None)
    domo_access_token: str = field(repr=False, default=None)

    auth_ls: list = field(repr=False, default=None)

    account_name_mask = "^dj_.*_acc"

    def __post_init__(self):
        if not self.display_name and self.domo_username:
            self._set_display_name()

    def _set_display_name(self):
        clean_text = re.sub("@.*$", "", self.domo_username)
        self.display_name = clean_text

    @staticmethod
    def _test_regex_mask(
        test_string: str,  # the string to test
        regex_mask: str,  # the regex expression to test
    ) -> bool:  # boolean of the re match
        """tests if a string matches the regex pattern"""

        return bool(re.match(regex_mask, test_string))

    @staticmethod
    def _clean_account_admin_accounts(account_name):

        clean_str = re.sub("^dj_", "", account_name)
        clean_str = re.sub("_acc$", "", clean_str)

        return clean_str

# %% ../../nbs/integrations/DomoJupyter.ipynb 11
async def is_v2(instance_auth: dmda.DomoFullAuth):
    """wrapper for the domo boostrap.is_group_ownership_beta function to return a binary for if the instance has the group ownership beta enabled"""

    import domolibrary.classes.DomoBootstrap as dmbs

    domo_bootstrap = dmbs.DomoBootstrap(auth=instance_auth)
    is_v2 = await domo_bootstrap.is_feature_accountsv2_enabled()
    return 1 if is_v2 else 0


async def process_row(
    instance: dict,
    domo_instance,
    instance_creds: DomoJupyterAccount_InstanceAuth,
    config_enum=None,
    debug_api: bool = False,
    debug_prn: bool = False,
    logger=None,
):
    # convert DomoJupyterAccount_InstanceAuth obj to
    if isinstance(instance_creds, DomoJupyterAccount_InstanceAuth):
        instance_creds = instance_creds.generate_auth(domo_instance=domo_instance)

    instance.update({"instance_auth": instance_creds})

    try:
        await instance_creds.get_auth_token(debug_api=debug_api)
        instance.update({"is_valid": 1})

        if isinstance(instance_creds, dmda.DomoFullAuth):
            instance.update({"is_v2": await is_v2(instance_auth=instance_creds)})

    except (
        dmda.InvalidCredentialsError,
        dmda.AccountLockedError,
        dmda.InvalidInstanceError,
        dmda.NoAccessTokenReturned,
    ) as e:
        if debug_prn:
            print(e)
        logger.log_error(str(e))
        instance.update({"is_valid": 0})

    config_creds = None
    if config_enum and instance.get("config_exception_pw") == 0:
        config_creds = config_enum["config_1"].value

    elif config_enum and instance.get("config_exception_pw") == 1:
        config_creds = config_enum["config_0"].value

    if isinstance(config_creds, DomoJupyterAccount_InstanceAuth):
        config_creds = config_creds.generate_auth(domo_instance=domo_instance)

    instance.update({"config_auth": config_creds})

    return instance

# %% ../../nbs/integrations/DomoJupyter.ipynb 14
class GetDomains_Query_AuthMatch_Error(Exception):
    """raise if SQL query fails to return column named 'auth_match_col'"""

    def __init__(self, sql: str = None, domo_instance: str = None, message: str = None):
        self.message = (
            message
            or f"Query failed to return a column 'auth_match_col' sql = {sql} in {domo_instance}"
        )
        super().__init__(self.message)


@patch_to(GetInstanceConfig, cls_method=True)
async def get_domains_with_instance_auth(
    cls: GetInstanceConfig,
    default_auth: dmda.DomoAuth,  # default auth to use with each row
    auth_enum: Enum,  # Enum where enum_name should match to `auth_match_col` from config_sql query and enum_value is the appropriate DomoAuth or DomoJupyterAccount object
    config_auth: dmda.DomoAuth = None,  # which instance to retrieve configuration data from
    config_dataset_id: str = None,  # dataset_id to run config_sql query against
    config_sql: str = "select domain as domo_instance,concat(config_useprod, '-', project) as auth_match_col from table",
    debug_api: bool = False,
    debug_log: bool = False,
    debug_prn: bool = False,
    logger: lc.Logger = None,  # pass in Logger class
) -> (
    pd.DataFrame
):  # returns a dataframe with domo_instance, instance_auth, and binary column is_valid
    """uses a sql query to retrieve a list of domo_instances and map authentication object to each instance"""

    if not logger:
        logger = lc.Logger(app_name="get_domains_with_instance_auth")

    gic = cls(logger=logger)

    config_ls = await gic._retrieve_company_ds(
        config_auth=config_auth,
        dataset_id=config_dataset_id,
        sql=config_sql,
        debug_prn=debug_prn,
        debug_log=debug_log,
        debug_api=debug_api,
    )

    if "auth_match_col" not in config_ls[0]:
        message = f"Query failed to return a column 'auth_match_col' sql = {config_sql} in {config_auth.domo_instance}"
        raise GetDomains_Query_AuthMatch_Error(message)

    config_ls = await ce.gather_with_concurrency(
        *[
            process_row(
                instance=instance,
                domo_instance=instance["domo_instance"],
                instance_creds=(
                    auth_enum[instance["auth_match_col"]].value
                    if instance["auth_match_col"] in auth_enum._member_names_
                    else default_auth
                ),
                config_enum=(
                    auth_enum if "config_1" in auth_enum._member_names_ else None
                ),
                debug_api=debug_api,
                debug_prn=debug_prn,
                logger=logger,
            )
            for instance in config_ls
        ],
        n=10,
    )

    return pd.DataFrame(config_ls)

# %% ../../nbs/integrations/DomoJupyter.ipynb 17
class InvalidAccountNameError(Exception):
    """raised when account name does not follow format string"""

    def __init__(self, account_name=None, regex_pattern=None):
        account_str = f'"{account_name}" '
        regex_str = f'"{regex_pattern}"'

        message = f"string {account_str if account_name else ''}does not match regex pattern {regex_str or ''}"
        self.message = message

        super().__init__(self.message)


@patch_to(DomoJupyterAccount_InstanceAuth, cls_method=True)
def get_domo_instance_auth_account(
    cls: DomoJupyterAccount_InstanceAuth,
    account_name: str,  # domojupyter account to retrieve
    # Domo's domojupyter module, pass in b/c can only be retrieved inside Domo jupyter notebook environment
    domojupyter_fn: callable,
    # set the domo_instance or retrieve from the domojupyter_account credential store
    domo_instance=None,
):
    """
    retrieves Abstract Credential Store from DomoJupyter environment.
    expects credentials property to contain DOMO_USERNAME, DOMO_PASSWORD, or DOMO_ACCESS_TOKEN, and (optional) DOMO_INSTANCE
    """

    if not cls._test_regex_mask(account_name, cls.account_name_mask):
        raise InvalidAccountNameError(
            account_name=account_name, regex_pattern=cls.account_name_mask
        )

    account_properties, dj_account = get_jupyter_account(
        account_name, domojupyter_fn=domojupyter_fn
    )

    if account_properties != ["credentials"]:
        raise InvalidAccountTypeError(
            account_name=account_name, account_type="abstract_credential_store"
        )

    creds = json.loads(dj_account.get("credentials"))

    return cls(
        account_name=account_name,
        raw_cred=creds,
        domo_username=creds.get("DOMO_USERNAME"),
        domo_password=creds.get("DOMO_PASSWORD"),
        domo_access_token=creds.get("DOMO_ACCESS_TOKEN"),
        domo_instance=domo_instance or creds.get("DOMO_INSTANCE"),
    )

# %% ../../nbs/integrations/DomoJupyter.ipynb 19
class GenerateAuth_InvalidDomoInstanceList(Exception):
    def __init__(self):
        message = "provide a list of domo_instances"
        super().__init__(message)


class GenerateAuth_CredentialsNotProvided(Exception):
    def __init__(self):
        message = "object does not have a valid combination of credentials (access_token or username and password)"
        super().__init__(message)


@patch_to(DomoJupyterAccount_InstanceAuth)
def generate_auth(self, domo_instance):
    if self.domo_access_token:
        auth = dmda.DomoTokenAuth(
            domo_instance=domo_instance, domo_access_token=self.domo_access_token
        )

    elif self.domo_username and self.domo_password:

        auth = dmda.DomoFullAuth(
            domo_instance=domo_instance,
            domo_username=self.domo_username,
            domo_password=self.domo_password,
        )

    else:
        raise GenerateAuth_CredentialsNotProvided()

    return auth


@patch_to(DomoJupyterAccount_InstanceAuth)
def generate_auth_ls(
    self: DomoJupyterAccount_InstanceAuth,
    domo_instance_ls: list[str] = None,  # list of domo_instances
) -> list[dmda.DomoAuth]:  # list of domo auth objects
    """for every domo_instance in domo_instance_ls generates an DomoAuth object"""

    # reset internal lists
    self.domo_instance = None

    self.domo_instance_ls = list(set(domo_instance_ls or self.domo_instance_ls))

    if not self.domo_instance_ls:
        raise GenerateAuth_InvalidDomoInstanceList()

    self.auth_ls = []
    for domo_instance in self.domo_instance_ls:
        auth = self.generate_auth(domo_instance)

        self.auth_ls.append(auth)

    return self.auth_ls

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\integrations\MonitDataset.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\integrations\MonitDataset.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/integrations/MonitDataset.ipynb.

# %% auto 0
__all__ = []

# %% ../../nbs/integrations/MonitDataset.ipynb 2
from dataclasses import dataclass, field
import datetime as dt
import decimal
import domolibrary.classes.DomoDataset as dcds
import domolibrary.classes.DomoStream as dcdstr


@dataclass
class MonitDataset_Record:
    id: str = None
    stream_account_id: int = None
    stream_account_userid: int = None
    stream_account_display_name: str = None
    nb_partitions: int = 0
    name: str = None
    data_provider_type: str = None
    display_type: str = None
    stream_id: str = None
    stream_config_tables: str = None
    stream_config_query: str = None
    instance: str = None
    owner: str = None
    row_count: int = None
    url: str = None
    report_date: dt.datetime = dt.datetime.now()
    tags: list = field(default=None)
    is_certified: int = 0
    certification_name: str = None
    certification_status: str = None
    connector_version: decimal.Decimal(2) = None
    update_method: str = None
    connector_id: str = None


@dataclass
class MonitDataset_Data:
    ds: dcds.DomoDataset = None
    stream_ds: dcdstr.DomoStream = None
    partition_ls: list = None

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\integrations\RoleHierarchy.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\integrations\RoleHierarchy.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/integrations/RoleHierarchy.ipynb.

# %% auto 0
__all__ = ['extract_role_hierarchy', 'get_roles_w_hierarchy', 'calc_role']

# %% ../../nbs/integrations/RoleHierarchy.ipynb 2
import domolibrary.classes.DomoRole as dmr

# %% ../../nbs/integrations/RoleHierarchy.ipynb 4
def extract_role_hierarchy(
    role: dmr.DomoRole, hierarchy_delimiter, debug_prn: bool = False
) -> dmr.DomoRole:  # augments the domo role with a hierarchy INT attribute

    description_arr = role.description.split(hierarchy_delimiter)

    if len(description_arr) != 1:
        hierarchy = int(description_arr[1])

    elif role.is_system_role:
        hierarchy = (5 - role.id) * 2 + 1

    else:
        hierarchy = 0

    role.hierarchy = hierarchy

    if debug_prn:
        print(
            {
                "description_arr": description_arr,
                "role_id": role.id,
                "hierarchy": hierarchy,
            }
        )

    return role

# %% ../../nbs/integrations/RoleHierarchy.ipynb 5
async def get_roles_w_hierarchy(
    auth,
    hierarchy_delimiter=" - h",  # post fix to delimit hierarchy number.  assumes scale of 1:10, system accounts will be included.
    debug_prn: bool = False,
    debug_api: bool = False,
):
    """gets instance roles and adds an attribute hierarchy"""

    domo_roles = await dmr.DomoRoles.get_roles(auth=auth, debug_api=debug_api)
    return [
        extract_role_hierarchy(
            role=role, hierarchy_delimiter=hierarchy_delimiter, debug_prn=debug_prn
        )
        for role in domo_roles
    ]

# %% ../../nbs/integrations/RoleHierarchy.ipynb 7
async def calc_role(
    current_role_id,
    new_role_name,
    auth,
    hierarchy_delimiter=" - h",
    is_alter_system_roles: bool = False,  # by default calc role will not apply to system roles and will always update to a system role
    debug_prn: bool = False,
):
    """compares current role to new role hierarchy and returns the higher one.  will not adjust system roles"""

    instance_roles = await get_roles_w_hierarchy(
        auth=auth, hierarchy_delimiter=hierarchy_delimiter
    )

    current_role = next((role for role in instance_roles if role.id == current_role_id))

    if current_role.is_system_role and not is_alter_system_roles:
        print(f"{current_role.name} is a system role -- no changes")
        return current_role

    expected_role = next(
        (role for role in instance_roles if role.name == new_role_name), None
    )

    if not expected_role:
        raise Exception(f"{new_role_name} not found in {auth.domo_instance}")

    if current_role.hierarchy >= expected_role.hierarchy:
        if debug_prn:
            print(
                f"do nothing:  {current_role.name} - {current_role.hierarchy} exceeds or equals {expected_role.name} - {expected_role.hierarchy}"
            )
        return current_role

    if debug_prn:
        print(
            f"upgrade role: {current_role.name} - {current_role.hierarchy} to a {expected_role.name} - {expected_role.hierarchy}"
        )
    return expected_role

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\access_token.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\access_token.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/auth_accesstoken.ipynb.

# %% auto 0
__all__ = ['get_access_tokens', 'AccessToken_GenerationError', 'generate_access_token', 'AccessToken_RevokeError',
           'revoke_access_token']

# %% ../../nbs/routes/auth_accesstoken.ipynb 2
import datetime as dt
import time

from dataclasses import dataclass, field
import httpx

import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.get_data as gd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

# import domolibrary.client.Logger as lg

# %% ../../nbs/routes/auth_accesstoken.ipynb 5
@gd.route_function
async def get_access_tokens(
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class=None,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/accesstokens"

    res = await gd.get_data(
        url=url,
        method="GET",
        auth=auth,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    [
        token.update({"expires": dt.datetime.utcfromtimestamp(token["expires"] / 1000)})
        for token in res.response
    ]

    return res

# %% ../../nbs/routes/auth_accesstoken.ipynb 7
def generate_expiration_unixtimestamp(
    duration_in_days: int = 90, debug_prn: bool = False
):

    today = dt.datetime.today()
    expiration_date = today + dt.timedelta(days=duration_in_days)

    if debug_prn:
        print(f"expiration_date is {duration_in_days} from today {expiration_date}")

    return int(time.mktime(expiration_date.timetuple()) * 1000)

# %% ../../nbs/routes/auth_accesstoken.ipynb 9
class AccessToken_GenerationError(de.DomoError):
    def __init__(
        self,
        user_id,
        domo_instance,
        parent_class,
        function_name,
        message=None,
    ):
        super().__init__(
            domo_instance=domo_instance,
            message=message or f"failure to generate access_token for {user_id}",
            function_name=function_name,
            parent_class=parent_class,
        )


@gd.route_function
async def generate_access_token(
    auth: dmda.DomoAuth,
    token_name: str,
    user_id,
    duration_in_days: 90,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class=None,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/accesstokens"

    expiration_timestamp = generate_expiration_unixtimestamp(
        duration_in_days=duration_in_days
    )

    body = {"name": token_name, "ownerId": user_id, "expires": expiration_timestamp}

    res = await gd.get_data(
        url=url,
        method="POST",
        body=body,
        auth=auth,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if res.status == 400:
        raise AccessToken_GenerationError(
            user_id=user_id,
            message=f"unable to generate access_token for {user_id} || did you pass a valid user_id",
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    if not res.is_success or not res.response["token"]:
        raise AccessToken_GenerationError(
            user_id=user_id,
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/auth_accesstoken.ipynb 11
class AccessToken_RevokeError(de.DomoError):
    def __init__(
        self,
        access_token_id,
        domo_instance,
        parent_class,
        function_name,
    ):
        super().__init__(
            domo_instance=domo_instance,
            message=f"failure to revoke token {access_token_id}",
            function_name=function_name,
            parent_class=parent_class,
        )


@gd.route_function
async def revoke_access_token(
    auth: dmda.DomoAuth,
    access_token_id: int,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class=None,
    session: httpx.AsyncClient = None,
):
    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/accesstokens/{access_token_id}"

    res = await gd.get_data(
        url=url,
        method="DELETE",
        auth=auth,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
    )

    if not res.is_success:
        raise AccessToken_RevokeError(
            access_token_id=access_token_id,
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_Name,
        )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\account.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\account.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/account.ipynb.

# %% auto 0
__all__ = ['CreateAccount_Error', 'UpdateAccount_Error', 'ShareAccount_Error', 'ShareAccount_Error_AlreadyShared', 'get_accounts',
           'GetAccount_NoMatch', 'GetAccount_NoConfigRetrieved', 'DeleteAccount_Error', 'get_account_from_id',
           'get_account_config', 'get_user_access', 'update_account_config', 'update_account_name',
           'generate_create_body', 'create_account', 'delete_account', 'ShareAccount', 'ShareAccount_V1_AccessLevel',
           'ShareAccount_V2_AccessLevel', 'generate_share_account_payload_v1', 'generate_share_account_payload_v2',
           'share_account_v2', 'get_account_accesslist', 'share_account_v1']

# %% ../../nbs/routes/account.ipynb 3
from typing import Union
from enum import Enum
import httpx
import asyncio

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

# %% ../../nbs/routes/account.ipynb 6
class CreateAccount_Error(de.DomoError):
    def __init__(
        self,
        status,
        response,
        account_id,
        domo_instance,
        info=None,
        function_name: str = None,
        parent_class: str = None,
    ):
        message = f"unable to create account {account_id} - {response} { (' - ' + info) or ''}"

        super().__init__(
            status=status,
            message=message,
            domo_instance=domo_instance,
            parent_class=parent_class,
            function_name=function_name,
        )


class UpdateAccount_Error(de.DomoError):
    def __init__(
        self,
        status,
        response,
        account_id,
        domo_instance,
        info=None,
        function_name: str = None,
        parent_class: str = None,
    ):
        message = f"unable to update account {account_id} - {response} { (' - ' + info) or ''}"

        super().__init__(
            status=status,
            message=message,
            domo_instance=domo_instance,
            parent_class=parent_class,
            function_name=function_name,
        )


class ShareAccount_Error(de.DomoError):
    def __init__(
        self,
        account_id,
        response,
        domo_instance,
        function_name,
        parent_class=None,
        status=None,
    ):
        super().__init__(
            status=status,
            entity_id=account_id,
            message=response,
            domo_instance=domo_instance,
            function_name=function_name,
            parent_class=parent_class,
        )


class ShareAccount_Error_AlreadyShared(de.DomoError):
    def __init__(
        self,
        account_id,
        response,
        domo_instance,
        function_name,
        parent_class=None,
        status=None,
    ):
        super().__init__(
            status=status,
            entity_id=account_id,
            message=response,
            domo_instance=domo_instance,
            function_name=function_name,
            parent_class=parent_class,
        )

# %% ../../nbs/routes/account.ipynb 8
@gd.route_function
async def get_accounts(
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:
    """retrieve a list of all the accounts the user has read access to.  Note users with "Manage all accounts" will retrieve all account objects"""

    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/accounts"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        session=session,
    )
    return res

# %% ../../nbs/routes/account.ipynb 12
class GetAccount_NoMatch(de.DomoError):
    def __init__(
        self,
        domo_instance,
        account_id=None,
        status=None,
        function_name=None,
        parent_class=None,
        message=None,
    ):
        message = (
            message
            or f"account_id {account_id} not found has it been shared with the user?"
        )

        super().__init__(
            message=message,
            status=status,
            function_name=function_name,
            parent_class=parent_class,
            domo_instance=domo_instance,
        )


class GetAccount_NoConfigRetrieved(de.DomoError):
    def __init__(
        self,
        account_id,
        domo_instance,
        status=None,
        function_name=None,
        parent_class=None,
    ):
        message = f"account_id {account_id} did not return a config.  update `DomoAccount_Config` if it uses OAuth, otherwise this is probably an error"

        super().__init__(
            message=message,
            status=status,
            function_name=function_name,
            parent_class=parent_class,
            domo_instance=domo_instance,
        )


class DeleteAccount_Error(de.DomoError):
    def __init__(
        self,
        entity_id,
        domo_instance,
        status,
        message,
        function_name=None,
        parent_class=None,
    ):
        super().__init__(
            entity_id=entity_id,
            domo_instance=domo_instance,
            status=status,
            message=message,
            function_name=function_name,
            parent_class=parent_class,
        )

# %% ../../nbs/routes/account.ipynb 13
@gd.route_function
async def get_account_from_id(
    auth: dmda.DomoAuth,
    account_id: int,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:
    """retrieves metadata about an account"""

    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/accounts/{account_id}?unmask=true"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        timeout=20,  # occasionally this API has a long response time
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=None,
    )

    if not res.is_success and (
        res.response == "Forbidden" or res.response == "Not Found"
    ):
        raise GetAccount_NoMatch(
            account_id=account_id,
            domo_instance=auth.domo_instance,
            status=res.status,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/account.ipynb 17
@gd.route_function
async def get_account_config(
    auth: dmda.DomoAuth,
    account_id: int,
    data_provider_type: str,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
    session: Union[httpx.AsyncClient, httpx.AsyncClient, None] = None,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/providers/{data_provider_type}/account/{account_id}?unmask=true"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    if not res.is_success:
        raise GetAccount_NoMatch(
            account_id=account_id,
            domo_instance=auth.domo_instance,
            status=res.status,
            message=f"unable to retrieve config for {account_id} -- is the account shared with this user?",
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    res.response.update(
        {
            "_search_metadata": {
                "account_id": account_id,
                "data_provider_type": data_provider_type,
            }
        }
    )

    return res

# %% ../../nbs/routes/account.ipynb 22
@gd.route_function
async def get_user_access(
    auth: dmda.DomoAuth,
    account_id: int,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
    session: Union[httpx.AsyncClient, httpx.AsyncClient, None] = None,
) -> rgd.ResponseGetData:
    res = await get_account_from_id(
        auth=auth,
        account_id=account_id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        session=session,
    )

    data_provider_type = res.response.get("dataProviderType")
    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/providers/{data_provider_type}/account/{account_id}?unmask=true"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    if not res.is_success:
        raise GetAccount_NoMatch(
            account_id=account_id,
            domo_instance=auth.domo_instance,
            status=res.status,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    res.response.update(
        {
            "_search_metadata": {
                "account_id": account_id,
                "data_provider_type": data_provider_type,
            }
        }
    )

    return res

# %% ../../nbs/routes/account.ipynb 24
@gd.route_function
async def update_account_config(
    auth: dmda.DomoAuth,
    account_id: int,
    config_body: dict,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:
    # get the data_provider_type, which is necessare for updating the config setting
    res = await get_account_from_id(
        auth=auth,
        account_id=account_id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        session=session,
    )
    data_provider_type = res.response.get("dataProviderType")
    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/providers/{data_provider_type}/account/{account_id}"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=config_body,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        session=session,
    )

    if res.status == 400 and res.response == "Bad Request":
        raise UpdateAccount_Error(
            status=res.status,
            response=res.response,
            account_id=account_id,
            info="updating config | use debug_api to check the URL - ",
            domo_instance=auth.domo_instance,
        )

    if res.status != 200:
        raise UpdateAccount_Error(
            status=res.status,
            response=res.response,
            account_id=account_id,
            info="updating account config",
            domo_instance=auth.domo_instance,
        )

    return res

# %% ../../nbs/routes/account.ipynb 27
@gd.route_function
async def update_account_name(
    auth: dmda.DomoAuth,
    account_id: int,
    account_name: str,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:
    url = (
        f"https://{auth.domo_instance}.domo.com/api/data/v1/accounts/{account_id}/name"
    )

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=account_name,
        content_type="text/plain",
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
    )

    if res.status != 200:
        raise UpdateAccount_Error(
            status=res.status,
            response=res.response,
            account_id=account_id,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            info="error updating account_name",
            domo_instance=auth.domo_instance,
        )

    return res

# %% ../../nbs/routes/account.ipynb 30
def generate_create_body(account_name, config):
    return {
        "displayName": account_name,
        "dataProviderType": config.data_provider_type,
        "name": config.data_provider_type,
        "configurations": config.to_json(),
    }


@gd.route_function
async def create_account(
    auth: dmda.DomoAuth,
    config_body: dict,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/accounts"

    if debug_api:
        print(url)

    attempt = 1
    res = None

    while attempt <= 3:
        res = await gd.get_data(
            auth=auth,
            url=url,
            method="POST",
            body=config_body,
            debug_api=debug_api,
            session=session,
            parent_class=parent_class,
            num_stacks_to_drop=debug_num_stacks_to_drop,
        )

        if res.is_success:
            return res

        attempt += 1
        await asyncio.sleep(3)

    if not res.is_success:
        raise CreateAccount_Error(
            status=res.status,
            account_id=config_body.get("displayName"),
            domo_instance=auth.domo_instance,
            info=res.response,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/account.ipynb 31
@gd.route_function
async def delete_account(
    auth: dmda.DomoAuth,
    account_id: str,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/accounts/{account_id}"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="DELETE",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise DeleteAccount_Error(
            entity_id=account_id,
            domo_instance=auth.domo_instance,
            status=res.status,
            message=res.response,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/account.ipynb 33
class ShareAccount:
    pass


class ShareAccount_V1_AccessLevel(ShareAccount, Enum):
    CAN_VIEW = "READ"
    CAN_EDIT = "WRITE"
    OWNER = "OWNER"


class ShareAccount_V2_AccessLevel(ShareAccount, Enum):
    CAN_VIEW = "CAN_VIEW"
    CAN_EDIT = "CAN_EDIT"
    CAN_SHARE = "CAN_SHARE"
    OWNER = "OWNER"


def generate_share_account_payload_v1(access_level: ShareAccount, user_id: int = None):
    return {"type": "USER", "id": int(user_id), "permissions": [access_level.value]}


def generate_share_account_payload_v2(
    access_level: ShareAccount, user_id: int = None, group_id: int = None
):
    if user_id:
        return {"type": "USER", "id": int(user_id), "accessLevel": access_level.value}

    if group_id:
        return {"type": "GROUP", "id": int(group_id), "accessLevel": access_level.value}

# %% ../../nbs/routes/account.ipynb 35
@gd.route_function
async def share_account_v2(
    auth: dmda.DomoAuth,
    account_id: str,
    share_payload: dict,
    debug_api: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
    session: httpx.AsyncClient = None,
):
    url = (
        f"https://{auth.domo_instance}.domo.com/api/data/v2/accounts/share/{account_id}"
    )

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=share_payload,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        debug_api=debug_api,
        session=session,
    )

    if res.status == 500 and res.response == "Internal Server Error":
        raise ShareAccount_Error_AlreadyShared(
            account_id=account_id,
            status=res.status,
            response=f'‚ÑπÔ∏è - {res.response + "| User may already have access to account."}',
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    if not res.status == 200:
        raise ShareAccount_Error(
            account_id=account_id,
            status=res.status,
            response=res.response,
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/account.ipynb 36
@gd.route_function
async def get_account_accesslist(
    auth: dmda.DomoAuth,
    account_id: str,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
):
    url = (
        f"https://{auth.domo_instance}.domo.com/api/data/v2/accounts/share/{account_id}"
    )

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        session=session,
    )

    if not res.status == 200:
        raise GetAccount_NoMatch(
            domo_instance=auth.domo_instance,
            status=res.status,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/account.ipynb 39
# v1 may have been deprecated.  used to be tied to group beta
@gd.route_function
async def share_account_v1(
    auth: dmda.DomoAuth,
    account_id: str,
    share_payload: dict,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
):
    """V1 API allows sharing with users ONLY, the original implementation does not support sharing with groups and has a more limited set of share rights (owner or read)"""
    url = (
        f"https://{auth.domo_instance}.domo.com/api/data/v1/accounts/{account_id}/share"
    )

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=share_payload,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        debug_api=debug_api,
        session=session,
    )

    if res.status == 500 and res.response == "Internal Server Error":
        raise ShareAccount_Error_AlreadyShared(
            account_id=account_id,
            status=res.status,
            response=f'‚ÑπÔ∏è - {res.response + "| User may already have access to or own the account OR may need to execute v2 share API."}',
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    if not res.status == 200:
        raise ShareAccount_Error(
            account_id=account_id,
            status=res.status,
            response=res.response,
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\activity_log.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\activity_log.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/activity_log.ipynb.

# %% auto 0
__all__ = ['get_activity_log_object_types', 'search_activity_log']

# %% ../../nbs/routes/activity_log.ipynb 3
import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda

# %% ../../nbs/routes/activity_log.ipynb 5
@gd.route_function
async def get_activity_log_object_types(
    auth: dmda.DomoAuth,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:
    """retrieves a list of valid objectTypes that can be used to search the activity_log API"""

    url = f"https://{auth.domo_instance}.domo.com/api/audit/v1/user-audits/objectTypes"

    return await gd.get_data(
        url=url,
        method="GET",
        auth=auth,
        parent_class=parent_class,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

# %% ../../nbs/routes/activity_log.ipynb 8
@gd.route_function
async def search_activity_log(
    auth: dmda.DomoAuth,
    start_time: int,  # epoch time in milliseconds
    end_time: int,  # epoch time in milliseconds
    maximum: int,
    object_type: str = None,
    debug_api: bool = False,
    debug_loop: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:
    """loops over activity log api to retrieve audit logs"""

    is_close_session = False

    if not session:
        session = httpx.AsyncClient()
        is_close_session = True

    url = f"https://{auth.domo_instance}.domo.com/api/audit/v1/user-audits"

    if object_type and object_type != "ACTIVITY_LOG":
        url = f"{url}/objectTypes/{object_type}"

    fixed_params = {"end": end_time, "start": start_time}

    offset_params = {
        "offset": "offset",
        "limit": "limit",
    }

    def arr_fn(res) -> list[dict]:
        return res.response

    res = await gd.looper(
        auth=auth,
        method="GET",
        url=url,
        arr_fn=arr_fn,
        fixed_params=fixed_params,
        offset_params=offset_params,
        session=session,
        maximum=maximum,
        debug_loop=debug_loop,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if is_close_session:
        await session.aclose()

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\application.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\application.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/application.ipynb.

# %% auto 0
__all__ = ['ApplicationError_NoneRetrieved', 'get_applications', 'get_application_by_id', 'ApplicationError_NoJobRetrieved',
           'get_application_jobs', 'get_application_job_by_id', 'generate_remote_domostats',
           'generate_body_watchdog_generic', 'CRUD_ApplicationJob_Error', 'create_application_job',
           'update_application_job', 'update_application_job_trigger', 'execute_application_job']

# %% ../../nbs/routes/application.ipynb 2
from typing import Union
import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

from pprint import pprint

# %% ../../nbs/routes/application.ipynb 4
class ApplicationError_NoneRetrieved(de.DomoError):
    def __init__(
        self,
        domo_instance,
        application_id=None,
        application_name=None,
        parent_class=None,
        function_name=None,
        job_id=None,
    ):
        message = "No applications retrieve"

        if application_id:
            message = f"unable to retrieve application - {application_id}"

        if application_name:
            message = f"unable to retrieve application - {application_name}"

        if application_id and job_id:
            message = (
                f"unable to retrieve {job_id} job from application - {application_name}"
            )

        super().__init__(
            message=message,
            parent_class=parent_class,
            function_name=function_name,
            domo_instance=domo_instance,
        )


@gd.route_function
async def get_applications(
    auth: dmda.DomoAuth,
    session: Union[httpx.AsyncClient, httpx.AsyncClient, None] = None,
    debug_api: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/executor/v1/applications/"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise ApplicationError_NoneRetrieved(
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )
    return res

# %% ../../nbs/routes/application.ipynb 7
@gd.route_function
async def get_application_by_id(
    auth: dmda.DomoAuth,
    application_id: str,
    session: Union[httpx.AsyncClient, httpx.AsyncClient, None] = None,
    debug_api: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/executor/v1/applications/{application_id}"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise ApplicationError_NoneRetrieved(
            domo_instance=auth.domo_instance,
            application_id=application_id,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/application.ipynb 10
class ApplicationError_NoJobRetrieved(de.DomoError):
    def __init__(
        self,
        domo_instance,
        application_id=None,
        parent_class=None,
        function_name=None,
    ):
        message = f"no jobs retrieved from application - {application_id}"

        super().__init__(
            message=message,
            parent_class=parent_class,
            function_name=function_name,
            domo_instance=domo_instance,
        )


gd.route_function


async def get_application_jobs(
    auth: dmda.DomoFullAuth,
    application_id: str,
    parent_class: str = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: Union[httpx.AsyncClient, httpx.AsyncClient, None] = None,
) -> rgd.ResponseGetData:

    offset_params = {"offset": "offset", "limit": "limit"}

    url = f"https://{auth.domo_instance}.domo.com/api/executor/v2/applications/{application_id}/jobs"

    def arr_fn(res) -> list[dict]:
        return res.response.get("jobs")

    res = await gd.looper(
        auth=auth,
        method="GET",
        url=url,
        arr_fn=arr_fn,
        loop_until_end=True,
        offset_params=offset_params,
        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise ApplicationError_NoJobRetrieved(
            domo_instance=auth.domo_instance,
            application_id=application_id,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/application.ipynb 12
@gd.route_function
async def get_application_job_by_id(
    auth: dmda.DomoFullAuth,
    application_id: str,
    job_id: str,
    parent_class: str = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: Union[httpx.AsyncClient, httpx.AsyncClient, None] = None,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/executor/v1/applications/{application_id}/jobs/{job_id}"

    res = await gd.get_data(
        auth=auth,
        method="GET",
        url=url,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise ApplicationError_NoneRetrieved(
            domo_instance=auth.domo_instance,
            application_id=application_id,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
            job_id=job_id,
        )

    return res

# %% ../../nbs/routes/application.ipynb 15
def generate_remote_domostats(
    target_instance: str,
    report_dict: dict,
    output_dataset_id: str,
    account_id: str,
    schedule_ls: list,
    execution_timeout: int = 1440,
    debug_api: bool = False,
):

    instance_url = f"{target_instance}.domo.com"

    body = {
        "jobName": instance_url,
        "jobDescription": f"Get Remote stat from {instance_url}",
        "executionTimeout": execution_timeout,
        "executionPayload": {
            "remoteInstance": instance_url,
            "policies": report_dict,
            "metricsDatasetId": output_dataset_id,
        },
        "accounts": [account_id],
        "executionClass": "com.domo.executor.subscriberstats.SubscriberStatsExecutor",
        "resources": {"requests": {"memory": "256M"}, "limits": {"memory": "256M"}},
        "triggers": schedule_ls,
    }

    if debug_api:
        pprint(body)

    return body


def generate_body_watchdog_generic(
    job_name: str,
    notify_user_ids_ls: list,
    notify_group_ids_ls: list,
    notify_emails_ls: list,
    log_dataset_id: str,
    schedule_ls: list,
    watchdog_parameter_body: dict,
    execution_timeout=1440,
    debug_api: bool = False,
):

    body = {
        "jobName": job_name,
        "jobDescription": f"Watchdog for {job_name}",
        "executionTimeout": execution_timeout,
        "accounts": [],
        "executionPayload": {
            "notifyUserIds": notify_user_ids_ls or [],
            "notifyGroupIds": notify_group_ids_ls or [],
            "notifyEmailAddresses": notify_emails_ls or [],
            "watcherParameters": watchdog_parameter_body,
            "metricsDatasetId": log_dataset_id,
        },
        "resources": {"requests": {"memory": "256Mi"}, "limits": {"memory": "256Mi"}},
        "triggers": schedule_ls,
    }

    if debug_api:
        pprint(body)

    return body

# %% ../../nbs/routes/application.ipynb 16
class CRUD_ApplicationJob_Error(de.DomoError):
    def __init__(
        self, domo_instance, application_id, message, parent_class, function_name
    ):
        super().__init__(
            self,
            domo_instance=domo_instance,
            entity_id=application_id,
            parent_class=parent_class,
            function_name=function_name,
            message=message,
        )


# create the new RemoteDomostats job


@gd.route_function
async def create_application_job(
    auth: dmda.DomoFullAuth,
    body: dict,
    application_id: str,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    parent_class: str = None,
    session: Union[httpx.AsyncClient, httpx.AsyncClient, None] = None,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/executor/v1/applications/{application_id}/jobs"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="POST",
        body=body,
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise CRUD_ApplicationJob_Error(
            domo_instance=auth.domo_instance,
            application_id=application_id,
            message=res.response,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res


# update the job
@gd.route_function
async def update_application_job(
    auth: dmda.DomoFullAuth,
    body: dict,
    job_id: str,
    application_id: str,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
    session: Union[httpx.AsyncClient, httpx.AsyncClient, None] = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/executor/v1/applications/{application_id}/jobs/{job_id}"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        debug_api=debug_api,
        session=session,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise CRUD_ApplicationJob_Error(
            domo_instance=auth.domo_instance,
            application_id=application_id,
            message=res.response,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res


@gd.route_function
async def update_application_job_trigger(
    auth: dmda.DomoFullAuth,
    body: dict,
    job_id: str,
    trigger_id: str,
    application_id: str,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
    session: Union[httpx.AsyncClient, httpx.AsyncClient, None] = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/executor/v1/applications/{application_id}/jobs/{job_id}/triggers/{trigger_id}"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise CRUD_ApplicationJob_Error(
            domo_instance=auth.domo_instance,
            application_id=application_id,
            message=res.response,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/application.ipynb 17
@gd.route_function
async def execute_application_job(
    auth: dmda.DomoAuth,
    application_id,
    job_id,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
):
    url = f"https://{auth.domo_instance}.domo.com/api/executor/v1/applications/{application_id}/jobs/{job_id}/executions"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="POST",
        body={},
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\auth.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\auth.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/auth.ipynb.

# %% auto 0
__all__ = ['InvalidCredentialsError', 'AccountLockedError', 'InvalidAuthTypeError', 'InvalidInstanceError',
           'NoAccessTokenReturned', 'get_full_auth', 'get_developer_auth', 'who_am_i']

# %% ../../nbs/routes/auth.ipynb 2
from typing import Optional
from urllib.parse import urlparse

import httpx

import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.Logger as lg
import domolibrary.client.DomoError as de

# %% ../../nbs/routes/auth.ipynb 5
class InvalidCredentialsError(de.DomoError):
    """return invalid credentials sent to API"""

    def __init__(
        self,
        function_name: Optional[str] = None,
        parent_class: str = None,
        status: Optional[int] = None,  # API request status
        message="invalid credentials",
        domo_instance: Optional[str] = None,
    ):
        super().__init__(
            status=status,
            message=message,
            domo_instance=domo_instance,
            function_name=function_name,
            parent_class=parent_class,
        )


class AccountLockedError(de.DomoError):
    """return invalid credentials sent to API"""

    def __init__(
        self,
        function_name: Optional[str] = None,
        status: Optional[int] = None,  # API request status
        message="invalid credentials",
        domo_instance: Optional[str] = None,
        parent_class: str = None,
    ):
        super().__init__(
            status=status,
            message=message,
            domo_instance=domo_instance,
            function_name=function_name,
            parent_class=parent_class,
        )


class InvalidAuthTypeError(de.DomoError):
    """return invalid Auth type sent to API"""

    def __init__(
        self,
        required_auth_type: dict = None,
        required_auth_type_ls: list = None,
        function_name: Optional[str] = None,
        parent_class: str = None,
        domo_instance: Optional[str] = None,
    ):
        message = f"This API rquires {required_auth_type.__name__ if required_auth_type else ', '.join([auth_type.__name__ for auth_type in required_auth_type_ls])}"

        super().__init__(
            message=message,
            domo_instance=domo_instance,
            function_name=function_name,
            parent_class=parent_class,
        )


class InvalidInstanceError(de.DomoError):
    """return if invalid domo_instance sent to API"""

    def __init__(
        self,
        function_name: Optional[str] = None,
        parent_class: str = None,
        status: Optional[int] = None,
        message="invalid instance",
        domo_instance: Optional[str] = None,
    ):
        super().__init__(
            status=status,
            message=message,
            domo_instance=domo_instance,
            parent_class=parent_class,
            function_name=function_name,
        )


class NoAccessTokenReturned(de.DomoError):
    def __init__(
        self,
        function_name: Optional[str] = None,
        status: Optional[int] = None,
        message: str = "No AccessToken returned",
        domo_instance: Optional[str] = None,
        parent_class: str = None,
    ):
        super().__init__(
            status=status,
            message=message,
            domo_instance=domo_instance,
            function_name=function_name,
            parent_class=parent_class,
        )

# %% ../../nbs/routes/auth.ipynb 7
async def get_full_auth(
    domo_instance: str,  # domo_instance.domo.com
    domo_username: str,  # email address
    domo_password: str,
    session: Optional[httpx.AsyncClient] = None,
    debug_api: bool = False,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    """uses username and password authentication to retrieve a full_auth access token"""

    is_close_session = False

    if not session:
        is_close_session = True
        session = httpx.AsyncClient()

    url = f"https://{domo_instance}.domo.com/api/content/v2/authentication"

    tokenHeaders = {"Content-Type": "application/json"}

    body = {
        "method": "password",
        "emailAddress": domo_username,
        "password": domo_password,
    }

    if debug_api:
        print(body, url)

    res = await session.request(method="POST", url=url, headers=tokenHeaders, json=body)

    if is_close_session:
        await session.aclose()

    traceback_details = lg.get_traceback()

    res = rgd.ResponseGetData._from_httpx_response(
        res, traceback_details=traceback_details, parent_class=parent_class
    )

    if (
        res.is_success
        and isinstance(res.response, dict)
        and res.response.get("reason", None)
    ):
        if res.response.get("reason") == "INVALID_CREDENTIALS":
            res.is_success = False
            raise InvalidCredentialsError(
                function_name=res.traceback_details.function_name,
                parent_class=parent_class,
                status=res.status,
                message=res.response["reason"],
                domo_instance=domo_instance,
            )
        if (
            isinstance(res.response, dict)
            and res.response.get("reason") == "ACCOUNT_LOCKED"
        ):
            res.is_success = False
            raise AccountLockedError(
                function_name=res.traceback_details.function_name,
                parent_class=parent_class,
                status=res.status,
                message=str(res.response.get("reason")),
                domo_instance=domo_instance,
            )

        if res.response == {} or res.response == "":  # no access token
            res.is_success = False
            raise NoAccessTokenReturned(
                function_name=res.traceback_details.function_name,
                parent_class=parent_class,
                status=res.status,
                domo_instance=domo_instance,
            )

    if res.status == 403 and res.response == "Forbidden":
        res.is_success = False
        raise InvalidInstanceError(
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            status=res.status,
            message=res.response,
            domo_instance=domo_instance,
        )

    if not res.is_success or not (
        isinstance(res.response, dict) and res.response.get("sessionToken")
    ):
        raise InvalidCredentialsError(
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            status=res.status,
            message=res.response,
            domo_instance=domo_instance,
        )

    return res

# %% ../../nbs/routes/auth.ipynb 15
async def get_developer_auth(
    domo_client_id: str,
    domo_client_secret: str,
    session: Optional[httpx.AsyncClient] = None,
    debug_api: bool = False,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    """
    only use for authenticating against apis documented under developer.domo.com
    """
    is_close_session = False

    if not session:
        is_close_session = True
        session = httpx.AsyncClient(
            auth=httpx.BasicAuth(domo_client_id, domo_client_secret)
        )

    url = "https://api.domo.com/oauth/token?grant_type=client_credentials"

    if debug_api:
        print(url, domo_client_id, domo_client_secret)

    res = await session.request(method="GET", url=url)

    traceback_details = lg.get_traceback()

    if is_close_session:
        await session.aclose()

    res = rgd.ResponseGetData._from_httpx_response(
        res, traceback_details=traceback_details, parent_class=parent_class
    )

    if res.status == 401 and res.response == "Unauthorized":
        res.is_success = False
        raise InvalidCredentialsError(
            function_name=res.traceback_details.function_name,
            status=res.status,
            message=res.response,
        )

    return res

# %% ../../nbs/routes/auth.ipynb 19
async def who_am_i(
    auth_header: dict,
    domo_instance: str,  # <domo_instance>.domo.com
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop=0,
    debug_api: bool = False,
    return_raw: bool = False,
):
    """
    will attempt to validate against the 'me' API.
    This is the same authentication test the Domo Java CLI uses.
    """

    is_close_session = False

    if not session:
        is_close_session = True
        session = httpx.AsyncClient()

    url = f"https://{domo_instance}.domo.com/api/content/v2/users/me"

    if debug_api:
        print(url, auth_header)

    res = await session.request(method="GET", headers=auth_header, url=url)

    if is_close_session:
        await session.aclose()

    if return_raw:
        return res

    traceback_details = lg.get_traceback(num_stacks_to_drop=debug_num_stacks_to_drop)

    res = rgd.ResponseGetData._from_httpx_response(
        res, traceback_details=traceback_details, parent_class=parent_class
    )

    if res.status == 401 and res.response == "Unauthorized":
        res.is_sucess = False

        raise InvalidCredentialsError(
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            status=res.status,
            message=res.response,
            domo_instance=domo_instance,
        )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\bootstrap.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\bootstrap.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/bootstrap.ipynb.

# %% auto 0
__all__ = ['Bootstrap_RetrievalError', 'get_bootstrap', 'get_bootstrap_customerid', 'get_bootstrap_features',
           'get_bootstrap_features_is_accountsv2_enabled', 'get_bootstrap_pages']

# %% ../../nbs/routes/bootstrap.ipynb 3
import httpx

import domolibrary.client.DomoError as de
import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda

# %% ../../nbs/routes/bootstrap.ipynb 4
from ..client.DomoAuth import InvalidAuthTypeError

# %% ../../nbs/routes/bootstrap.ipynb 7
class Bootstrap_RetrievalError(de.DomoError):
    def __init__(self, status, response, domo_instance, parent_class, function_name):
        super().__init__(
            status=status,
            message=response,
            domo_instance=domo_instance,
            parent_class=parent_class,
            function_name=function_name,
        )

# %% ../../nbs/routes/bootstrap.ipynb 10
@gd.route_function
async def get_bootstrap(
    auth: dmda.DomoFullAuth,  ## only works with DomoFullAuth authentication, do not use TokenAuth
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class=None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:
    """get bootstrap data"""

    dmda.test_is_full_auth(auth, num_stacks_to_drop=1)

    # url = f"https://{auth.domo_instance}.domo.com/api/domoweb/bootstrap?v2Navigation=false"
    url = (
        f"https://{auth.domo_instance}.domo.com/api/domoweb/bootstrap?v2Navigation=true"
    )

    res = await gd.get_data(
        url=url,
        method="GET",
        auth=auth,
        debug_api=debug_api,
        session=session,
        is_follow_redirects=True,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise Bootstrap_RetrievalError(
            status=res.status,
            response=res.response,
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    if res.response == "":
        raise Bootstrap_RetrievalError(
            response="BSR_Features:  no features returned - is there a VPN?",
            status=res.status,
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/bootstrap.ipynb 15
@gd.route_function
async def get_bootstrap_customerid(
    auth: dmda.DomoFullAuth,  # this function requires the DomoFullAuth object to authenticate the bootstrap
    session: httpx.AsyncClient = None,  # optional parameter to improve same instance query performance
    debug_api: bool = False,  # pass True to see the parameters sent to the Domo API
    return_raw: bool = False,  # pass True to return the raw API response
    debug_num_stacks_to_drop=2,  # number frames to drop off the stacktrace.  retrieved from `res.traceback_details`
    parent_class: str = None,  # Optional parent class that calls the route function
) -> (
    rgd.ResponseGetData
):  # the response contains the string representation of the customer_id
    """retrieves the domo_instance customer id"""

    res = await get_bootstrap(
        auth=auth,
        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if return_raw:
        return res

    res.response = res.response.get("currentUser").get("USER_GROUP")
    return res

# %% ../../nbs/routes/bootstrap.ipynb 20
@gd.route_function
async def get_bootstrap_features(
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    return_raw: bool = False,
    debug_num_stacks_to_drop=2,
    parent_class=None,
) -> rgd.ResponseGetData:

    res = await get_bootstrap(
        auth=auth,
        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if return_raw:
        return res

    res.response = res.response.get("data").get("features")
    return res

# %% ../../nbs/routes/bootstrap.ipynb 24
@gd.route_function
async def get_bootstrap_features_is_accountsv2_enabled(
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    return_raw: bool = False,
    debug_num_stacks_to_drop=2,
    parent_class=None,
) -> rgd.ResponseGetData:

    res = await get_bootstrap_features(
        auth=auth,
        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        return_raw=False,
    )

    if return_raw:
        return res

    match_accounts_v2 = next(
        (
            domo_feature
            for domo_feature in res.response
            if domo_feature.get("name") == "accounts-v2"
        ),
        None,
    )

    res.response = True if match_accounts_v2 else False
    return res

# %% ../../nbs/routes/bootstrap.ipynb 28
@gd.route_function
async def get_bootstrap_pages(
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    return_raw: bool = False,
    debug_num_stacks_to_drop=2,
    parent_class=None,
) -> rgd.ResponseGetData:
    """this API will return the downstream (children) hierarchy of a page"""
    res = await get_bootstrap(
        auth=auth,
        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if return_raw:
        return res

    res.response = res.response.get("data").get("pages")
    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\card.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\card.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/card.ipynb.

# %% auto 0
__all__ = ['CardSearch_NotFoundError', 'get_kpi_definition', 'get_card_metadata', 'generate_body_search_cards_admin_summary',
           'search_cards_admin_summary']

# %% ../../nbs/routes/card.ipynb 2
from typing import List

import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

# %% ../../nbs/routes/card.ipynb 4
class CardSearch_NotFoundError(de.DomoError):
    def __init__(
        self,
        card_id,
        domo_instance,
        function_name,
        status,
        parent_class: str = None,
        message=None,
    ):
        super().__init__(
            status=status,
            message=f"card {card_id} not found",
            domo_instance=domo_instance,
            function_name=function_name,
            parent_class=parent_class,
        )

# %% ../../nbs/routes/card.ipynb 5
@gd.route_function
async def get_kpi_definition(
    auth: dmda.DomoAuth,
    card_id: str,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/content/v3/cards/kpi/definition"

    body = {"urn": card_id}

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success and res.response == "Not Found":
        raise CardSearch_NotFoundError(
            card_id=card_id,
            status=res.status,
            domo_instance=auth.domo_instance,
            function_name="get_kpi_definition",
        )

    return res

# %% ../../nbs/routes/card.ipynb 8
@gd.route_function
async def get_card_metadata(
    auth: dmda.DomoAuth,
    card_id: str,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:
    optional_params = "metadata,certification,datasources,owners,problems"

    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/cards?urns={card_id}&parts={optional_params}"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if res.is_success and len(res.response) == 0:
        raise CardSearch_NotFoundError(
            card_id=card_id,
            status=res.status,
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    res.response = res.response[0]

    return res

# %% ../../nbs/routes/card.ipynb 11
def generate_body_search_cards_admin_summary(
    page_ids: List[str] = None,
    #  searchPages: bool = True,
    card_search_text: str = None,
    page_search_text: str = None,
) -> dict:
    body = {"ascending": True, "orderBy": "cardTitle"}

    if card_search_text:
        body.update(
            {"cardTitleSearchText": card_search_text, "includeCardTitleClause": True}
        )

    if page_search_text:
        body.update(
            {
                "pageTitleSearchText": page_search_text,
                "includePageTitleClause": True,
                "notOnPage": False,
            }
        )

    if page_ids:
        body.update({"pageIds": page_ids})

    return body

# %% ../../nbs/routes/card.ipynb 12
@gd.route_function
async def search_cards_admin_summary(
    auth: dmda.DomoAuth,
    body: dict,
    maximum: int = None,
    debug_api: bool = False,
    debug_loop: bool = False,
    session: httpx.AsyncClient = None,
    wait_sleep: int = 3,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
) -> rgd.ResponseGetData:
    limit = 100
    offset = 0
    loop_until_end = False if maximum else True

    url = f"https://{auth.domo_instance}.domo.com/api/content/v2/cards/adminsummary?skip={offset}&limit={limit}"

    offset_params = {
        "offset": "skip",
        "limit": "limit",
    }

    def arr_fn(res):
        return res.response.get("cardAdminSummaries")

    res = await gd.looper(
        auth=auth,
        method="POST",
        url=url,
        arr_fn=arr_fn,
        offset_params=offset_params,
        limit=limit,
        skip=offset,
        body=body,
        maximum=maximum,
        session=session,
        debug_api=debug_api,
        debug_loop=debug_loop,
        loop_until_end=loop_until_end,
        wait_sleep=wait_sleep,
        parent_class=parent_class,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )
    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\codeengine.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\codeengine.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/codeengine.ipynb.

# %% auto 0
__all__ = ['CodeEngine_Package_Parts', 'remove_javascript_comments', 'parse_javascript_between_functions',
           'parse_javascript_between_module', 'remove_after_closing_parens', 'parse_javascript', 'parse_python',
           'parse_functions_factory', 'extract_functions']

# %% ../../nbs/routes/codeengine.ipynb 2
import httpx

from enum import Enum, auto
from typing import List, Callable
from functools import partial

import re

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda

# %% ../../nbs/routes/codeengine.ipynb 4
class CodeEngine_Package_Parts(Enum):
    VERSIONS = auto()
    FUNCTIONS = auto()
    CODE = auto()

# %% ../../nbs/routes/codeengine.ipynb 5
@gd.route_function
async def get_codeengine_package_by_id(
    package_id,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    params: dict = None,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:
    url = (
        f"https://{auth.domo_instance}.domo.com/api/codeengine/v2/packages/{package_id}"
    )

    params = params or {"parts": "versions"}

    return await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        params=params,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

# %% ../../nbs/routes/codeengine.ipynb 7
@gd.route_function
async def get_codeengine_package_by_id_and_version(
    package_id,
    version,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    params: dict = None,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/codeengine/v2/packages/{package_id}/versions/{version}"

    params = params or {"parts": "functions,code"}

    return await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        params=params,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

# %% ../../nbs/routes/codeengine.ipynb 11
def remove_javascript_comments(code, **kwargs):
    pattern = r"(/\*\*(.*?)\*/)"
    return re.sub(pattern, "", code, flags=re.DOTALL)


def parse_javascript_between_functions(code, function_name):
    # pattern = r"((async\s)?function\s+" + function_name + r"\(.*?\).*?)(async\s)?function\s"
    pattern = r"((async\s)?function\s+" + function_name + r"\(.*?\).*?}\n\n\n)"
    match = re.search(pattern, code, re.DOTALL)
    return match.group(0) if match else None


def parse_javascript_between_module(code, function_name):
    pattern = (
        r"((async\s)?function\s+" + function_name + r"\(.*?\).*?)(?=module.export)"
    )
    match = re.search(pattern, code, re.DOTALL)
    return match.group(0) if match else None


def remove_after_closing_parens(code, **kwargs):
    pattern = r"(.*\})"
    match = re.search(pattern, code, re.DOTALL)
    return match.group(0) if match else None


def parse_javascript(function_name, code):
    # remove comments
    code = remove_javascript_comments(code)

    # find everything until the next function definition
    match_str = parse_javascript_between_functions(
        code=code, function_name=function_name
    )

    if not match_str:
        match_str = parse_javascript_between_module(
            code=code, function_name=function_name
        )

    # remove everything after the last closing parens
    return remove_javascript_comments(match_str)


def parse_python(function_name, code):
    pattern = (
        r"(async\s+)?def\s+" + re.escape(function_name) + r"\s*\([^)]*\)\s*:\s*[^}]*"
    )
    match = re.search(pattern, code, re.DOTALL)
    return match.group(0)


class parse_functions_factory(Enum):
    PYTHON = partial(parse_python)
    JAVASCRIPT = partial(parse_javascript)


def extract_functions(
    function_ls: List[dict],  # from API, function metadata
    code: str,  # from API, code string
    language: str,  # PYTHON or JAVASCRIPT, must align with parse_functions_factory enum
    parse_fn: Callable = None,  # function for exctracting functions must receive `code:str` and function_name:str`
):
    """helper function that handles parsing"""

    parse_fn = parse_fn or parse_functions_factory[language]

    res = []

    # return [{ **function, "code" : parse_fn.value(function_name=function["name"], code=code)}
    #     for function in function_ls
    # ]
    for function in function_ls:
        function_name = function["name"]
        # print(function_name)
        code_obj = {"code": parse_fn.value(function_name=function_name, code=code)}
        # print(code_obj)
        res.append({**function, **code_obj})

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\datacenter.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\datacenter.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/datacenter.ipynb.

# %% auto 0
__all__ = ['Datacenter_Enum', 'Dataflow_Type_Filter_Enum', 'Datacenter_Filter_Field_Enum',
           'Datacenter_Filter_Field_Certification_Enum', 'generate_search_datacenter_filter',
           'generate_search_datacenter_filter_search_term', 'generate_search_datacenter_body',
           'generate_search_datacenter_account_body', 'SearchDatacenter_NoResultsFound', 'search_datacenter',
           'get_connectors', 'get_lineage_upstream', 'ShareResource_Enum', 'share_resource']

# %% ../../nbs/routes/datacenter.ipynb 2
from enum import Enum
from typing import Union
import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoError as de
import domolibrary.client.DomoAuth as dmda

# %% ../../nbs/routes/datacenter.ipynb 4
class Datacenter_Enum(Enum):
    ACCOUNT = "ACCOUNT"
    CARD = "CARD"
    DATAFLOW = "DATAFLOW"
    DATASET = "DATASET"
    GROUP = "GROUP"
    PAGE = "PAGE"
    USER = "USER"
    CONNECTOR = "CONNECTOR"
    PACKAGE = "PACKAGE"


class Dataflow_Type_Filter_Enum(Enum):
    ADR = {
        "filterType": "term",
        "field": "data_flow_type",
        "value": "ADR",
        "name": "ADR",
        "not": False,
    }

    MYSQL = {
        "filterType": "term",
        "field": "data_flow_type",
        "value": "MYSQL",
        "name": "MYSQL",
        "not": False,
    }

    REDSHIFT = {
        "filterType": "term",
        "field": "data_flow_type",
        "value": "MYSQL",
        "name": "MYSQL",
        "not": False,
    }

    MAGICV2 = {
        "filterType": "term",
        "field": "data_flow_type",
        "value": "MAGIC",
        "name": "Magic ETL v2",
        "not": False,
    }

    MAGIC = {
        "filterType": "term",
        "field": "data_flow_type",
        "value": "ETL",
        "name": "Magic ETL",
        "not": False,
    }

# %% ../../nbs/routes/datacenter.ipynb 5
class Datacenter_Filter_Field_Enum(Enum):
    DATAPROVIDER = "dataprovidername_facet"
    CERTIFICATION = "certification.state"


class Datacenter_Filter_Field_Certification_Enum(Enum):
    CERTIFIED = "CERTIFIED"
    PENDING = "PENDING"
    REQUESTED = "REQUESTED"
    EXPIRED = "EXPIRED"


def generate_search_datacenter_filter(
    field,  # use Datacenter_Filter_Field_Enum
    value,
    is_not: bool = False,  # to handle exclusion
):
    return {
        "filterType": "term",
        "field": field,
        "value": value,
        "not": is_not,
    }

# %% ../../nbs/routes/datacenter.ipynb 7
def generate_search_datacenter_filter_search_term(search_term):
    # if not "*" in search_term:
    #     search_term = f"*{search_term}*"

    return {"field": "name_sort", "filterType": "wildcard", "query": search_term}

# %% ../../nbs/routes/datacenter.ipynb 10
def generate_search_datacenter_body(
    search_text: str = None,
    entity_type: Union[
        str, list
    ] = "DATASET",  # can accept one entity_type or a list of entity_types
    additional_filters_ls: list[dict] = None,
    combineResults: bool = True,
    limit: int = 100,
    offset: int = 0,
):
    filters_ls = (
        [generate_search_datacenter_filter_search_term(search_text)]
        if search_text
        else []
    )

    if not isinstance(entity_type, list):
        entity_type = [entity_type]

    if additional_filters_ls:
        if not isinstance(additional_filters_ls, list):
            additional_filters_ls = [additional_filters_ls]

        filters_ls += additional_filters_ls

    return {
        "entities": entity_type,
        "filters": filters_ls or [],
        "combineResults": combineResults,
        "query": "*",
        "count": limit,
        "offset": offset,
    }

# %% ../../nbs/routes/datacenter.ipynb 13
def generate_search_datacenter_account_body(
    search_str: str, is_exact_match: bool = True
):
    return {
        # "count": 100,
        # "offset": 0,
        "combineResults": False,
        "query": search_str if is_exact_match else f"*{search_str}*",
        "filters": [],
        "facetValuesToInclude": [
            "DATAPROVIDERNAME",
            "OWNED_BY_ID",
            "VALID",
            "USED",
            "LAST_MODIFIED_DATE",
        ],
        "queryProfile": "GLOBAL",
        "entityList": [["account"]],
        "sort": {"fieldSorts": [{"field": "display_name_sort", "sortOrder": "ASC"}]},
    }

# %% ../../nbs/routes/datacenter.ipynb 14
class SearchDatacenter_NoResultsFound(de.DomoError):
    def __init__(
        self, body, domo_instance, parent_class: str = None, function_name: str = None
    ):
        super().__init__(
            message=body,
            domo_instance=domo_instance,
            parent_class=parent_class,
            function_name=function_name,
        )


@gd.route_function
async def search_datacenter(
    auth: dmda.DomoAuth,
    maximum: int = None,
    body: dict = None,  # either pass a body or generate a body in the function using search_text, entity_type, and additional_filters parameters
    search_text=None,
    entity_type: Union[
        str, list
    ] = "dataset",  # can accept one value or a list of values
    additional_filters_ls=None,
    arr_fn: callable = None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_loop: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
) -> rgd.ResponseGetData:
    limit = 100  # api enforced limit

    if not body:
        body = generate_search_datacenter_body(
            entity_type=entity_type,
            additional_filters_ls=additional_filters_ls,
            search_text=search_text,
            combineResults=False,
            limit=limit,
        )

    if not arr_fn:

        def arr_fn(res):
            return res.response.get("searchObjects")

    url = f"https://{auth.domo_instance}.domo.com/api/search/v1/query"

    res = await gd.looper(
        auth=auth,
        session=session,
        url=url,
        loop_until_end=True if not maximum else False,
        body=body,
        offset_params_in_body=True,
        offset_params={"offset": "offset", "limit": "count"},
        arr_fn=arr_fn,
        method="POST",
        maximum=maximum,
        limit=limit,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        debug_loop=debug_loop,
    )

    if res.is_success and len(res.response) == 0:
        raise SearchDatacenter_NoResultsFound(
            body=body,
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/datacenter.ipynb 17
@gd.route_function
async def get_connectors(
    auth: dmda.DomoAuth,
    search_text=None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
    additional_filters_ls=None,
):
    additional_filters_ls = additional_filters_ls or []

    body = generate_search_datacenter_body(
        entity_type=Datacenter_Enum.CONNECTOR.value,
        additional_filters_ls=additional_filters_ls,
        combineResults=True,
    )

    res = await search_datacenter(
        auth=auth,
        body=body,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if search_text:
        res.response = [
            r
            for r in res.response
            if search_text.lower() in r["label"].lower()
            or search_text.lower() in r["title"].lower()
        ]

    return res

# %% ../../nbs/routes/datacenter.ipynb 19
@gd.route_function
async def get_lineage_upstream(
    auth: dmda.DomoAuth,
    entity_type: str,
    entity_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/lineage/{entity_type}/{entity_id}"

    params = {"traverseDown": "false"}

    return await gd.get_data(
        auth=auth,
        method="GET",
        url=url,
        params=params,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

# %% ../../nbs/routes/datacenter.ipynb 22
class ShareResource_Enum(Enum):
    PAGE = "page"
    CARD = "badge"


@gd.route_function
async def share_resource(
    auth: dmda.DomoAuth,
    resource_ids: list,
    resource_type: ShareResource_Enum,
    group_ids: list = None,
    user_ids: list = None,
    message: str = None,  # email to user
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
):
    """shares page or card with users or groups

    body format:  {
        "resources": [
            {
                "type": "page",
                "id": {oage_id}
            }
        ],
        "recipients": [
            {
                "type": "group",
                "id": "{group_id}"
            }
        ],
        "message": "I thought you might find this page interesting."
    }"""

    resource_ids = resource_ids if isinstance(resource_ids, list) else [resource_ids]
    if group_ids:
        group_ids = (
            group_ids and group_ids if isinstance(group_ids, list) else [group_ids]
        )

    if user_ids:
        user_ids = user_ids if isinstance(user_ids, list) else [user_ids]

    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/share?sendEmail=false"

    recipient_ls = []

    if group_ids:
        [recipient_ls.append({"type": "group", "id": str(id)}) for id in group_ids]

    if user_ids:
        [recipient_ls.append({"type": "user", "id": str(id)}) for id in user_ids]

    resource_ls = [{"type": resource_type.value, "id": str(id)} for id in resource_ids]

    body = {
        "resources": resource_ls,
        "recipients": recipient_ls,
        "message": message,
    }

    res = await gd.get_data(
        url,
        method="POST",
        auth=auth,
        body=body,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if res.is_success:
        res.response = f"{resource_type.value} {','.join([resource['id'] for resource in  resource_ls])} successfully shared with {', '.join([recipient['id'] for recipient in recipient_ls])}"

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\dataflow.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\dataflow.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/dataflow.ipynb.

# %% auto 0
__all__ = ['get_dataflow_by_id', 'get_dataflow_versions', 'get_dataflow_by_id_and_version', 'get_dataflow_execution_history',
           'get_dataflow_execution_by_id', 'execute_dataflow']

# %% ../../nbs/routes/dataflow.ipynb 2
import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda

# %% ../../nbs/routes/dataflow.ipynb 4
@gd.route_function
async def get_dataflow_by_id(
    dataflow_id: int,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:
    domo_instance = auth.domo_instance

    url = f"https://{domo_instance}.domo.com/api/dataprocessing/v1/dataflows/{dataflow_id}"

    return await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

# %% ../../nbs/routes/dataflow.ipynb 8
@gd.route_function
async def get_dataflow_versions(
    dataflow_id: int,
    auth: dmda.DomoAuth,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=1,
    debug_api: bool = False,
):

    url = f"https://{auth.domo_instance}.domo.com/api/dataprocessing/v1/dataflows/{dataflow_id}/versions"

    res = await gd.get_data(
        auth=auth,
        session=session,
        url=url,
        method="GET",
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        debug_api=debug_api,
    )

    return res

# %% ../../nbs/routes/dataflow.ipynb 10
@gd.route_function
async def get_dataflow_by_id_and_version(
    dataflow_id: int,
    version_id: int,
    auth: dmda.DomoAuth,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=1,
    debug_api: bool = False,
):

    url = f"https://{auth.domo_instance}.domo.com/api/dataprocessing/v2/dataflows/{dataflow_id}/versions/{version_id}"

    res = await gd.get_data(
        auth=auth,
        session=session,
        url=url,
        method="GET",
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        debug_api=debug_api,
    )

    return res

# %% ../../nbs/routes/dataflow.ipynb 12
@gd.route_function
async def get_dataflow_execution_history(
    dataflow_id: int,
    auth: dmda.DomoAuth,
    maximum: int = None,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=1,
    debug_loop: bool = False,
    debug_api: bool = False,
):
    limit = 100

    url = f"https://{auth.domo_instance}.domo.com/api/dataprocessing/v1/dataflows/{dataflow_id}/executions"

    def arr_fn(res):
        return res.response

    res = await gd.looper(
        auth=auth,
        session=session,
        url=url,
        loop_until_end=True if not maximum else False,
        method="GET",
        offset_params_in_body=False,
        offset_params={"offset": "offset", "limit": "limit"},
        arr_fn=arr_fn,
        maximum=maximum,
        limit=limit,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        debug_api=debug_api,
        debug_loop=debug_loop,
    )

    return res

# %% ../../nbs/routes/dataflow.ipynb 16
@gd.route_function
async def get_dataflow_execution_by_id(
    auth: dmda.DomoAuth,
    dataflow_id: int,
    execution_id: int,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/dataprocessing/v1/dataflows/{dataflow_id}/executions/{execution_id}"

    return await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        debug_api=debug_api,
        session=session,
    )

# %% ../../nbs/routes/dataflow.ipynb 20
@gd.route_function
async def execute_dataflow(
    auth: dmda.DomoAuth,
    dataflow_id: int,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/dataprocessing/v1/dataflows/{dataflow_id}/executions"

    return await gd.get_data(
        auth=auth,
        url=url,
        method="POST",
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        debug_api=debug_api,
        session=session,
    )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\dataset.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\dataset.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/dataset.ipynb.

# %% auto 0
__all__ = ['DatasetNotFoundError', 'QueryRequestError', 'query_dataset_public', 'query_dataset_private', 'get_dataset_by_id',
           'get_schema', 'alter_schema', 'set_dataset_tags', 'UploadDataError', 'upload_dataset_stage_1',
           'upload_dataset_stage_2_file', 'upload_dataset_stage_2_df', 'upload_dataset_stage_3', 'index_dataset',
           'index_status', 'generate_list_partitions_body', 'list_partitions', 'generate_create_dataset_body', 'create',
           'delete_partition_stage_1', 'delete_partition_stage_2', 'delete', 'ShareDataset_AccessLevelEnum',
           'generate_share_dataset_payload', 'ShareDataset_Error', 'share_dataset']

# %% ../../nbs/routes/dataset.ipynb 3
from typing import Optional, List
from enum import Enum

import io
import pandas as pd

import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

# %% ../../nbs/routes/dataset.ipynb 6
class DatasetNotFoundError(de.DomoError):
    def __init__(
        self,
        dataset_id,
        domo_instance,
        status=None,
        parent_class=None,
        function_name=None,
    ):
        message = f"dataset - {dataset_id} not found"

        super().__init__(
            message,
            status=status,
            domo_instance=domo_instance,
            function_name=function_name,
            parent_class=parent_class,
        )

# %% ../../nbs/routes/dataset.ipynb 7
class QueryRequestError(de.DomoError):
    def __init__(
        self,
        dataset_id,
        domo_instance,
        sql,
        status=None,
        message="",
        parent_class=None,
        function_name=None,
    ):
        message = f"dataset - {dataset_id} received a bad request {message}.  Check your SQL \n {sql}"

        super().__init__(
            message,
            status=status,
            domo_instance=domo_instance,
            parent_class=parent_class,
            function_name=function_name,
        )


# typically do not use
async def query_dataset_public(
    dev_auth: dmda.DomoDeveloperAuth,
    dataset_id: str,
    sql: str,
    session: httpx.AsyncClient,
    debug_api: bool = False,
):
    """query for hitting public apis, requires client_id and secret authentication"""

    url = f"https://api.domo.com/v1/datasets/query/execute/{dataset_id}?IncludeHeaders=true"

    body = {"sql": sql}

    return await gd.get_data(
        auth=dev_auth,
        url=url,
        method="POST",
        body=body,
        session=session,
        debug_api=debug_api,
    )


async def query_dataset_private(
    auth: dmda.DomoAuth,  # DomoFullAuth or DomoTokenAuth
    dataset_id: str,
    sql: str,
    session: Optional[httpx.AsyncClient] = None,
    loop_until_end: bool = False,  # retrieve all available rows
    limit=100,  # maximum rows to return per request.  refers to PAGINATION
    skip=0,
    maximum=100,  # equivalent to the LIMIT or TOP clause in SQL, the number of rows to return total
    filter_pdp_policy_id_ls: List[int] = None,
    debug_api: bool = False,
    debug_loop: bool = False,
    timeout: int = 10,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    """execute SQL queries against private APIs, requires DomoFullAuth or DomoTokenAuth"""

    url = f"https://{auth.domo_instance}.domo.com/api/query/v1/execute/{dataset_id}"

    offset_params = {
        "offset": "offset",
        "limit": "limit",
    }

    # def body_fn(skip, limit):
    #     return {"sql": f"{sql} limit {limit} offset {skip}"}

    def body_fn(skip, limit, body=None):
        body = {"sql": f"{sql} limit {limit} offset {skip}"}

        if filter_pdp_policy_id_ls:
            body.update(
                {
                    "context": {
                        "dataControlContext": {
                            "filterGroupIds": filter_pdp_policy_id_ls,
                            "previewPdp": True,
                        }
                    }
                }
            )

        return body

    def arr_fn(res) -> pd.DataFrame:
        rows_ls = res.response.get("rows")
        columns_ls = res.response.get("columns")
        output = []
        for row in rows_ls:
            new_row = {}
            for index, column in enumerate(columns_ls):
                new_row[column] = row[index]
            output.append(new_row)
            # pd.DataFrame(data=res.response.get('rows'), columns=res.response.get('columns'))
        return output

    res = await gd.looper(
        auth=auth,
        method="POST",
        url=url,
        arr_fn=arr_fn,
        offset_params=offset_params,
        limit=limit,
        skip=skip,
        maximum=maximum,
        session=session,
        body_fn=body_fn,
        debug_api=debug_api,
        debug_loop=debug_loop,
        loop_until_end=loop_until_end,
        timeout=timeout,
        parent_class=parent_class,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if res.status == 404 and res.response == "Not Found":
        raise DatasetNotFoundError(
            dataset_id=dataset_id,
            domo_instance=auth.domo_instance,
            status=res.status,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    if res.status == 400 and res.response == "Bad Request":
        raise QueryRequestError(
            dataset_id=dataset_id,
            domo_instance=auth.domo_instance,
            sql=sql,
            status=res.status,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    if not res.is_success:
        raise QueryRequestError(
            dataset_id=dataset_id,
            domo_instance=auth.domo_instance,
            sql=sql,
            message=res.response,
            status=res.status,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/dataset.ipynb 10
async def get_dataset_by_id(
    dataset_id: str,  # dataset id from URL
    auth: Optional[dmda.DomoAuth] = None,  # requires full authentication
    debug_api: bool = False,  # for troubleshooting API request
    session: Optional[httpx.AsyncClient] = None,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:  # returns metadata about a dataset
    """retrieve dataset metadata"""

    url = f"https://{auth.domo_instance}.domo.com/api/data/v3/datasources/{dataset_id}"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if res.status == 404 and res.response == "Not Found":
        raise DatasetNotFoundError(
            dataset_id=dataset_id,
            domo_instance=auth.domo_instance,
            status=res.status,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/dataset.ipynb 13
async def get_schema(
    auth: dmda.DomoAuth,
    dataset_id: str,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class=None,
) -> rgd.ResponseGetData:
    """retrieve the schema for a dataset"""

    url = f"https://{auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/schema/indexed?includeHidden=false"

    return await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

# %% ../../nbs/routes/dataset.ipynb 16
async def alter_schema(
    auth: dmda.DomoAuth,
    schema_obj: dict,
    dataset_id: str,
    debug_api: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
) -> rgd.ResponseGetData:
    """retrieve the schema for a dataset"""

    url = f"https://{auth.domo_instance}.domo.com/api/data/v2/datasources/{dataset_id}/schemas"

    return await gd.get_data(
        auth=auth,
        url=url,
        method="POST",
        body=schema_obj,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

# %% ../../nbs/routes/dataset.ipynb 18
async def set_dataset_tags(
    auth: dmda.DomoFullAuth,
    tag_ls: List[str],  # complete list of tags for dataset
    dataset_id: str,
    debug_api: bool = False,
    session: Optional[httpx.AsyncClient] = None,
    return_raw: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
):
    """REPLACE tags on this dataset with a new list"""

    url = f"https://{auth.domo_instance}.domo.com/api/data/ui/v3/datasources/{dataset_id}/tags"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="POST",
        debug_api=debug_api,
        body=tag_ls,
        session=session,
        return_raw=return_raw,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    if res.status == 200:
        res.set_response(
            response=f'Dataset {dataset_id} tags updated to [{ ", ".join(tag_ls) }]'
        )

    return res

# %% ../../nbs/routes/dataset.ipynb 21
class UploadDataError(de.DomoError):
    """raise if unable to upload data to Domo"""

    def __init__(
        self, stage_num: int, dataset_id: str, status, message, domo_instance: str
    ):
        message = f"error uploading data during Stage { stage_num} - {message}"

        super().__init__(
            entity_id=dataset_id,
            message=message,
            status=status,
            domo_instance=domo_instance,
        )

# %% ../../nbs/routes/dataset.ipynb 22
async def upload_dataset_stage_1(
    auth: dmda.DomoAuth,
    dataset_id: str,
    #  restate_data_tag: str = None, # deprecated
    partition_tag: str = None,  # synonymous with data_tag
    session: Optional[httpx.AsyncClient] = None,
    debug_api: bool = False,
    return_raw: bool = False,
) -> rgd.ResponseGetData:
    """preps dataset for upload by creating an upload_id (upload session key) pass to stage 2 as a parameter"""

    url = f"https://{auth.domo_instance}.domo.com/api/data/v3/datasources/{dataset_id}/uploads"

    # base body assumes no paritioning
    body = {"action": None, "appendId": None}

    params = None

    if partition_tag:
        # params = {'dataTag': restate_data_tag or data_tag} # deprecated
        params = {"dataTag": partition_tag}
        body.update({"appendId": "latest"})

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="POST",
        body=body,
        session=session,
        debug_api=debug_api,
        params=params,
    )

    if not res.is_success:
        raise UploadDataError(
            stage_num=1,
            dataset_id=dataset_id,
            domo_instance=auth.domo_instance,
            status=res.status,
            message=res.response,
        )

    if return_raw:
        return res

    upload_id = res.response.get("uploadId")

    if not upload_id:
        raise UploadDataError(
            stage_num=1,
            dataset_id=dataset_id,
            domo_instance=auth.domo_instance,
            status=res.status,
            message="no upload_id",
        )

    res.response = upload_id

    return res

# %% ../../nbs/routes/dataset.ipynb 24
async def upload_dataset_stage_2_file(
    auth: dmda.DomoAuth,
    dataset_id: str,
    upload_id: str,  # must originate from  a stage_1 upload response
    data_file: Optional[io.TextIOWrapper] = None,
    session: Optional[httpx.AsyncClient] = None,
    # only necessary if streaming multiple files into the same partition (multi-part upload)
    part_id: str = 2,
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/data/v3/datasources/{dataset_id}/uploads/{upload_id}/parts/{part_id}"

    body = data_file

    res = await gd.get_data(
        url=url,
        method="PUT",
        auth=auth,
        content_type="text/csv",
        body=body,
        session=session,
        debug_api=debug_api,
    )

    if not res.is_success:
        raise UploadDataError(
            stage_num=2,
            dataset_id=dataset_id,
            domo_instance=auth.domo_instance,
            status=res.status,
            message=res.response,
        )

    res.upload_id = upload_id
    res.dataset_id = dataset_id
    res.part_id = part_id

    return res

# %% ../../nbs/routes/dataset.ipynb 25
async def upload_dataset_stage_2_df(
    auth: dmda.DomoAuth,
    dataset_id: str,
    upload_id: str,  # must originate from  a stage_1 upload response
    upload_df: pd.DataFrame,
    session: Optional[httpx.AsyncClient] = None,
    part_id: str = 2,  # only necessary if streaming multiple files into the same partition (multi-part upload)
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/data/v3/datasources/{dataset_id}/uploads/{upload_id}/parts/{part_id}"

    body = upload_df.to_csv(header=False, index=False)

    # if debug:
    #     print(body)

    res = await gd.get_data(
        url=url,
        method="PUT",
        auth=auth,
        content_type="text/csv",
        body=body,
        session=session,
        debug_api=debug_api,
    )

    if not res.is_success:
        raise UploadDataError(
            stage_num=2,
            dataset_id=dataset_id,
            domo_instance=auth.domo_instance,
            status=res.status,
            message=res.response,
        )

    res.upload_id = upload_id
    res.dataset_id = dataset_id
    res.part_id = part_id

    return res

# %% ../../nbs/routes/dataset.ipynb 26
async def upload_dataset_stage_3(
    auth: dmda.DomoAuth,
    dataset_id: str,
    upload_id: str,  # must originate from  a stage_1 upload response
    session: Optional[httpx.AsyncClient] = None,
    update_method: str = "REPLACE",  # accepts REPLACE or APPEND
    #  restate_data_tag: str = None, # deprecated
    partition_tag: str = None,  # synonymous with data_tag
    is_index: bool = False,  # index after uploading
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    """commit will close the upload session, upload_id.  this request defines how the data will be loaded into Adrenaline, update_method
    has optional flag for indexing dataset.
    """

    url = f"https://{auth.domo_instance}.domo.com/api/data/v3/datasources/{dataset_id}/uploads/{upload_id}/commit"

    body = {"index": is_index, "action": update_method}

    if partition_tag:
        body.update(
            {
                "action": "APPEND",
                #  'dataTag': restate_data_tag or data_tag,
                #  'appendId': 'latest' if (restate_data_tag or data_tag) else None,
                "dataTag": partition_tag,
                "appendId": "latest" if partition_tag else None,
                "index": is_index,
            }
        )

    res = await gd.get_data(
        auth=auth,
        method="PUT",
        url=url,
        body=body,
        session=session,
        debug_api=debug_api,
    )

    if not res.is_success:
        raise UploadDataError(
            stage_num=3,
            dataset_id=dataset_id,
            domo_instance=auth.domo_instance,
            status=res.status,
            message=res.response,
        )

    res.upload_id = upload_id
    res.dataset_id = dataset_id

    return res

# %% ../../nbs/routes/dataset.ipynb 28
async def index_dataset(
    auth: dmda.DomoAuth,
    dataset_id: str,
    session: Optional[httpx.AsyncClient] = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    """manually index a dataset"""

    url = f"https://{auth.domo_instance}.domo.com/api/data/v3/datasources/{dataset_id}/indexes"

    body = {"dataIds": []}

    return await gd.get_data(
        auth=auth,
        method="POST",
        body=body,
        url=url,
        session=session,
        debug_api=debug_api,
    )

# %% ../../nbs/routes/dataset.ipynb 29
async def index_status(
    auth: dmda.DomoAuth,
    dataset_id: str,
    index_id: str,
    session: Optional[httpx.AsyncClient] = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    """get the completion status of an index"""

    url = f"https://{auth.domo_instance}.domo.com/api/data/v3/datasources/{dataset_id}/indexes/{index_id}/statuses"

    return await gd.get_data(
        auth=auth, method="GET", url=url, session=session, debug_api=debug_api
    )

# %% ../../nbs/routes/dataset.ipynb 31
def generate_list_partitions_body(limit=100, offset=0):
    return {
        "paginationFields": [
            {
                "fieldName": "datecompleted",
                "sortOrder": "DESC",
                "filterValues": {"MIN": None, "MAX": None},
            }
        ],
        "limit": limit,
        "offset": offset,
    }


async def list_partitions(
    auth: dmda.DomoAuth,
    dataset_id: str,
    body: dict = None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_loop: bool = False,
):
    body = body or generate_list_partitions_body()

    url = f"https://{auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/partition/list"

    offset_params = {
        "offset": "offset",
        "limit": "limit",
    }

    def arr_fn(res) -> list[dict]:
        return res.response

    res = await gd.looper(
        auth=auth,
        method="POST",
        url=url,
        arr_fn=arr_fn,
        body=body,
        offset_params_in_body=True,
        offset_params=offset_params,
        loop_until_end=True,
        session=session,
        debug_loop=debug_loop,
        debug_api=debug_api,
    )

    if res.status == 404 and res.response == "Not Found":
        raise DatasetNotFoundError(
            dataset_id=dataset_id, domo_instance=auth.domo_instance, status=res.status
        )
    return res

# %% ../../nbs/routes/dataset.ipynb 33
def generate_create_dataset_body(
    dataset_name: str, dataset_type: str = "API", schema: dict = None
):
    schema = schema or {
        "columns": [
            {"type": "STRING", "name": "Friend"},
            {"type": "STRING", "name": "Attending"},
        ]
    }

    return {
        "userDefinedType": dataset_type,
        "dataSourceName": dataset_name,
        "schema": schema,
    }


async def create(
    auth: dmda.DomoAuth,
    dataset_name: str,
    dataset_type: str = "api",
    session: httpx.AsyncClient = None,
    schema: dict = None,
    debug_api: bool = False,
):
    body = generate_create_dataset_body(
        dataset_name=dataset_name, dataset_type=dataset_type, schema=schema
    )

    url = f"https://{auth.domo_instance}.domo.com/api/data/v2/datasources"

    return await gd.get_data(
        auth=auth,
        method="POST",
        url=url,
        body=body,
        session=session,
        debug_api=debug_api,
    )

# %% ../../nbs/routes/dataset.ipynb 36
async def delete_partition_stage_1(
    auth: dmda.DomoAuth,
    dataset_id: str,
    dataset_partition_id: str,
    debug_api: bool = False,
):
    # Delete partition has 3 stages
    # Stage 1. This marks the data version associated with the partition tag as deleted.  It does not delete the partition tag or remove the association between the partition tag and data version.  There should be no need to upload an empty file ‚Äì step #3 will remove the data from Adrenaline.
    # update on 9/9/2022 based on the conversation with Greg Swensen
    url = f"https://{auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/tag/{dataset_partition_id}/data"

    return await gd.get_data(auth=auth, method="DELETE", url=url, debug_api=debug_api)


# Stage 2. This will remove the partition association so that it doesn‚Äôt show up in the list call.  Technically, this is not required as a partition against a deleted data version will not count against the 400 partition limit, but as the current partitions api doesn‚Äôt make that clear, cleaning these up will make it much easier for you to manage.

# %% ../../nbs/routes/dataset.ipynb 37
async def delete_partition_stage_2(
    auth: dmda.DomoAuth,
    dataset_id: str,
    dataset_partition_id: str,
    debug_api: bool = False,
):
    url = f"https://{auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/partition/{dataset_partition_id}"

    return await gd.get_data(auth=auth, method="DELETE", url=url, debug_api=debug_api)

# %% ../../nbs/routes/dataset.ipynb 38
async def delete(
    auth: dmda.DomoAuth,
    dataset_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
):
    url = f"https://{auth.domo_instance}.domo.com/api/data/v3/datasources/{dataset_id}?deleteMethod=hard"

    return await gd.get_data(
        auth=auth, method="DELETE", url=url, session=session, debug_api=debug_api
    )

# %% ../../nbs/routes/dataset.ipynb 39
class ShareDataset_AccessLevelEnum(Enum):
    CO_OWNER = "CO_OWNER"
    CAN_EDIT = "CAN_EDIT"
    CAN_SHARE = "CAN_SHARE"


def generate_share_dataset_payload(
    entity_type,  # USER or GROUP
    entity_id,
    access_level: ShareDataset_AccessLevelEnum = ShareDataset_AccessLevelEnum.CAN_SHARE,
    is_send_email: bool = False,
):
    return {
        "permissions": [
            {"type": entity_type, "id": entity_id, "accessLevel": access_level.value}
        ],
        "sendEmail": is_send_email,
    }

# %% ../../nbs/routes/dataset.ipynb 40
class ShareDataset_Error(de.DomoError):
    def __init__(
        self,
        dataset_id,
        status,
        response,
        domo_instance,
        parent_class=None,
        function_name=None,
    ):
        message = f"error sharing dataset {dataset_id} - {response}"

        super().__init__(
            status=status,
            domo_instance=domo_instance,
            message=message,
            parent_class=parent_class,
            function_name=function_name,
        )


async def share_dataset(
    auth: dmda.DomoAuth,
    dataset_id: str,
    body: dict,
    session: httpx.AsyncClient = None,
    debug_api=False,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/data/v3/datasources/{dataset_id}/share"

    res = await gd.get_data(
        auth=auth,
        method="POST",
        url=url,
        body=body,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise ShareDataset_Error(
            dataset_id=dataset_id,
            status=res.status,
            response=res.response,
            domo_instance=auth.domo_instance,
        )

    update_user_ls = [f"{user['type']} - {user['id']}" for user in body["permissions"]]

    res.response = (
        f"updated access list { ', '.join(update_user_ls)} added to {dataset_id}"
    )
    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\grant.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\grant.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/grant.ipynb.

# %% auto 0
__all__ = ['GetGrants_Error', 'get_grants']

# %% ../../nbs/routes/grant.ipynb 3
import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

# %% ../../nbs/routes/grant.ipynb 4
class GetGrants_Error(de.DomoError):
    def __init__(self, status, message, domo_instance, function_name):
        super().__init__(
            status=status,
            message=message,
            domo_instance=domo_instance,
            function_name=function_name,
        )

# %% ../../nbs/routes/grant.ipynb 6
async def get_grants(
    auth: dmda.DomoAuth, debug_api: bool = False, session: httpx.AsyncClient = None
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/authorization/v1/authorities"

    res = await gd.get_data(
        auth=auth, url=url, method="GET", debug_api=debug_api, session=session
    )

    if not res.is_success:
        raise GetGrants_Error(
            status=res.status,
            message=res.message,
            domo_instance=auth.domo_instance,
            function_name="get_grants",
        )

    if len(res.response) == 0:
        raise GetGrants_Error(
            status=res.status,
            message=f"{len(res.response)} grants returned",
            domo_instance=auth.domo_instance,
            function_name="get_grants",
        )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\group.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\group.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/group.ipynb.

# %% auto 0
__all__ = ['SearchGroups_Error', 'search_groups_by_name', 'get_all_groups', 'get_group_by_id', 'toggle_system_group_visibility',
           'Group_CRUD_Error', 'GroupType_Enum', 'generate_body_create_group', 'create_group', 'update_group',
           'delete_groups', 'get_group_owners', 'get_group_membership', 'generate_body_update_group_membership',
           'update_group_membership']

# %% ../../nbs/routes/group.ipynb 2
import httpx
from enum import Enum
from typing import Union, List

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

# %% ../../nbs/routes/group.ipynb 5
class SearchGroups_Error(de.DomoError):
    def __init__(
        self,
        status,
        message,
        domo_instance,
        function_name="search_groups_by_name",
        parent_class: str = None,
    ):
        super().__init__(
            function_name=function_name,
            status=status,
            message=message,
            domo_instance=domo_instance,
            parent_class=parent_class,
        )


@gd.route_function
async def search_groups_by_name(
    auth: dmda.DomoAuth,
    search_name: str,
    is_exact_match: bool = True,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    """uses /content/v2/groups/grouplist api -- includes user details"""

    url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups/grouplist?ascending=true&search={search_name}&sort=name "

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )
    if not is_exact_match:
        return res

    match_group = next(
        (group for group in res.response if group.get("name") == search_name), None
    )
    # print(match_group)

    if not match_group:
        raise SearchGroups_Error(
            status=res.status,
            message=f"There is no exact match for {search_name}",
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )
    res.response = match_group

    return res

# %% ../../nbs/routes/group.ipynb 8
@gd.route_function
async def get_all_groups(
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_loop: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    """uses /content/v2/groups/grouplist api -- includes user details"""

    url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups/grouplist"

    def arr_fn(res):
        return res.response

    res = await gd.looper(
        offset_params={"offset": "offset", "limit": "limit"},
        arr_fn=arr_fn,
        loop_until_end=True,
        limit=30,
        url=url,
        method="GET",
        auth=auth,
        session=session,
        debug_loop=debug_loop,
        debug_api=debug_api,
        parent_class=parent_class,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    return res

# %% ../../nbs/routes/group.ipynb 11
@gd.route_function
async def get_group_by_id(
    auth: dmda.DomoAuth,
    group_id: str,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
) -> rgd.ResponseGetData:
    """uses /content/v2/groups/ api -- does not return details"""

    url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups/{group_id}"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if res.status == 404 and res.response == "Not Found":
        raise SearchGroups_Error(
            status=res.status,
            message=f"group {group_id} not found",
            domo_instance=auth.domo_instance,
            function_name="get_group_by_id",
        )

    return res

# %% ../../nbs/routes/group.ipynb 13
@gd.route_function
async def toggle_system_group_visibility(
    auth,
    is_hide_system_groups: bool,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
):
    print(
        f"toggling group visiblity in {auth.domo_instance} { 'hiding system groups' if is_hide_system_groups else 'show system groups'}"
    )

    url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups/setVisibility"

    await gd.get_data(
        url=url,
        method="POST",
        auth=auth,
        body={"type": "system", "hidden": is_hide_system_groups},
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
        parent_class=parent_class,
    )

    url = f"https://{auth.domo_instance}.domo.com/api/customer/v1/properties/groups.system.enabled"

    return await gd.get_data(
        url=url,
        auth=auth,
        method="GET",
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
        parent_class=parent_class,
    )

# %% ../../nbs/routes/group.ipynb 17
class Group_CRUD_Error(de.DomoError):
    def __init__(
        self,
        status,
        message,
        domo_instance,
        function_name="create_group",
        parent_class: str = None,
    ):
        super().__init__(
            function_name=function_name,
            status=status,
            message=message,
            domo_instance=domo_instance,
            parent_class=parent_class,
        )


class GroupType_Enum(Enum):
    OPEN = "open"
    ADHOC = "adHoc"
    CLOSED = "closed"
    DIRECTORY = "directory"
    DYNAMIC = "dynamic"
    SYSYTEM = "system"


def generate_body_create_group(
    group_name: str, group_type: str = "open", description: str = ""
) -> dict:
    """Generates the body to create group for content_v2_group API"""
    body = {"name": group_name, "type": group_type, "description": description}

    return body

# %% ../../nbs/routes/group.ipynb 20
@gd.route_function
async def create_group(
    auth: dmda.DomoAuth,
    group_name: str,
    group_type: str = "open",
    description: str = "",
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
    return_raw: bool = False,
) -> rgd.ResponseGetData:
    # body : {"name": "GROUP_NAME", "type": "open", "description": ""}

    body = generate_body_create_group(
        group_name=group_name, group_type=group_type, description=description
    )
    url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="POST",
        body=body,
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    if not res.is_success:
        try:
            group_exists = await search_groups_by_name(
                auth=auth, search_name=group_name, is_exact_match=True
            )

            if group_exists.is_success:
                raise Group_CRUD_Error(
                    status=res.status,
                    message=f"{group_name} already exists. Choose a different group_name",
                    function_name=res.traceback_details.function_name,
                    parent_class=parent_class,
                    domo_instance=auth.domo_instance,
                )

        except SearchGroups_Error as e:
            raise Group_CRUD_Error(
                status=res.status,
                message=res.response,
                domo_instance=auth.domo_instance,
                function_name=res.traceback_details.function_name,
                parent_class=parent_class,
            )

    return res

# %% ../../nbs/routes/group.ipynb 23
@gd.route_function
async def update_group(
    auth: dmda.DomoAuth,
    group_id: int,
    group_name: str = None,
    group_type: str = None,
    description: str = None,
    additional_params: dict = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
) -> rgd.ResponseGetData:

    s = {"groupId": int(group_id)}

    if group_name:
        s.update({"name": group_name})

    if group_type:
        s.update({"type": group_type})

    if description:
        s.update({"description": description})

    if additional_params and isinstance(additional_params, dict):
        s.update({**additional_params})
        pass

    url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=[s],
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if group_name and res.status == 400:
        raise Group_CRUD_Error(
            status=res.status,
            message="are you trying to create an account with a duplicate name?",
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    if not res.is_success:
        raise Group_CRUD_Error(
            status=res.status,
            message=res.response,
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    res.response = f"updated {group_id} from {auth.domo_instance}"
    return res

# %% ../../nbs/routes/group.ipynb 27
@gd.route_function
async def delete_groups(
    auth: dmda.DomoAuth,
    group_ids: List[str],  # list of group_ids
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
    return_raw: bool = False,
) -> rgd.ResponseGetData:

    group_ids = group_ids if isinstance(group_ids, list) else [str(group_ids)]

    url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="DELETE",
        body=group_ids,
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    if not res.is_success:
        raise Group_CRUD_Error(
            status=res.status,
            message=f"failed to delete {', '.join(group_ids)}",
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            domo_instance=auth.domo_instance,
        )

    res.response = f"deleted {', '.join(group_ids)} from {auth.domo_instance}"
    return res

# %% ../../nbs/routes/group.ipynb 31
@gd.route_function
async def get_group_owners(
    auth: dmda.DomoAuth,
    group_id: str,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:

    # url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups/access"
    # url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups/users?group={group_id}"
    url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups/permissions?checkOwnership=true&includeUsers=false"

    res = await gd.get_data(
        auth=auth,
        url=url,
        body=[str(group_id)],
        method="POST",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    res.response = res.response[0].get("permissions").get("owners")
    return res

# %% ../../nbs/routes/group.ipynb 34
@gd.route_function
async def get_group_membership(
    auth: dmda.DomoAuth,
    group_id: str,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
) -> rgd.ResponseGetData:

    # url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups/access"
    url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups/users?group={group_id}"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    res.response = res.response.get("groupUserList")
    return res

# %% ../../nbs/routes/group.ipynb 38
def generate_body_update_group_membership_entity(
    user_id: Union[str, int], user_type: str  # USER or GROUP
):
    if user_type == "USER":
        return {"type": "USER", "id": str(user_id)}
    elif user_type == "GROUP":
        return {"type": "GROUP", "id": int(user_id)}

# %% ../../nbs/routes/group.ipynb 39
def generate_body_update_group_membership(
    group_id: str,
    add_member_arr: list[str] = None,
    remove_member_arr: list[str] = None,
    add_owner_arr: list[str] = None,
    remove_owner_arr: list[str] = None,
) -> list[dict]:
    """
    each member or owner obj should be an object of shape {"type", "id"}
    """

    body = {"groupId": int(group_id)}

    if add_owner_arr and len(add_owner_arr) > 0:
        body.update(
            {
                "addOwners": [
                    generate_body_update_group_membership_entity(
                        user_id=obj.get("id"), user_type=obj.get("type")
                    )
                    for obj in add_owner_arr
                ]
            }
        )

    if remove_owner_arr and len(remove_owner_arr) > 0:
        body.update(
            {
                "removeOwners": [
                    generate_body_update_group_membership_entity(
                        user_id=obj.get("id"), user_type=obj.get("type")
                    )
                    for obj in remove_owner_arr
                ]
            }
        )

    if remove_member_arr and len(remove_member_arr) > 0:
        body.update(
            {
                "removeMembers": [
                    generate_body_update_group_membership_entity(
                        user_id=obj.get("id"), user_type=obj.get("type")
                    )
                    for obj in remove_member_arr
                ]
            }
        )
    if add_member_arr and len(add_member_arr) > 0:
        body.update(
            {
                "addMembers": [
                    generate_body_update_group_membership_entity(
                        user_id=obj.get("id"), user_type=obj.get("type")
                    )
                    for obj in add_member_arr
                ]
            }
        )

    return [body]

# %% ../../nbs/routes/group.ipynb 40
gd.route_function


async def update_group_membership(
    auth: dmda.DomoAuth,
    group_id: str,
    add_member_arr: list[dict] = None,
    remove_member_arr: list[dict] = None,
    add_owner_arr: list[dict] = None,
    remove_owner_arr: list[dict] = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
) -> rgd.ResponseGetData:
    """
    each member or owner obj should be an object of shape {"type", "id"}
    """

    body = generate_body_update_group_membership(
        group_id=group_id,
        add_member_arr=add_member_arr,
        remove_member_arr=remove_member_arr,
        add_owner_arr=add_owner_arr,
        remove_owner_arr=remove_owner_arr,
    )

    # body = [{
    #     "groupId":"GROUP_ID",
    #     "removeMembers": [{"type":"USER","id":"USER_ID"}],
    #     "addMembers"   : [{"type":"USER","id":"USER_ID"}]
    # }]
    url = f"https://{auth.domo_instance}.domo.com/api/content/v2/groups/access"

    if debug_api:
        print(url, body)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        debug_api=debug_api,
        session=session,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\instance_config.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\instance_config.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/instance_config.ipynb.

# %% auto 0
__all__ = ['ToggleSocialUsers_Error', 'get_is_invite_social_users_enabled', 'toggle_is_social_users_enabled',
           'ToggleUserInvite_Error', 'toggle_is_user_invite_enabled', 'get_is_user_invite_notifications_enabled',
           'get_sso_config', 'generate_sso_body', 'UpdateSSO_Error', 'update_sso_config', 'get_allowlist',
           'Allowlist_UnableToUpdate', 'set_allowlist', 'set_authorized_domains', 'GetDomains_NotFound',
           'get_authorized_domains', 'get_is_weekly_digest_enabled', 'toggle_is_weekly_digest_enabled',
           'GetAppDomains_NotFound', 'get_authorized_custom_app_domains', 'set_authorized_custom_app_domains']

# %% ../../nbs/routes/instance_config.ipynb 3
import httpx

from typing import List

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

from ..utils.convert import convert_string_to_bool

import domolibrary.routes.user as user_routes

# %% ../../nbs/routes/instance_config.ipynb 6
class ToggleSocialUsers_Error(de.DomoError):
    def __init__(self, status, domo_instance, message="failure to toggle social users"):
        super().__init__(status=status, domo_instance=domo_instance, message=message)


@gd.route_function
async def get_is_invite_social_users_enabled(
    auth: dmda.DomoAuth,
    customer_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    parent_class=None,
    return_raw: bool = False,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:

    # must pass the customer as the short form API endpoint (without customer_id) does not support a GET request
    # url = f"https://{auth.domo_instance}.domo.com/api/content/v3/customers/features/free-invite"

    url = f"https://{auth.domo_instance}.domo.com/api/content/v3/customers/{customer_id}/features/free-invite"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise ToggleSocialUsers_Error(
            status=res.status, message=res.response, domo_instance=auth.domo_instance
        )

    if return_raw:
        return res

    res.response = {"name": "free-invite", "is_enabled": res.response["enabled"]}

    return res

# %% ../../nbs/routes/instance_config.ipynb 9
@gd.route_function
async def toggle_is_social_users_enabled(
    is_enabled: bool,
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    return_raw: bool = False,
    parent_class=False,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:
    """
    Admin > Features > Buzz
    Toggles the ability for users to add social users to Domo when sharing content
    """

    auth = auth

    url = f"https://{auth.domo_instance}.domo.com/api/content/v3/customers/features/free-invite"

    body = {"enabled": is_enabled}

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise ToggleSocialUsers_Error(
            status=res.status, message=res.response, domo_instance=auth.domo_instance
        )

    if return_raw:
        return res

    res.response = {
        "is_enabled": is_enabled,
        "feature": "free-invite",
    }

    return res

# %% ../../nbs/routes/instance_config.ipynb 13
class ToggleUserInvite_Error(de.DomoError):
    def __init__(
        self, status, domo_instance, message="failure to toggle user invite enabled"
    ):
        super().__init__(status=status, domo_instance=domo_instance, message=message)


@gd.route_function
async def toggle_is_user_invite_enabled(
    auth: dmda.DomoAuth,
    is_enabled: bool,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    return_raw: bool = False,
    parent_class=None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:
    """
    Admin > Company Settings > Notifications
    """

    url = f"https://{auth.domo_instance}.domo.com/api/customer/v1/properties/user.invite.email.enabled"

    body = {"value": is_enabled}

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise ToggleUserInvite_Error(
            status=res.status, message=res.response, domo_instance=auth.domo_instance
        )

    if return_raw:
        return res

    res.response = {"feature": "user.invite.email.enabled", "is_enabled": is_enabled}

    return res

# %% ../../nbs/routes/instance_config.ipynb 16
@gd.route_function
async def get_is_user_invite_notifications_enabled(
    auth: dmda.DomoFullAuth,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    parent_class=None,
    debug_num_stacks_to_drop=1,
    return_raw: bool = False,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/customer/v1/properties/user.invite.email.enabled"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        session=session,
        debug_api=debug_api,
    )

    if not res.is_success:
        raise ToggleSocialUsers_Error(
            status=res.status, message=res.response, domo_instance=auth.domo_instance
        )

    if return_raw:
        return res

    res.response = {
        "name": "user.invite.email.enabled",
        "is_enabled": convert_string_to_bool(res.response["value"]),
    }

    return res

# %% ../../nbs/routes/instance_config.ipynb 20
@gd.route_function
async def get_sso_config(
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/identity/v1/authentication/oidc/std/settings"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    return res

# %% ../../nbs/routes/instance_config.ipynb 24
def generate_sso_body(
    login_enabled: bool = None,  # False
    idp_enabled: bool = None,  # False
    import_groups: bool = None,  # False
    require_invitation: bool = None,  # False
    enforce_allowlist: bool = None,  # False
    skip_to_idp: bool = None,  # False
    auth_request_endpoint: str = None,
    token_endpoint: str = None,
    user_info_endpoint: str = None,
    public_key: str = None,
    redirect_url: str = None,
    certificate: str = None,
    override_sso: bool = None,  # False
    override_embed: bool = None,  # False
    # "https://{domo_instance}}.domo.com/auth/oidc"
    well_known_config: str = None,
    assertion_endpoint: str = None,
    ingest_attributes: bool = None,  # False
):
    r = {
        "loginEnabled": login_enabled,
        "idpEnabled": idp_enabled,
        "importGroups": import_groups,
        "requireInvitation": require_invitation,
        "enforceWhitelist": enforce_allowlist,
        "skipToIdp": skip_to_idp,
        "authRequestEndpoint": auth_request_endpoint,
        "tokenEndpoint": token_endpoint,
        "userInfoEndpoint": user_info_endpoint,
        "publicKey": public_key,
        "redirectUrl": redirect_url,
        "certificate": certificate,
        "overrideSSO": override_sso,
        "overrideEmbed": override_embed,
        "wellKnownConfig": well_known_config,
        "assertionEndpoint": assertion_endpoint,
        "ingestAttributes": ingest_attributes,
    }

    return {key: value for key, value in r.items() if value is not None}

# %% ../../nbs/routes/instance_config.ipynb 25
class UpdateSSO_Error(de.DomoError):
    def __init__(
        self,
        domo_instance,
        config_body,
        function_name,
        status=None,
        parent_class=None,
    ):
        message = f'failed to set config to {  " || ".join([ key + " : " + str(value)  for key, value in config_body.items()]) }'

        super().__init__(
            domo_instance=domo_instance,
            message=message,
            status=status,
            parent_class=parent_class,
            function_name=function_name,
        )


@gd.route_function
async def update_sso_config(
    auth: dmda.DomoAuth,
    config_body: dict,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
):
    """to successfully update the SSO Configuration, you must send all the parameters related to SSO Configuration"""

    url = f"https://{auth.domo_instance}.domo.com/api/identity/v1/authentication/oidc/std/settings"

    res = await gd.get_data(
        auth=auth,
        url=url,
        body=config_body,
        method="PUT",
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if res.status == 200:
        res.is_success = True

    else:
        res.is_success = False
        raise UpdateSSO_Error(
            domo_instance=auth.domo_instance,
            config_body=config_body,
            status=res.status,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/instance_config.ipynb 29
@gd.route_function
async def get_allowlist(
    auth: dmda.DomoFullAuth,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
    debug_api: bool = False,
    parent_class=None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:

    if auth.__class__.__name__ != "DomoFullAuth":
        raise dmda.InvalidAuthTypeError(
            function_name="get_allowlist",
            domo_instance=auth.domo_instance,
            required_auth_type=dmda.DomoFullAuth,
        )

    url = f"https://{auth.domo_instance}.domo.com/admin/companysettings/whitelist"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        headers={"accept": "*/*"},
        session=session,
        debug_api=debug_api,
        is_follow_redirects=True,
        return_raw=return_raw,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    return res

# %% ../../nbs/routes/instance_config.ipynb 34
class Allowlist_UnableToUpdate(de.DomoError):
    def __init__(
        self,
        status: int,
        reason: str,
        domo_instance: str,
        function_name: str = "update_allowlist",
    ):
        super().__init__(
            function_name=function_name,
            status=status,
            message=f"unable to update allowlist: {reason}",
            domo_instance=domo_instance,
        )

# %% ../../nbs/routes/instance_config.ipynb 35
@gd.route_function
async def set_allowlist(
    auth: dmda.DomoAuth,
    ip_address_ls: list[str],
    debug_api: bool = False,
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
    parent_class=None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:
    """companysettings/whitelist API only allows users to SET the allowlist does not allow INSERT or UPDATE"""

    url = f"https://{auth.domo_instance}.domo.com/admin/companysettings/whitelist"

    body = {"addresses": ip_address_ls}

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        debug_api=debug_api,
        is_follow_redirects=True,
        return_raw=return_raw,
        session=session,
        headers={"accept": "text/plain"},
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )
    if not res.is_success:
        raise Allowlist_UnableToUpdate(
            status=res.status, reason=res.response, domo_instance=auth.domo_instance
        )

    if res.is_success:
        res.response = f"allow list updated from {res.response}"

    return res

# %% ../../nbs/routes/instance_config.ipynb 38
@gd.route_function
async def set_authorized_domains(
    auth: dmda.DomoAuth,
    authorized_domain_ls: List[str],
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/customer-states/authorized-domains"

    body = {"name": "authorized-domains", "value": ",".join(authorized_domain_ls)}

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    return res

# %% ../../nbs/routes/instance_config.ipynb 39
class GetDomains_NotFound(de.DomoError):
    def __init__(self, status, message, domo_instance):
        super().__init__(status=status, message=message, domo_instance=domo_instance)


@gd.route_function
async def get_authorized_domains(
    auth: dmda.DomoAuth,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/customer-states/authorized-domains"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    # domo raises a 404 error even if the success is valid but there are no approved domains
    if res.status == 404 and res.response == "Not Found":
        res_test = await user_routes.get_all_users(auth=auth)

        if not res_test.is_success:
            raise GetDomains_NotFound(
                domo_instance=auth.domo_instance,
                status=res.status,
                message=res.response,
            )

        if res_test.is_success:
            res.status = 200
            res.is_success = True
            res.response = []

        return res

    res.response = [domain.strip() for domain in res.response.get("value").split(",")]
    return res

# %% ../../nbs/routes/instance_config.ipynb 43
@gd.route_function
async def get_is_weekly_digest_enabled(
    auth: dmda.DomoAuth,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/customer-states/come-back-to-domo-all-users"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    res.response = {
        "is_enabled": convert_string_to_bool(res.response["value"]),
        "feature": "come-back-to-domo-all-users",
    }

    return res

# %% ../../nbs/routes/instance_config.ipynb 45
@gd.route_function
async def toggle_is_weekly_digest_enabled(
    auth: dmda.DomoAuth,
    return_raw: bool = False,
    debug_api: bool = False,
    is_enabled: bool = True,
    session: httpx.AsyncClient = None,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/customer-states/come-back-to-domo-all-users"

    body = {"name": "come-back-to-domo-all-users", "value": is_enabled}
    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        return res

    return await get_is_weekly_digest_enabled(auth=auth)

# %% ../../nbs/routes/instance_config.ipynb 48
class GetAppDomains_NotFound(de.DomoError):
    def __init__(self, status, message, domo_instance):
        super().__init__(status=status, message=message, domo_instance=domo_instance)


@gd.route_function
async def get_authorized_custom_app_domains(
    auth: dmda.DomoAuth,
    return_raw: bool = False,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/customer-states/authorized-app-domains"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    # domo raises a 404 error even if the success is valid but there are no approved domains
    if res.status == 404 and res.response == "Not Found":
        res_test = await user_routes.get_all_users(auth=auth)

        if not res_test.is_success:
            raise GetAppDomains_NotFound(
                domo_instance=auth.domo_instance,
                status=res.status,
                message=res.response,
            )

        if res_test.is_success:
            res.status = 200
            res.is_success = True
            res.response = []

        return res

    res.response = [domain.strip() for domain in res.response.get("value").split(",")]
    return res

# %% ../../nbs/routes/instance_config.ipynb 51
@gd.route_function
async def set_authorized_custom_app_domains(
    auth: dmda.DomoAuth,
    authorized_custom_app_domain_ls: List[str],
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/customer-states/authorized-app-domains"

    body = {
        "name": "authorized-app-domains",
        "value": ",".join(authorized_custom_app_domain_ls),
    }

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\jupyter.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\jupyter.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/jupyter.ipynb.

# %% auto 0
__all__ = ['JupyterAPI_Error', 'JupyterAPI_WorkspaceStarted', 'get_jupyter_workspace_by_id',
           'parse_instance_service_location_and_prefix', 'get_workspace_auth_token_params', 'get_jupyter_workspaces',
           'start_jupyter_workspace', 'get_jupyter_content', 'generate_update_jupyter_body_factory',
           'generate_update_jupyter_body', 'update_jupyter_file', 'get_content']

# %% ../../nbs/routes/jupyter.ipynb 2
from enum import Enum

import os
import httpx
from functools import partial

import urllib

import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.get_data as gd

import domolibrary.client.DomoError as de
import domolibrary.utils.chunk_execution as ce

# %% ../../nbs/routes/jupyter.ipynb 5
class JupyterAPI_Error(de.DomoError):
    def __init__(
        self, status, response, domo_instance, parent_class=None, function_name=None
    ):
        super().__init__(
            status=status,
            message=response,
            domo_instance=domo_instance,
            parent_class=parent_class,
            function_name=function_name,
        )


class JupyterAPI_WorkspaceStarted(de.DomoError):
    def __init__(
        self, status, response, domo_instance, parent_class=None, function_name=None
    ):
        super().__init__(
            status=status,
            message=response,
            domo_instance=domo_instance,
            parent_class=parent_class,
            function_name=function_name,
        )

# %% ../../nbs/routes/jupyter.ipynb 6
@gd.route_function
async def get_jupyter_workspace_by_id(
    auth,
    workspace_id,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
):
    url = f"https://{auth.domo_instance}.domo.com/api/datascience/v1/workspaces/{workspace_id}"

    res = await gd.get_data(
        url=url,
        method="GET",
        auth=auth,
        parent_class=parent_class,
        session=session,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        debug_api=debug_api,
    )

    if not res.is_success:
        raise JupyterAPI_Error(
            status=res.status,
            response=res.response,
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/jupyter.ipynb 8
def parse_instance_service_location_and_prefix(instance: dict, domo_instance):
    url = instance["url"]

    query = urllib.parse.unquote(urllib.parse.urlparse(url).query)
    query = urllib.parse.urlparse(query.split("&")[1].replace("next=", ""))

    return {
        "service_location": query.netloc.replace(domo_instance, "")[1:],
        "service_prefix": query.path,
    }


async def get_workspace_auth_token_params(workspace_id, auth, return_raw: bool = False):
    """
    params are needed for authenticating requests inside the workspace environment
    Note: you'll also need a internally generated jupyter_token to authenticate requests
    returns { service_location , service_prefix}
    """
    res = await get_jupyter_workspace_by_id(workspace_id=workspace_id, auth=auth)

    open_instances = res.response.get("instances")

    if return_raw:
        return open_instances

    if not open_instances:
        raise JupyterAPI_WorkspaceStarted(
            status=res.status,
            response="There are no open instances. Do you need to start the workspace?",
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
        )

    return parse_instance_service_location_and_prefix(
        open_instances[0], auth.domo_instance
    )

# %% ../../nbs/routes/jupyter.ipynb 10
@gd.route_function
async def get_jupyter_workspaces(
    auth: dmda.DomoAuth,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=1,
    debug_api: bool = False,
    debug_loop: bool = False,
):
    url = f"https://{auth.domo_instance}.domo.com/api/datascience/v1/search/workspaces"

    body = {
        "limit": 50,
        "offset": 0,
        "sortFieldMap": {"CREATED": "DESC"},
        "filters": [],
    }

    def arr_fn(res):
        return res.response["workspaces"]

    offset_params = {"limit": "limit", "offset": "offset"}

    res = await gd.looper(
        url=url,
        method="POST",
        limit=50,
        body=body,
        auth=auth,
        arr_fn=arr_fn,
        offset_params_in_body=True,
        offset_params=offset_params,
        parent_class=parent_class,
        session=session,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        debug_api=debug_api,
        debug_loop=debug_loop,
    )
    if not res.is_success:
        raise JupyterAPI_Error(
            status=res.status,
            response=res.response,
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/jupyter.ipynb 13
@gd.route_function
async def start_jupyter_workspace(
    workspace_id,
    auth: dmda.DomoAuth,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=1,
    debug_api: bool = False,
    return_raw: bool = False,
):
    url = f"https://{auth.domo_instance}.domo.com/api/datascience/v1/workspaces/{workspace_id}/instances"

    try:
        res = await gd.get_data(
            url=url,
            method="POST",
            auth=auth,
            parent_class=parent_class,
            session=session,
            num_stacks_to_drop=debug_num_stacks_to_drop,
            debug_api=debug_api,
        )

        if return_raw:
            return res

    except RuntimeError as e:
        return rgd.ResponseGetData(
            status=500,
            response=f"starting workspace, please wait - {e}",
            is_success=False,
        )

    if res.status == 500 or res.status == 403:
        raise JupyterAPI_Error(
            status=res.status,
            response=f"you may not have access to this workspace {workspace_id}, is it shared with you? || OR may already be started -- {res.response}",
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    if not res.is_success:
        raise JupyterAPI_Error(
            status=res.status,
            response=res.response,
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    res.response = "workspace started"
    return res

# %% ../../nbs/routes/jupyter.ipynb 15
@gd.route_function
async def get_jupyter_content(
    auth: dmda.DomoAuth,
    content_path: str = "",
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
):
    url = f"https://{auth.domo_instance}.{auth.service_location}{auth.service_prefix}api/contents/{content_path}"

    res = await gd.get_data(
        url=f"{url}",
        method="GET",
        auth=auth,
        headers={"authorization": f"Token {auth.jupyter_token}"},
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        session=session,
    )
    if not res.is_success:
        raise JupyterAPI_Error(
            status=res.status,
            response=res.response,
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/jupyter.ipynb 20
def generate_update_jupyter_body__new_content_path(content_path):
    if not content_path:
        return None

    if "/" in content_path:
        return "/".join(content_path.split("/")[:-1])
    else:
        return ""


def generate_update_jupyter_body__text(body, content_path=None):
    body.update(
        {
            "format": "text",
            "type": "file",
            "path": generate_update_jupyter_body__new_content_path(content_path),
        }
    )
    return body


def generate_update_jupyter_body__ipynb(body, content_path=None):

    body.update(
        {
            "format": None,
            "type": "notebook",
            "path": generate_update_jupyter_body__new_content_path(content_path),
        }
    )
    return body


def generate_update_jupyter_body__directory(content_path, body):
    body.update(
        {
            "path": generate_update_jupyter_body__new_content_path(content_path),
            "format": None,
            "type": "directory",
        }
    )
    return body

# %% ../../nbs/routes/jupyter.ipynb 21
class generate_update_jupyter_body_factory(Enum):
    IPYNB = partial(generate_update_jupyter_body__ipynb)
    DIRECTORY = partial(generate_update_jupyter_body__directory)
    TEXT = partial(generate_update_jupyter_body__text)

    @classmethod
    def from_text(cls, value):
        try:
            return cls[value.upper()].value
        except:
            return cls.TEXT.value


def generate_update_jupyter_body(
    new_content, content_path: str  # my_folder/datatypes.ipynb
):
    """factory to construct properly formed body"""

    content_name = os.path.normpath(content_path).split(os.sep)[-1]

    if "." in content_path:
        content_type = content_path.split(".")[-1]
    else:
        content_type = "directory"

    body = {
        "name": content_name,
        "content": new_content,
        "path": content_path,
    }
    return generate_update_jupyter_body_factory.from_text(content_type)(
        body=body, content_path=content_path
    )

# %% ../../nbs/routes/jupyter.ipynb 25
@gd.route_function
async def update_jupyter_file(
    auth: dmda.DomoJupyterAuth,
    new_content,
    content_path: str = "",  # file name and location in jupyter
    debug_api: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
    session: httpx.AsyncClient = None,
):
    dmda.test_is_jupyter_auth(auth)

    body = generate_update_jupyter_body(new_content, content_path)

    content_path_split = os.path.normpath(content_path).split(os.sep)

    url = f"https://{auth.domo_instance}.{auth.service_location}{auth.service_prefix}api/contents/{'/'.join(content_path_split)}"

    res = await gd.get_data(
        url=url,
        method="PUT",
        auth=auth,
        body=body,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
    )

    if not res.is_success:
        raise JupyterAPI_Error(
            status=res.status,
            response=res.response,
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/jupyter.ipynb 29
async def get_content_recursive(
    auth,
    all_rows,
    content_path,
    logs,
    res: rgd.ResponseGetData,
    obj: dict = None,
    is_recursive: bool = True,
    is_skip_recent_executions: bool = True,
    is_skip_default_files: bool = True,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=0,
    parent_class=None,
    session: httpx.AsyncClient = None,
):
    # set path (on initial execution there is no object)

    res = await get_jupyter_content(
        auth=auth,
        content_path=content_path,
        debug_api=debug_api,
        parent_class=parent_class,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop + 1,
        session=session,
    )
    if return_raw:
        return res

    obj = res.response
    obj_name = obj["name"]
    obj_type = obj["type"]
    obj_path = obj["path"]
    obj_content = obj["content"] or []

    s = {"content_path": obj_path, "type": obj_type, "name": obj_name}

    if (is_skip_recent_executions and obj_path.startswith("recent_executions")) or (
        is_skip_default_files and obj_path.startswith("domo_jupyter_examples")
    ):
        res.response = all_rows
        res.logs = logs
        return res

    all_rows.append(obj)
    s.update({"is_append": True})
    logs.append(s)

    res.response = all_rows
    res.logs = logs

    if obj["type"] != "directory":
        return res

    s.update({"content": len(obj_content), "all_rows": len(all_rows)})
    logs.append(s)

    res.response = all_rows
    res.logs = logs

    if not is_recursive:
        return res

    if len(obj_content) > 0:
        await ce.gather_with_concurrency(
            *[
                get_content_recursive(
                    auth=auth,
                    content_path=content["path"],
                    all_rows=all_rows,
                    logs=logs,
                    res=res,
                    is_skip_recent_executions=is_skip_recent_executions,
                    is_skip_default_files=is_skip_default_files,
                    debug_api=debug_api,
                    debug_num_stacks_to_drop=debug_num_stacks_to_drop + 1,
                    parent_class=parent_class,
                    session=session,
                )
                for content in obj_content
            ],
            n=5
        )

    return res

# %% ../../nbs/routes/jupyter.ipynb 30
@gd.route_function
async def get_content(
    auth: dmda.DomoJupyterAuth,
    content_path="",
    is_recursive: bool = True,
    is_skip_recent_executions: bool = True,
    is_skip_default_files: bool = True,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
):
    dmda.test_is_jupyter_auth(auth)

    all_rows = []
    logs = []
    res = None

    return await get_content_recursive(
        auth=auth,
        content_path=content_path,
        all_rows=all_rows,
        logs=logs,
        res=res,
        is_recursive=is_recursive,
        is_skip_recent_executions=is_skip_recent_executions,
        is_skip_default_files=is_skip_default_files,
        return_raw=return_raw,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        session=session,
    )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\page.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\page.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/page.ipynb.

# %% auto 0
__all__ = ['PageRetrieval_byId_Error', 'get_page_by_id', 'get_page_definition', 'get_page_access_test', 'get_page_access_list',
           'get_pages_adminsummary', 'update_page_layout', 'put_writelock', 'delete_writelock', 'add_page_owner']

# %% ../../nbs/routes/page.ipynb 2
import httpx
from typing import List
import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

# %% ../../nbs/routes/page.ipynb 5
class PageRetrieval_byId_Error(de.DomoError):
    def __init__(
        self,
        status,
        domo_instance,
        page_id,
        response,
        function_name=None,
        parent_class=None,
    ):
        super().__init__(
            status=status,
            function_name=function_name,
            parent_class=parent_class,
            message=f"failed to retrieve page_id: {page_id}",
            domo_instance=domo_instance,
        )

# %% ../../nbs/routes/page.ipynb 8
async def get_page_by_id(
    auth: dmda.DomoAuth,
    page_id: str,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    include_layout: bool = False,  # passes parameter to return page layout information
    debug_num_stacks_to_drop: int = 1,  # for traceback_details.  use 1 for route functions, 2 for class method
    parent_class: str = None,  # pass in self.__class__.__name__ into function
) -> (
    rgd.ResponseGetData
):  # returns ResponseGetData on success or raise Exception on error
    """retrieves a page or throws an error"""

    # 9/21/2023 - the domo UI uses /cards to get page info
    url = f"https://{auth.domo_instance}.domo.com/api/content/v3/stacks/{page_id}/cards"

    if include_layout:
        url += "?includeV4PageLayouts=true"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        session=session,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if (
        not res.is_success
        or not isinstance(res.response, dict)
        or not res.response.get("id", None)
    ):
        raise PageRetrieval_byId_Error(
            status=res.status,
            page_id=page_id,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            domo_instance=auth.domo_instance,
            response=res.response,
        )

    return res

# %% ../../nbs/routes/page.ipynb 12
async def get_page_definition(
    auth: dmda.DomoAuth,
    page_id: int,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v3/stacks/{page_id}/cards"

    params = {
        "includeV4PageLayouts": "true",
        "parts": "metadata,datasources,library,drillPathURNs,certification,owners,dateInfo,subscriptions,slicers",
    }

    res = await gd.get_data(
        url,
        method="GET",
        auth=auth,
        session=session,
        params=params,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if (
        not res.is_success
        or not isinstance(res.response, dict)
        or not res.response.get("id", None)
    ):
        raise PageRetrieval_byId_Error(
            status=res.status,
            page_id=page_id,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            domo_instance=auth.domo_instance,
            response=res.response,
        )

    return res

# %% ../../nbs/routes/page.ipynb 16
async def get_page_access_test(
    auth,
    page_id,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
):
    """retrieves accesslist, which users and groups a page is shared with"""
    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/pages/{page_id}/access"

    res = await gd.get_data(
        url,
        method="GET",
        auth=auth,
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    return res

# %% ../../nbs/routes/page.ipynb 19
async def get_page_access_list(
    auth,
    page_id,
    is_expand_users: bool = True,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
):
    """retrieves accesslist, which users and groups a page is shared with"""

    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/share/accesslist/page/{page_id}?expandUsers={is_expand_users}"

    res = await gd.get_data(
        url,
        method="GET",
        auth=auth,
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    res.response["explicitSharedUserCount"] = len(res.response.get("users"))
    for user in res.response.get("users"):
        user.update({"isExplicitShare": True})

    # add group members to users response
    if is_expand_users:
        group_users = [
            {**user, "isExplicitShare": False}
            for group in res.response.get("groups")
            for user in group.get("users")
        ]
        users = res.response.get("users") + [
            group_user
            for group_user in group_users
            if group_user.get("id")
            not in [user.get("id") for user in res.response.get("users")]
        ]
        res.response.update({"users": users})

    return res

# %% ../../nbs/routes/page.ipynb 22
async def get_pages_adminsummary(
    auth: dmda.DomoAuth,
    debug_loop: bool = False,
    debug_api: bool = False,
    limit=35,
    session: httpx.AsyncClient = None,
):
    """retrieves all pages in instance user is able to see (but may not have been explicitly shared)"""

    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/pages/adminsummary"

    offset_params = {
        "offset": "skip",
        "limit": "limit",
    }

    body = {"orderBy": "pageTitle", "ascending": True}

    def arr_fn(res) -> list[dict]:
        return res.response.get("pageAdminSummaries")

    res = await gd.looper(
        auth=auth,
        method="POST",
        url=url,
        arr_fn=arr_fn,
        offset_params=offset_params,
        session=session,
        loop_until_end=True,
        body=body,
        limit=limit,
        debug_loop=debug_loop,
        debug_api=debug_api,
    )
    return res

# %% ../../nbs/routes/page.ipynb 24
async def update_page_layout(
    auth: dmda.DomoAuth, layout_id: str, body: dict, debug_api: bool = False
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v4/pages/layouts/{layout_id}"

    res = await gd.get_data(
        auth=auth, url=url, body=body, method="PUT", debug_api=debug_api
    )

    if debug_api:
        print(res)

    return res


async def put_writelock(
    auth: dmda.DomoAuth,
    layout_id: str,
    user_id: str,
    epoch_time: int,
    debug_api: bool = False,
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v4/pages/layouts/{layout_id}/writelock"
    body = {
        "layoutId": layout_id,
        "lockHeartbeat": epoch_time,
        "lockTimestamp": epoch_time,
        "userId": user_id,
    }

    res = await gd.get_data(
        auth=auth, url=url, body=body, method="PUT", debug_api=debug_api
    )

    if debug_api:
        print(res)

    return res


async def delete_writelock(
    auth: dmda.DomoAuth, layout_id: str, debug_api: bool = False
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v4/pages/layouts/{layout_id}/writelock"
    res = await gd.get_data(auth=auth, url=url, method="DELETE", debug_api=debug_api)

    if debug_api:
        print(res)

    return res

# %% ../../nbs/routes/page.ipynb 25
async def add_page_owner(
    auth: dmda.DomoAuth,
    page_id_ls: List[int],
    group_id_ls: List[int],
    user_id_ls: List[int],
    note: str = "",
    send_email: bool = False,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/pages/bulk/owners"
    owners = []
    for group in group_id_ls:
        owners.append({"id": group, "type": "GROUP"})
    for user in user_id_ls:
        owners.append({"id": user, "type": "USER"})

    body = {
        "pageIds": page_id_ls,
        "owners": owners,
        "note": note,
        "sendEmail": send_email,
    }

    res = await gd.get_data(
        auth=auth,
        method="PUT",
        url=url,
        body=body,
        session=session,
        debug_api=debug_api,
    )
    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\pdp.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\pdp.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/pdp.ipynb.

# %% auto 0
__all__ = ['PDP_NotRetrieved', 'get_pdp_policies', 'SearchPDP_Error', 'search_pdp_policies_by_name',
           'generate_policy_parameter_simple', 'generate_policy_body', 'CreatePolicy_Error', 'create_policy',
           'update_policy', 'delete_policy', 'toggle_pdp']

# %% ../../nbs/routes/pdp.ipynb 2
import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

# %% ../../nbs/routes/pdp.ipynb 4
class PDP_NotRetrieved(de.DomoError):
    def __init__(
        self,
        domo_instance,
        function_name,
        status,
        message,
        pdp_id=None,
    ):

        super().__init__(
            domo_instance=domo_instance,
            entity_id=pdp_id,
            function_name=function_name,
            status=status,
            message=message,
        )

# %% ../../nbs/routes/pdp.ipynb 5
async def get_pdp_policies(
    auth: dmda.DomoAuth,
    dataset_id: str,
    debug_api: bool = False,
    include_all_rows: bool = True,
) -> rgd.ResponseGetData:
    url = f"http://{auth.domo_instance}.domo.com/api/query/v1/data-control/{dataset_id}/filter-groups/"

    if include_all_rows:
        url += "?options=load_associations,load_filters,include_open_policy"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        # headers= {'accept': 'application/json'},
        # params = {'options':'load_associations,load_filters,include_open_policy'},
        is_follow_redirects=True,
    )

    if len(res.response) == 0 or not res.is_success:
        raise PDP_NotRetrieved(
            domo_instance=auth.domo_instance,
            function_name="get_pdp_policies",
            status=res.status,
            message="failed to retrieve pdp policies",
        )

    return res

# %% ../../nbs/routes/pdp.ipynb 8
class SearchPDP_Error(de.DomoError):
    def __init__(
        self, status, message, domo_instance, function_name="search_pdp_by_name"
    ):
        super().__init__(
            function_name=function_name,
            status=status,
            message=message,
            domo_instance=domo_instance,
        )


def search_pdp_policies_by_name(
    # used to return pdp policy info, search by name
    search_name: str,
    result_list: list[
        dict
    ],  # this is the res.response from get_pdp_policies -- should be list of dict
    is_exact_match: bool = True,
):

    if is_exact_match:
        policy_search = next(
            (policy for policy in result_list if policy["name"] == search_name), None
        )
        # print(policy_search)

        if not policy_search:
            raise SearchPDP_Error(
                status="",
                message=f'There is no policy named "{search_name}"',
                domo_instance="",
            )

        return policy_search
    else:
        policy_search = [
            policy
            for policy in result_list
            if search_name.lower() in policy["name"].lower()
        ]
        if not policy_search:
            raise SearchPDP_Error(
                status="",
                message=f'There is no policy name containing "{search_name}"',
                domo_instance="",
            )

        return policy_search

# %% ../../nbs/routes/pdp.ipynb 12
def generate_policy_parameter_simple(
    column_name: str,
    type: str = "COLUMN",
    column_values_ls: list[str] = None,
    operator="EQUALS",
    ignore_case: bool = True,
):
    if not isinstance(column_values_ls, list):
        column_values_ls = [column_values_ls]

    return {
        "type": type,
        "name": column_name,
        "values": column_values_ls,
        "operator": operator,
        "ignoreCase": ignore_case,
    }

# %% ../../nbs/routes/pdp.ipynb 13
def generate_policy_body(
    policy_name: str,
    dataset_id: str,
    parameters_ls: list[dict],  # generated by generate_policy_parameter_simple method
    policy_id: str = None,  # only included if updating existing policy
    user_ids: list[str] = None,
    group_ids: list[str] = None,
    virtual_user_ids: list[str] = None,
):
    if not user_ids:
        user_ids = []

    if not group_ids:
        group_ids = []

    if not virtual_user_ids:
        virtual_user_ids = []

    if not isinstance(parameters_ls, list):
        parameters_ls = [parameters_ls]

    body = {
        "name": policy_name,
        "dataSourceId": dataset_id,
        "userIds": user_ids,
        "virtualUserIds": virtual_user_ids,
        "groupIds": group_ids,
        "dataSourcePermissions": False,
        "parameters": parameters_ls,
    }

    if policy_id:
        body.update({"filterGroupId": policy_id})

    return body

# %% ../../nbs/routes/pdp.ipynb 16
class CreatePolicy_Error(de.DomoError):
    def __init__(self, status, message, domo_instance, function_name="create_policy"):
        super().__init__(
            function_name=function_name,
            status=status,
            message=message,
            domo_instance=domo_instance,
        )


async def create_policy(
    auth: dmda.DomoAuth,
    dataset_id: str,
    body: dict,  # generated using generate_policy_parameter_simple & generate_policy_body
    session: httpx.AsyncClient = None,
    override_same_name: bool = False,
    debug_api: bool = False,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/query/v1/data-control/{dataset_id}/filter-groups"

    if debug_api:
        print(url)

    if override_same_name:
        print(f"Creating policy...")
        res = await gd.get_data(
            auth=auth,
            url=url,
            method="POST",
            body=body,
            debug_api=debug_api,
            session=session,
        )
    else:
        existing_policies = await get_pdp_policies(auth=auth, dataset_id=dataset_id)

        if existing_policies.is_success:
            try:
                policy_exists = search_pdp_policies_by_name(
                    search_name=body.get("name"),
                    result_list=existing_policies.response,
                    is_exact_match=True,
                )
            except:
                policy_exists = False

            if policy_exists:
                raise CreatePolicy_Error(
                    status="",
                    message=f'Policy name already exists--avoid creating pdp policies with the same name..To override, rerun and set "override_same_name=True"',
                    domo_instance=auth.domo_instance,
                )
            else:
                print(f"Creating policy...")
                res = await gd.get_data(
                    auth=auth,
                    url=url,
                    method="POST",
                    body=body,
                    debug_api=debug_api,
                    session=session,
                )

    return res

# %% ../../nbs/routes/pdp.ipynb 21
async def update_policy(
    auth: dmda.DomoAuth,
    dataset_id: str,
    policy_id: str,
    body: dict,  # generated using generate_policy_parameter_simple & generate_policy_body
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/query/v1/data-control/{dataset_id}/filter-groups/{policy_id}"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        debug_api=debug_api,
        session=session,
    )

    return res

# %% ../../nbs/routes/pdp.ipynb 25
async def delete_policy(
    auth: dmda.DomoAuth,
    dataset_id: str = None,
    policy_id: str = None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/query/v1/data-control/{dataset_id}/filter-groups/{policy_id}"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="DELETE",
        debug_api=debug_api,
        session=session,
    )

    return res

# %% ../../nbs/routes/pdp.ipynb 29
async def toggle_pdp(
    auth: dmda.DomoAuth,
    dataset_id: str,
    is_enable: bool = True,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:

    url = (
        f"https://{auth.domo_instance}.domo.com/api/query/v1/data-control/{dataset_id}"
    )

    if debug_api:
        print(url)

    body = {
        "enabled": is_enable,
        "external": False,  # not sure what this parameter does
    }

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        debug_api=debug_api,
        session=session,
    )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\publish.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\publish.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/publish.ipynb.

# %% auto 0
__all__ = ['GET_Publish_Error', 'search_publications', 'get_publication_by_id', 'generate_publish_body', 'create_publish_job',
           'udpate_publish_job', 'get_publish_subscriptions', 'get_subscription_summaries',
           'get_subscriber_content_details', 'get_subscription_invititations', 'accept_invite_by_id',
           'accept_invite_by_id_v2', 'refresh_publish_jobs']

# %% ../../nbs/routes/publish.ipynb 2
from typing import List
import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

# %% ../../nbs/routes/publish.ipynb 6
class GET_Publish_Error(de.DomoError):
    def __init__(
        self,
        status,
        message,
        domo_instance,
        function_name: str = None,
        parent_class: str = None,
    ):
        super().__init__(
            status=status,
            message=message,
            domo_instance=domo_instance,
            function_name=function_name,
            parent_class=parent_class,
        )

# %% ../../nbs/routes/publish.ipynb 7
async def search_publications(
    auth: dmda.DomoAuth,
    search_term: str = None,
    limit=100,
    offset=0,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/publish/v2/publication/summaries"

    params = {"limit": limit, "offset": offset}

    if search_term:
        params.update({"searchTerm": search_term})

    res = await gd.get_data(
        auth=auth,
        method="GET",
        url=url,
        params=params,
        session=session,
        debug_api=debug_api,
    )

    return res

# %% ../../nbs/routes/publish.ipynb 9
async def get_publication_by_id(
    auth: dmda.DomoAuth,
    publication_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    timeout=10,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/publish/v2/publication/{publication_id}"

    res = await gd.get_data(
        auth=auth,
        method="GET",
        url=url,
        session=session,
        timeout=timeout,
        debug_api=debug_api,
    )

    return res


# generate publish body

# %% ../../nbs/routes/publish.ipynb 11
def generate_publish_body(
    url: str,
    sub_domain_ls: List[str],
    content_ls: List[str],
    name: str,
    description: str,
    unique_id: str,
    is_new: bool,
):
    if not sub_domain_ls:
        sub_domain_ls = []

    if not content_ls:
        content_ls = []

    body = {
        "id": unique_id,
        "name": name,
        "description": description,
        "domain": url,
        "content": content_ls,
        "subscriberDomain": sub_domain_ls,
        "new": str(is_new).lower(),
    }

    return body

# %% ../../nbs/routes/publish.ipynb 13
# Creating publish job for a specific subscriber
async def create_publish_job(
    auth: dmda.DomoAuth,
    body: dict,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/publish/v2/publication"

    if debug_api:
        print(body)
    res = await gd.get_data(
        auth=auth,
        method="POST",
        url=url,
        body=body,
        session=session,
        debug_api=debug_api,
    )

    return res

# %% ../../nbs/routes/publish.ipynb 14
# Updating existing publish job with content
async def udpate_publish_job(
    auth: dmda.DomoAuth,
    publication_id: str,
    body: dict,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/publish/v2/publication/{publication_id}"

    res = await gd.get_data(
        auth=auth,
        method="PUT",
        url=url,
        body=body,
        session=session,
        debug_api=debug_api,
    )
    return res


# # finds all jobs waiting to be accepted within the subscriber

# %% ../../nbs/routes/publish.ipynb 16
@gd.route_function
async def get_publish_subscriptions(
    auth: dmda.DomoAuth,
    publish_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    """retrieves a summary of existing subscriptions"""
    url = f"https://{auth.domo_instance}.domo.com/api/publish/v2/publications/summaries/{publish_id}/subscriptions"

    res = await gd.get_data(
        auth=auth,
        method="GET",
        url=url,
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise GET_Publish_Error(
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/publish.ipynb 18
async def get_subscription_summaries(
    auth: dmda.DomoAuth, session: httpx.AsyncClient = None, debug_api: bool = False
) -> rgd.ResponseGetData:
    """retrieves a summary of existing subscriptions"""
    url = f"https://{auth.domo_instance}.domo.com/api/publish/v2/subscription/summaries"

    res = await gd.get_data(
        auth=auth, method="GET", url=url, session=session, debug_api=debug_api
    )
    return res

# %% ../../nbs/routes/publish.ipynb 21
@gd.route_function
async def get_subscriber_content_details(
    auth: dmda.DomoAuth,
    publication_id,
    subscriber_instance: str,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
):
    if not subscriber_instance.endswith(".domo.com"):
        subscriber_instance = f"{subscriber_instance}.domo.com"

    url = f"https://{auth.domo_instance}.domo.com/api/publish/v2/associations/{publication_id}/subscribers/{subscriber_instance}"

    res = await gd.get_data(
        method="get",
        url=url,
        auth=auth,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
    )

    if not res.is_success:
        raise GET_Publish_Error(
            status=res.status,
            message=res.response,
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/publish.ipynb 23
async def get_subscription_invititations(
    auth: dmda.DomoAuth, session: httpx.AsyncClient = None, debug_api: bool = False
) -> rgd.ResponseGetData:
    """retrieves a list of subscription invitations"""

    url = f"https://{auth.domo_instance}.domo.com/api/publish/v2/subscription/invites"

    res = await gd.get_data(
        auth=auth, method="GET", url=url, session=session, debug_api=debug_api
    )
    return res

# %% ../../nbs/routes/publish.ipynb 26
async def accept_invite_by_id(
    auth: dmda.DomoAuth,
    subscription_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    """this takes get_subscription_invites_list into account and accepts - not instant"""

    url = f"https://{auth.domo_instance}.domo.com/api/publish/v2/subscription/{subscription_id}"

    res = await gd.get_data(
        auth=auth, method="POST", url=url, session=session, debug_api=debug_api
    )
    return res

# %% ../../nbs/routes/publish.ipynb 27
async def accept_invite_by_id_v2(
    auth: dmda.DomoAuth,
    publication_id: str,
    owner_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    """this takes get_subscription_invites_list into account and accepts - not instant"""

    url = f"https://{auth.domo_instance}.domo.com/api/publish/v2/subscriptions/v2"

    body = {
        "publicationId": publication_id,
        "customerId": "",
        "domain": "",
        "groupIds": [],
        "userId": owner_id,
        "userIds": [],
    }

    res = await gd.get_data(
        auth=auth,
        method="POST",
        url=url,
        body=body,
        session=session,
        debug_api=debug_api,
    )
    return res

# %% ../../nbs/routes/publish.ipynb 28
async def refresh_publish_jobs(
    auth: dmda.DomoAuth,
    publish_ids: list,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    """Refreshing list of publish jobs. Typically "instance" = publisher instance"""

    url = f"https://{auth.domo_instance}.domo.com/api/publish/v2/publication/refresh"

    body = {"publicationIds": publish_ids}

    res = await gd.get_data(
        auth=auth,
        method="PUT",
        url=url,
        body=body,
        session=session,
        debug_api=debug_api,
    )
    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\role.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\role.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/role.ipynb.

# %% auto 0
__all__ = ['Role_NotRetrieved', 'Role_CRUD_Error', 'get_roles', 'get_role_by_id', 'get_role_grants', 'get_role_membership',
           'create_role', 'delete_role', 'get_default_role', 'set_default_role', 'update_role_metadata',
           'set_role_grants', 'role_membership_add_users']

# %% ../../nbs/routes/role.ipynb 2
import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

# %% ../../nbs/routes/role.ipynb 5
class Role_NotRetrieved(de.DomoError):
    def __init__(
        self,
        domo_instance,
        function_name,
        status,
        message,
        role_id=None,
        parent_class=None,
    ):
        super().__init__(
            domo_instance=domo_instance,
            entity_id=role_id,
            function_name=function_name,
            status=status,
            message=message,
            parent_class=parent_class,
        )


# | export
class Role_CRUD_Error(de.DomoError):
    def __init__(
        self,
        domo_instance,
        function_name,
        status,
        message,
        role_id=None,
        parent_class=None,
    ):
        super().__init__(
            domo_instance=domo_instance,
            entity_id=role_id,
            function_name=function_name,
            status=status,
            message=message,
            parent_class=parent_class,
        )

# %% ../../nbs/routes/role.ipynb 6
@gd.route_function
async def get_roles(
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/authorization/v1/roles"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        session=session,
    )

    if not res.is_success:
        raise Role_NotRetrieved(
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            status=res.status,
            message=res.response,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/role.ipynb 9
@gd.route_function
async def get_role_by_id(
    auth: dmda.DomoAuth,
    role_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/authorization/v1/roles/{role_id}"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise Role_NotRetrieved(
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            status=res.status,
            message=res.response,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/role.ipynb 11
@gd.route_function
async def get_role_grants(
    auth: dmda.DomoAuth,
    role_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/authorization/v1/roles/{role_id}/authorities"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if len(res.response) == 0:
        role_res = await get_roles(auth=auth)

        domo_role = [role for role in role_res.response if role.get("id") == role_id]

        if not domo_role:
            raise Role_NotRetrieved(
                domo_instance=auth.domo_instance,
                function_name=res.traceback_details.function_name,
                message=f"role {role_id} does not exist",
                status=res.status,
                parent_class=parent_class,
            )

    return res

# %% ../../nbs/routes/role.ipynb 14
@gd.route_function
async def get_role_membership(
    auth: dmda.DomoAuth,
    role_id: str,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/authorization/v1/roles/{role_id}/users"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if len(res.response.get("users")) == 0:
        role_res = await get_roles(auth)

        domo_role = next(
            (role for role in role_res.response if role.get("id") == role_id), None
        )

        if not domo_role:
            raise Role_NotRetrieved(
                domo_instance=auth.domo_instance,
                function_name=res.traceback_details.function_name,
                message=f"role {role_id} does not exist or cannot be retrieved",
                status=res.status,
                parent_class=parent_class,
            )

    if return_raw:
        return res

    res.response = res.response.get("users")

    return res

# %% ../../nbs/routes/role.ipynb 18
@gd.route_function
async def create_role(
    auth: dmda.DomoAuth,
    name: str,
    description: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/authorization/v1/roles"

    body = {"name": name, "description": description}

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="POST",
        body=body,
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise Role_CRUD_Error(
            domo_instance=auth.domo_auth,
            function_name=res.traceback_deails.function_name,
            status=res.status,
            message=res.response,
        )

    return res

# %% ../../nbs/routes/role.ipynb 19
@gd.route_function
async def delete_role(
    auth: dmda.DomoAuth,
    role_id: int,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/authorization/v1/roles/{role_id}"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="DELETE",
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise Role_CRUD_Error(
            domo_instance=auth.domo_auth,
            function_name=res.traceback_deails.function_name,
            status=res.status,
            message=res.response,
        )

    res.response = f"role {role_id} deleted or doesn't exist"

    return res

# %% ../../nbs/routes/role.ipynb 23
@gd.route_function
async def get_default_role(
    auth,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/customer-states/user.roleid.default"

    params = {"defaultValue": 2, "ignoreCache": True}

    res = await gd.get_data(
        auth=auth,
        method="GET",
        url=url,
        params=params,
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise Role_NotRetrieved(
            domo_instance=auth.domo_auth,
            function_name=res.traceback_deails.function_name,
            status=res.status,
            message=res.response,
        )

    res.response = res.response.get("value")

    return res

# %% ../../nbs/routes/role.ipynb 26
@gd.route_function
async def set_default_role(
    auth: dmda.DomoAuth,
    role_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class=None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/customer-states/user.roleid.default"

    body = {"name": "user.roleid.default", "value": role_id}

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        debug_api=debug_api,
        body=body,
        session=session,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise Role_CRUD_Error(
            domo_instance=auth.domo_auth,
            function_name=res.traceback_deails.function_name,
            status=res.status,
            message=res.response,
        )

    return res

# %% ../../nbs/routes/role.ipynb 28
@gd.route_function
async def update_role_metadata(
    auth: dmda.DomoAuth,
    role_id,
    role_name,
    role_description: str = None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
):
    url = f"https://{auth.domo_instance}.domo.com/api/authorization/v1/roles/{role_id}"

    body = {"name": role_name, "description": role_description, "id": role_id}

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise Role_CRUD_Error(
            domo_instance=auth.domo_auth,
            function_name=res.traceback_deails.function_name,
            status=res.status,
            message=res.response,
        )

    return res

# %% ../../nbs/routes/role.ipynb 31
@gd.route_function
async def set_role_grants(
    auth: dmda.DomoAuth,
    role_id: str,
    role_grant_ls: list[str],
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/authorization/v1/roles/{role_id}/authorities"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=role_grant_ls,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise Role_CRUD_Error(
            domo_instance=auth.domo_auth,
            function_name=res.traceback_deails.function_name,
            status=res.status,
            message=res.response,
        )

    return res

# %% ../../nbs/routes/role.ipynb 32
@gd.route_function
async def role_membership_add_users(
    auth: dmda.DomoAuth,
    role_id: str,
    user_list: list[str],  # list of user ids
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/authorization/v1/roles/{role_id}/users"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=user_list,
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise Role_CRUD_Error(
            domo_instance=auth.domo_auth,
            function_name=res.traceback_deails.function_name,
            status=res.status,
            message=res.response,
        )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\sandbox.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\sandbox.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/sandbox.ipynb.

# %% auto 0
__all__ = ['get_is_allow_same_instance_promotion_enabled', 'Sandbox_ToggleSameInstancePromotion_Error',
           'toggle_allow_same_instance_promotion', 'get_shared_repos', 'get_repo_from_id']

# %% ../../nbs/routes/sandbox.ipynb 2
import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

# %% ../../nbs/routes/sandbox.ipynb 4
@gd.route_function
async def get_is_allow_same_instance_promotion_enabled(
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient = None,
    return_raw: bool = False,
    debug_num_stacks_to_drop: int = 1,
    debug_api: bool = False,
    parent_class: str = None,
):
    url = f"https://{auth.domo_instance}.domo.com/api/version/v1/settings"

    res = await gd.get_data(
        auth=auth,
        method="GET",
        url=url,
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if return_raw:
        return res

    res.response = {
        "name": "allow_same_instance_promotion",
        "is_enabled": res.response["allowSelfPromotion"],
    }

    return res

# %% ../../nbs/routes/sandbox.ipynb 6
class Sandbox_ToggleSameInstancePromotion_Error(de.DomoError):
    def __init__(
        self, domo_instance, message, status, parent_class=None, function_name=None
    ):
        super().__init__(
            self,
            domo_instance=domo_instance,
            status=status,
            parent_class=parent_class,
            message=message,
            function_name=function_name,
        )


@gd.route_function
async def toggle_allow_same_instance_promotion(
    is_enabled: bool,
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop: int = 1,
    debug_api: bool = False,
    parent_class: str = None,
):
    url = f"https://{auth.domo_instance}.domo.com/api/version/v1/settings"

    body = {"allowSelfPromotion": is_enabled}

    res = await gd.get_data(
        auth=auth,
        method="POST",
        url=url,
        body=body,
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise Sandbox_ToggleSameInstancePromotion_Error(
            domo_instance=auth.domo_instance,
            message=res.response,
            status=res.status,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    return res

# %% ../../nbs/routes/sandbox.ipynb 8
@gd.route_function
async def get_shared_repos(
    auth: dmda.DomoAuth,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop: bool = False,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/version/v1/repositories/search"

    body = {
        "query": {
            "offset": 0,
            "limit": 50,
            "fieldSearchMap": {},
            "sort": "lastCommit",
            "order": "desc",
            "filters": {"userId": None},
            "dateFilters": {},
        },
        "shared": False,
    }

    res = await gd.get_data(
        auth=auth,
        method="POST",
        url=url,
        body=body,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    return res

# %% ../../nbs/routes/sandbox.ipynb 11
@gd.route_function
async def get_repo_from_id(
    auth: dmda.DomoFullAuth,
    repository_id: str,
    debug_api: bool = False,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:

    url = f"https://{auth.domo_instance}.domo.com/api/version/v1/repositories/{repository_id}"

    return await gd.get_data(
        auth=auth,
        method="GET",
        url=url,
        parent_class=parent_class,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        session=session,
    )

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\stream.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\stream.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/stream.ipynb.

# %% auto 0
__all__ = ['get_stream_by_id', 'update_stream', 'create_stream', 'execute_stream']

# %% ../../nbs/routes/stream.ipynb 2
import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda

# %% ../../nbs/routes/stream.ipynb 4
async def get_stream_by_id(
    auth: dmda.DomoAuth,
    stream_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/streams/{stream_id}"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        session=session,
        debug_api=debug_api,
    )
    return res


async def update_stream(
    auth: dmda.DomoAuth,
    stream_id: str,
    body: dict,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/streams/{stream_id}"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        body=body,
        method="PUT",
        session=session,
        debug_api=debug_api,
    )
    return res


async def create_stream(
    auth: dmda.DomoAuth,
    body: dict,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/streams"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        body=body,
        method="POST",
        session=session,
        debug_api=debug_api,
    )
    return res


async def execute_stream(
    auth: dmda.DomoAuth,
    stream_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/streams/{stream_id}/executions"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="POST",
        session=session,
        debug_api=debug_api,
    )
    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\user.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\user.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/user.ipynb.

# %% auto 0
__all__ = ['User_CrudError', 'GetUser_Error', 'ResetPassword_PasswordUsed', 'SearchUser_NoResults', 'DownloadAvatar_Error',
           'get_all_users', 'get_by_id', 'search_users', 'search_users_by_id', 'search_users_by_email',
           'search_virtual_user_by_subscriber_instance', 'create_user', 'set_user_landing_page', 'reset_password',
           'request_password_reset', 'UserProperty_Type', 'UserProperty', 'generate_patch_user_property_body',
           'update_user', 'download_avatar', 'generate_avatar_bytestr', 'upload_avatar', 'delete_user']

# %% ../../nbs/routes/user.ipynb 3
import os

from enum import Enum
from typing import List

import datetime as dt

import base64
import asyncio
import httpx


import domolibrary.utils.DictDot as dd
from domolibrary.utils.convert import test_valid_email
import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de

import domolibrary.utils.chunk_execution as ce
import domolibrary.utils.Image as uimg

# %% ../../nbs/routes/user.ipynb 6
class User_CrudError(de.DomoError):
    def __init__(
        self,
        domo_instance,
        function_name,
        status,
        message,
        parent_class=None,
        entity_id=None,
    ):
        super().__init__(
            domo_instance=domo_instance,
            function_name=function_name,
            status=status,
            message=message,
            entity_id=entity_id,
            parent_class=parent_class,
        )


class GetUser_Error(de.DomoError):
    def __init__(
        self, domo_instance, status, response, function_name=None, parent_class=None
    ):
        super().__init__(
            message=response,
            status=status,
            function_name=function_name,
            parent_class=parent_class,
            domo_instance=domo_instance,
        )


class ResetPassword_PasswordUsed(de.DomoError):
    def __init__(
        self,
        status,
        domo_instance,
        entity_id=None,
        message="Password used previously",
        function_name=None,
        parent_class=None,
    ):
        super().__init__(
            message=message,
            status=status,
            function_name=function_name,
            entity_id=entity_id,
            domo_instance=domo_instance,
            parent_class=parent_class,
        )


class SearchUser_NoResults(de.DomoError):
    def __init__(
        self,
        domo_instance,
        search_criteria=None,
        function_name=None,
        parent_class=None,
        status=None,
    ):
        search_str = f"- {search_criteria}" if search_criteria else ""

        super().__init__(
            message=f"query {search_str} returned no users",
            function_name=function_name,
            parent_class=parent_class,
            domo_instance=domo_instance,
            status=status,
        )


class DownloadAvatar_Error(de.DomoError):
    def __init__(
        self,
        status,
        response,
        user_id,
        domo_instance,
        function_name=None,
        parent_class=None,
    ):
        super().__init__(
            status=status,
            message=f"unable to download {user_id} - {response}",
            domo_instance=domo_instance,
            parent_class=parent_class,
            function_name=function_name,
        )

# %% ../../nbs/routes/user.ipynb 8
async def get_all_users(
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class=None,
) -> rgd.ResponseGetData:
    """retrieves all users from Domo"""
    url = f"https://{ auth.domo_instance}.domo.com/api/content/v2/users"

    res = await gd.get_data(
        url=url,
        method="GET",
        auth=auth,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise GetUser_Error(
            domo_instance=auth.domo_instance,
            status=res.status,
            response=res.response,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/user.ipynb 12
async def get_by_id(
    user_id,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop=1,
    parent_class=None,
):
    # does not include role_id
    v2_url = f"https://{auth.domo_instance}.domo.com/api/content/v2/users/{user_id}"

    v3_url = f"https://{auth.domo_instance}.domo.com/api/content/v3/users/{user_id}"

    params = {"includeDetails": True}

    res_v2, res_v3 = await asyncio.gather(
        gd.get_data(
            url=v2_url,
            method="GET",
            auth=auth,
            debug_api=debug_api,
            session=session,
            params=params,
            num_stacks_to_drop=debug_num_stacks_to_drop,
            parent_class=parent_class,
        ),
        gd.get_data(
            url=v3_url,
            method="GET",
            auth=auth,
            debug_api=debug_api,
            session=session,
            params=params,
            num_stacks_to_drop=debug_num_stacks_to_drop,
            parent_class=parent_class,
        ),
    )

    if return_raw:
        return res_v2, res_v3

    if res_v2.status == 200 and res_v2.response == "":
        raise SearchUser_NoResults(
            search_criteria=f"user_id {user_id} not found",
            domo_instance=auth.domo_instance,
            status=res_v2.status,
            function_name=f"{res_v2.traceback_details.function_name}-v2_url",
            parent_class=parent_class,
        )

    if not res_v2.is_success:
        raise GetUser_Error(
            domo_instance=auth.domo_instance,
            status=res_v2.status,
            response=res_v2.response,
            function_name=f"{res_v2.traceback_details.function_name}-v2_url",
            parent_class=parent_class,
        )

    if res_v3.status == "404" and res_v3.response == "Not Found":
        raise SearchUser_NoResults(
            domo_instance=auth.domo_instance,
            status=res_v3.status,
            search_criteria=f"user_id {user_id} not found",
            function_name=f"{res_v3.traceback_details.function_name}-v3_url",
            parent_class=parent_class,
        )
    if (
        not res_v3.status == "404" and not res_v3.response == "Not Found"
    ) and not res_v3.is_success:
        raise GetUser_Error(
            domo_instance=auth.domo_instance,
            status=res_v3.status,
            response=res_v3.response,
            function_name=f"{res_v3.traceback_details.function_name}-v3_url",
            parent_class=parent_class,
        )

    res_v2.response.update({"roleId": res_v3.response.get("roleId")})

    return res_v2

# %% ../../nbs/routes/user.ipynb 17
def process_v1_search_users(
    v1_user_ls: list[dict],  # list of users from v1_users_search API
) -> list[dict]:  # sanitized list of users.
    """sanitizes the response from v1_users_search API and removes unecessary attributes"""

    clean_users = []

    for obj_user in v1_user_ls:
        dd_user = dd.DictDot(obj_user)

        clean_users.append(
            {
                "id": dd_user.id,
                "displayName": dd_user.displayName,
                "roleId": dd_user.roleId,
                "userName": dd_user.userName,
                "emailAddress": dd_user.emailAddress,
            }
        )

    return clean_users

# %% ../../nbs/routes/user.ipynb 18
async def search_users(
    auth: dmda.DomoAuth,
    body: dict,
    loop_until_end: bool = True,  # retrieve all available rows
    limit=200,  # maximum rows to return per request.  refers to PAGINATION
    maximum=100,  # equivalent to the LIMIT or TOP clause in SQL, the number of rows to return total
    suppress_no_results_error: bool = False,
    debug_api: bool = False,
    return_raw: bool = False,
    debug_loop: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class=None,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/identity/v1/users/search"

    offset_params = {"offset": "offset", "limit": "limit"}

    def body_fn(skip, limit, body):
        return {**body, "limit": limit, "offset": skip}

    def arr_fn(res: rgd.ResponseGetData):
        return res.response.get("users")

    res = await gd.looper(
        auth=auth,
        method="POST",
        url=url,
        maximum=maximum,
        limit=limit,
        offset_params=offset_params,
        offset_params_in_body=True,
        loop_until_end=loop_until_end,
        arr_fn=arr_fn,
        body_fn=body_fn,
        body=body,
        debug_api=debug_api,
        debug_loop=debug_loop,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        session=session,
    )

    if return_raw:
        return res

    if not res.is_success:
        raise GetUser_Error(
            domo_instance=auth.domo_instance,
            status=res.status,
            response=res.response,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    if not suppress_no_results_error and len(res.response) == 0:
        raise SearchUser_NoResults(
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    res.response = process_v1_search_users(res.response)

    return res

# %% ../../nbs/routes/user.ipynb 19
async def search_users_by_id(
    user_ids: list[str],  # list of user ids to search
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    return_raw: bool = False,
    suppress_no_results_error: bool = False,
    debug_num_stacks_to_drop=2,
    parent_class=None,
) -> dict:  # dict to pass to search v1_users_search_api
    """search v1_users_search_api"""

    user_cn = ce.chunk_list(user_ids, 1000)

    res_ls = await ce.gather_with_concurrency(
        n=6,
        *[
            search_users(
                auth=auth,
                body={
                    # "showCount": true,
                    # "count": false,
                    "includeDeleted": False,
                    "includeSupport": False,
                    "filters": [
                        {
                            "field": "id",
                            "filterType": "value",
                            "values": user_ls,
                            "operator": "EQ",
                        }
                    ],
                },
                debug_api=debug_api,
                return_raw=return_raw,
                suppress_no_results_error=suppress_no_results_error,
                debug_num_stacks_to_drop=debug_num_stacks_to_drop,
                parent_class=parent_class,
            )
            for user_ls in user_cn
        ]
    )

    res = res_ls[-1]

    res.response = [row for ls in [_.response for _ in res_ls] for row in ls]

    return res

# %% ../../nbs/routes/user.ipynb 20
async def search_users_by_email(
    user_email_ls: list[
        str
    ],  # list of user emails to search.  Note:  search does not appear to be case sensitive
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    return_raw: bool = False,
    suppress_no_results_error: bool = False,
    debug_num_stacks_to_drop=2,
    parent_class=None,
) -> dict:  # dict to pass to search v1_users_search_api
    """search v1_users_search_api"""

    user_cn = ce.chunk_list(user_email_ls, 1000)

    res_ls = await ce.gather_with_concurrency(
        n=10,
        *[
            search_users(
                auth=auth,
                body={
                    # "showCount": true,
                    # "count": false,
                    "includeDeleted": False,
                    "includeSupport": False,
                    "limit": 200,
                    "offset": 0,
                    "sort": {"field": "displayName", "order": "ASC"},
                    "filters": [
                        {
                            "filterType": "text",
                            "field": "emailAddress",
                            "text": " ".join(user_ls),
                        }
                    ],
                },
                debug_api=debug_api,
                return_raw=return_raw,
                suppress_no_results_error=suppress_no_results_error,
                debug_num_stacks_to_drop=debug_num_stacks_to_drop,
                parent_class=parent_class,
            )
            for user_ls in user_cn
        ]
    )

    res = res_ls[-1]

    res.response = [row for ls in [_.response for _ in res_ls] for row in ls]
    return res

# %% ../../nbs/routes/user.ipynb 24
async def search_virtual_user_by_subscriber_instance(
    auth: dmda.DomoAuth,  # domo auth object
    subscriber_instance_ls: list[str],  # list of subscriber domo instances
    debug_api: bool = False,  # debug API requests
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
) -> rgd.ResponseGetData:  # list of virtual domo users
    """retrieve virtual users for subscriber instances tied to one publisher"""

    url = f"https://{auth.domo_instance}.domo.com/api/publish/v2/proxy_user/domain/"

    body = {
        "domains": [
            f"{subscriber_instance}.domo.com"
            for subscriber_instance in subscriber_instance_ls
        ]
    }

    return await gd.get_data(
        url=url,
        method="POST",
        auth=auth,
        body=body,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

# %% ../../nbs/routes/user.ipynb 28
async def create_user(
    auth: dmda.DomoAuth,
    display_name: str,
    email_address: str,
    role_id: int,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    debug_num_stacks_to_drop: int = 1,
    parent_class: str = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/content/v3/users"

    test_valid_email(email_address)

    body = {
        "displayName": display_name,
        "detail": {"email": email_address},
        "roleId": role_id,
    }

    res = await gd.get_data(
        url=url,
        method="POST",
        body=body,
        auth=auth,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        session=session,
    )

    if res.status == 400 and res.response == "Bad Request":
        raise User_CrudError(
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            status=res.status,
            message=f"{res.response} - does this user (email) already exist?",
        )

    if not res.is_success:
        raise User_CrudError(
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            status=res.status,
            message=res.response,
        )

    res.is_success = True
    return res

# %% ../../nbs/routes/user.ipynb 31
async def set_user_landing_page(
    auth: dmda.DomoAuth,
    user_id: str,
    page_id: str,
    debug_api: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/landings/target/DESKTOP/entity/PAGE/id/{page_id}/{user_id}"

    res = await gd.get_data(
        url=url,
        method="PUT",
        auth=auth,
        # body = body,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
    )

    if not res.is_success:
        raise User_CrudError(
            domo_instance=auth.domo_instance,
            entity_id=user_id,
            status=res.status,
            message=res.response,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/user.ipynb 32
async def reset_password(
    auth: dmda.DomoAuth,
    user_id: str,
    new_password: str,
    debug_api: bool = False,
    parent_class=None,
    debug_num_stacks_to_drop=1,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/identity/v1/password"

    body = {"domoUserId": user_id, "password": new_password}

    res = await gd.get_data(
        url=url,
        method="PUT",
        auth=auth,
        body=body,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if (
        res.status == 200
        and res.response.get("description", None)
        == "Password has been used previously."
    ):
        raise ResetPassword_PasswordUsed(
            status=res.status,
            entity_id=user_id,
            domo_instance=auth.domo_instance,
            message=res.response["description"].replace(".", ""),
        )

    return res

# %% ../../nbs/routes/user.ipynb 35
async def request_password_reset(
    domo_instance: str,
    email: str,
    locale="en-us",
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
):
    url = f"https://{domo_instance}.domo.com/api/domoweb/auth/sendReset"

    params = {"email": email, "local": locale}

    return await gd.get_data(
        url=url,
        method="GET",
        params=params,
        auth=None,
        debug_api=debug_api,
        session=session,
    )

# %% ../../nbs/routes/user.ipynb 37
class UserProperty_Type(Enum):
    display_name = "displayName"
    email_address = "emailAddress"
    phone_number = "phoneNumber"
    title = "title"
    department = "department"
    web_landing_page = "webLandingPage"
    web_mobile_landing_page = "webMobileLandingPage"
    role_id = "roleId"
    employee_id = "employeeId"
    employee_number = "employeeNumber"
    hire_date = "hireDate"
    reports_to = "reportsTo"


class UserProperty:
    property_type: UserProperty_Type
    values: str

    def __init__(self, property_type: UserProperty_Type, values: list):
        self.property_type = property_type
        self.values = self._value_to_list(values)

    @staticmethod
    def _value_to_list(values):
        return values if isinstance(values, list) else [values]

    def to_json(self):
        return {
            "key": self.property_type.value,
            "values": self._value_to_list(self.values),
        }

# %% ../../nbs/routes/user.ipynb 39
def generate_patch_user_property_body(user_property_ls: List[UserProperty]):
    return {
        "attributes": [user_property.to_json() for user_property in user_property_ls]
    }

# %% ../../nbs/routes/user.ipynb 42
async def update_user(
    user_id: str,
    user_property_ls: List[UserProperty],
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
    debug_num_stacks_to_drop: int = 1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/identity/v1/users/{user_id}"

    body = (
        generate_patch_user_property_body(user_property_ls)
        if isinstance(user_property_ls[0], UserProperty)
        else user_property_ls
    )

    res = await gd.get_data(
        url=url,
        method="PATCH",
        auth=auth,
        body=body,
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise User_CrudError(
            domo_instance=auth.domo_instance,
            entity_id=user_id,
            status=res.status,
            message=res.response,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/user.ipynb 46
@gd.route_function
async def download_avatar(
    user_id,
    auth: dmda.DomoAuth,
    pixels: int = 300,
    folder_path="./images",
    img_name=None,
    is_download_image: bool = True,
    debug_api: bool = False,
    return_raw: bool = False,
    parent_class: str = None,
    debug_num_stacks_to_drop=1,
    session: httpx.AsyncClient = None,
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/avatar/USER/{user_id}?size={pixels}"

    res = await gd.get_data_stream(
        url=url,
        method="GET",
        auth=auth,
        debug_api=debug_api,
        headers={"accept": "image/png;charset=utf-8"},
        num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=parent_class,
        session=session,
    )

    if return_raw:
        return res

    if res.status != 200:
        raise DownloadAvatar_Error(
            status=res.status,
            response=res.response,
            user_id=user_id,
            domo_instance=auth.domo_instance,
            parent_class=parent_class,
            function_name=res.traceback_details.function_name,
        )

    if is_download_image:
        if not os.path.exists(folder_path):
            os.mkdir(folder_path)

        if img_name:
            img_name = img_name.replace(".png", "")

        img_name = f"{img_name or user_id}.png"

        file_path = os.path.join(folder_path, img_name)

        with open(file_path, "wb") as out_file:
            out_file.write(res.response)

    res.is_success = True

    return res

# %% ../../nbs/routes/user.ipynb 49
def generate_avatar_bytestr(img_bytestr, img_type):
    if isinstance(img_bytestr, str):
        img_bytestr = img_bytestr.encode("utf-8")

    if not uimg.isBase64(img_bytestr):
        img_bytestr = base64.b64encode(img_bytestr)

    img_bytestr = img_bytestr.decode("utf-8")

    html_encoding = f"data:image/{img_type};base64,"

    if not img_bytestr.startswith(html_encoding):
        img_bytestr = html_encoding + img_bytestr

    return img_bytestr


@gd.route_function
async def upload_avatar(
    auth: dmda.DomoAuth,
    user_id: int,
    img_bytestr: bytes,
    img_type: str,  #'jpg or png'
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    session: httpx.AsyncClient = None,
    parent_class: str = None,
):
    url = f"https://{auth.domo_instance}.domo.com/api/content/v1/avatar/bulk"

    body = {
        "base64Image": generate_avatar_bytestr(img_bytestr, img_type),
        "encodedImage": generate_avatar_bytestr(img_bytestr, img_type),
        "isOpen": False,
        "entityIds": [user_id],
        "entityType": "USER",
    }

    # return body

    res = await gd.get_data(
        url=url,
        method="POST",
        body=body,
        session=session,
        debug_api=debug_api,
        num_stacks_to_drop=debug_num_stacks_to_drop,
        auth=auth,
        parent_class=None,
    )

    if not res.is_success:
        raise User_CrudError(
            domo_instance=auth.domo_instance,
            entity_id=user_id,
            status=res.status,
            message=res.response,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
        )

    return res

# %% ../../nbs/routes/user.ipynb 52
async def delete_user(
    auth: dmda.DomoAuth,
    user_id: str,
    debug_api: bool = False,
    debug_num_stacks_to_drop=1,
    parent_class: str = None,
    session: httpx.AsyncClient = None,
) -> rgd.ResponseGetData:
    url = f"https://{auth.domo_instance}.domo.com/api/identity/v1/users/{user_id}"

    if debug_api:
        print(url)

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="DELETE",
        debug_api=debug_api,
        session=session,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )
    if not res.is_success:
        raise User_CrudError(
            domo_instance=auth.domo_instance,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            status=res.status,
            message=res.response,
        )

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\routes\user_attributes.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\routes\user_attributes.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/user_attributes.ipynb.

# %% auto 0
__all__ = ['UserAttributes_IssuerType', 'UserAttributes_GET_Error', 'UserAttributes_CRUD_Error', 'get_user_attributes',
           'get_user_attribute_by_id', 'clean_attribute_id', 'generate_create_user_attribute_body',
           'create_user_attribute', 'update_user_attribute', 'delete_user_attribute']

# %% ../../nbs/routes/user_attributes.ipynb 2
from enum import Enum
from typing import List

import datetime as dt

import re

import httpx
import domolibrary.client.get_data as gd
import domolibrary.client.DomoError as de

import domolibrary.client.DomoAuth as dmda

# %% ../../nbs/routes/user_attributes.ipynb 4
class UserAttributes_IssuerType(Enum):
    IDP = "idp"
    SYSTEM = "domo-defined"
    CUSTOM = "customer-defined"


class UserAttributes_GET_Error(de.DomoError):
    def __init__(
        self,
        status,
        message,
        domo_instance,
        parent_class: str = None,
        function_name: str = None,
    ):
        super().__init__(
            status=status,
            message=message,
            parent_class=parent_class,
            domo_instance=domo_instance,
            function_name=function_name,
        )


class UserAttributes_CRUD_Error(de.DomoError):
    def __init__(
        self,
        status,
        message,
        domo_instance,
        parent_class: str = None,
        function_name: str = None,
    ):
        super().__init__(
            status=status,
            message=message,
            parent_class=parent_class,
            domo_instance=domo_instance,
            function_name=function_name,
        )

# %% ../../nbs/routes/user_attributes.ipynb 6
@gd.route_function
async def get_user_attributes(
    auth: dmda.DomoAuth,
    issuer_type_ls: List[
        UserAttributes_IssuerType
    ] = None,  # use `UserAttributes_IssuerType` enum
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    """retrieves user attributes from Domo
    user attributes can be `UserAttributes_IssuerType` -- idp, domo, or user-generated
    API does not filter on the issuer type (despite API accepting filter parameter)
    """
    issuer_type_ls = issuer_type_ls or [member for member in UserAttributes_IssuerType]

    issuer_types = ",".join([member.value for member in issuer_type_ls])

    params = {"issuerTypes": issuer_types}

    url = f"https://{auth.domo_instance}.domo.com/api/user/v1/properties/meta/keys"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="GET",
        params=params,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise UserAttributes_GET_Error(
            status=res.status,
            message=res.response,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            domo_instance=auth.domo_instance,
        )

    res.response = [
        obj
        for obj in res.response
        if obj["keyspace"] in [member.value for member in issuer_type_ls]
    ]

    return res

# %% ../../nbs/routes/user_attributes.ipynb 9
@gd.route_function
async def get_user_attribute_by_id(
    auth: dmda.DomoAuth,
    attribute_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    """retrieves user attributes from Domo
    user attributes can be `UserAttributes_IssuerType` -- idp, domo, or user-generated
    API does not filter on the issuer type (despite API accepting filter parameter)
    """

    res = await get_user_attributes(auth=auth, session=session)

    if not res.is_success:
        raise UserAttributes_GET_Error(
            status=res.status,
            message=res.response,
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            domo_instance=auth.domo_instance,
        )

    res.response = next(
        (obj for obj in res.response if obj["key"] == attribute_id), None
    )

    if not res.response:
        raise UserAttributes_GET_Error(
            status=res.status,
            message=f"attribute {attribute_id} not found",
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            domo_instance=auth.domo_instance,
        )

    return res

# %% ../../nbs/routes/user_attributes.ipynb 12
def clean_attribute_id(text):
    return re.sub(r"[^A-Za-z0-9]", "", text)

# %% ../../nbs/routes/user_attributes.ipynb 13
def generate_create_user_attribute_body(
    attribute_id: str,
    name: str = None,
    description: str = None,
    issuer_type: UserAttributes_IssuerType = None,
    security_voter: str = None,
    data_type: str = None,
):
    s = {"key": attribute_id}

    if issuer_type:
        s.update({"keyspace": issuer_type.value})

    if security_voter:
        s.update({"securityVoter": security_voter})

    if data_type:
        s.update({"validator": data_type})

    if name:
        s.update({"title": name})

    if description:
        s.update({"description": description})

    return s


@gd.route_function
async def create_user_attribute(
    auth: dmda.DomoAuth,
    attribute_id,
    name=None,
    description=None,
    data_type: str = None,
    security_voter=None,
    issuer_type: UserAttributes_IssuerType = None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    name = name or attribute_id
    attribute_id = clean_attribute_id(attribute_id)
    description = (
        description
        or f"updated via domolibrary {dt.datetime.now().strftime('%Y-%m-%d - %H:%M')}"
    )
    data_type = data_type or "ANY_VALUE"
    security_voter = security_voter or "FULL_VIS_ADMIN_IDP"
    issuer_type = issuer_type or UserAttributes_IssuerType.CUSTOM

    body = generate_create_user_attribute_body(
        attribute_id=attribute_id,
        issuer_type=issuer_type,
        name=name,
        data_type=data_type,
        security_voter=security_voter,
        description=description,
    )

    url = f"https://{auth.domo_instance}.domo.com/api/user/v1/properties/meta/keys/{attribute_id}"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="POST",
        body=body,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise UserAttributes_CRUD_Error(
            status=res.status,
            message=f"Bad Request - does attribute {attribute_id} already exist?",
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            domo_instance=auth.domo_instance,
        )

    res.response = f"created {attribute_id}"

    return res

# %% ../../nbs/routes/user_attributes.ipynb 15
@gd.route_function
async def update_user_attribute(
    auth: dmda.DomoAuth,
    attribute_id,
    name=None,
    description=None,
    issuer_type: UserAttributes_IssuerType = UserAttributes_IssuerType.CUSTOM,
    data_type: str = None,
    security_voter=None,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    """body must include all attribute parameters,
    this route wil use the `get_user_attribute_by_id` function to retrieve existing values (and throw an error if not found)
    to construct an update statement"""

    body = generate_create_user_attribute_body(
        attribute_id=attribute_id,
        issuer_type=issuer_type,
        name=name,
        description=description,
        data_type=data_type,
        security_voter=security_voter,
    )

    res = await get_user_attribute_by_id(attribute_id=attribute_id, auth=auth)

    body = {**res.response, **body}

    url = f"https://{auth.domo_instance}.domo.com/api/user/v1/properties/meta/keys/{attribute_id}"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="PUT",
        body=body,
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise UserAttributes_CRUD_Error(
            status=res.status,
            message=f"Bad Request - error updating {attribute_id}",
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            domo_instance=auth.domo_instance,
        )

    res.response = f"updated {attribute_id}"

    return res

# %% ../../nbs/routes/user_attributes.ipynb 18
@gd.route_function
async def delete_user_attribute(
    auth: dmda.DomoAuth,
    attribute_id,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    parent_class=None,
    debug_num_stacks_to_drop=1,
):
    url = f"https://{auth.domo_instance}.domo.com/api/user/v1/properties/meta/keys/{attribute_id}"

    res = await gd.get_data(
        auth=auth,
        url=url,
        method="DELETE",
        session=session,
        debug_api=debug_api,
        parent_class=parent_class,
        num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if not res.is_success:
        raise UserAttributes_CRUD_Error(
            status=res.status,
            message=f"Bad Request - failed to delete {attribute_id}",
            function_name=res.traceback_details.function_name,
            parent_class=parent_class,
            domo_instance=auth.domo_instance,
        )

    res.response = f"deleted {attribute_id}"

    return res

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\utils\chunk_execution.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\utils\chunk_execution.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/utils/chunk_execution.ipynb.

# %% auto 0
__all__ = ['gather_with_concurrency', 'run_sequence', 'chunk_list']

# %% ../../nbs/utils/chunk_execution.ipynb 2
from typing import Any, Awaitable
import asyncio

# %% ../../nbs/utils/chunk_execution.ipynb 3
async def gather_with_concurrency(
    *coros,  # list of coroutines to await
    n=60,  # number of open coroutines
):
    """limits the number of open coroutines at a time."""

    semaphore = asyncio.Semaphore(n)

    async def sem_coro(coro):
        async with semaphore:
            return await coro

    return await asyncio.gather(*(sem_coro(c) for c in coros))

# %% ../../nbs/utils/chunk_execution.ipynb 6
async def run_sequence(
    *functions: Awaitable[Any],  # comma separated list of functions
) -> None:  # no explicit return
    """executes a sequence of functions"""

    return [await function for function in functions]

# %% ../../nbs/utils/chunk_execution.ipynb 9
def chunk_list(
    obj_ls: list[any],  # list of entities to split into n chunks
    chunk_size: int,  # entities per sub list
) -> list[list[dict]]:  # returns a list of chunk_size lists of objects

    return [
        obj_ls[i * chunk_size : (i + 1) * chunk_size]
        for i in range((len(obj_ls) + chunk_size - 1) // chunk_size)
    ]

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\utils\convert.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\utils\convert.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/utils/convert.ipynb.

# %% auto 0
__all__ = ['convert_epoch_millisecond_to_datetime', 'convert_datetime_to_epoch_millisecond', 'convert_string_to_datetime',
           'convert_snake_to_pascal', 'convert_str_to_snake_case', 'InvalidEmail', 'test_valid_email',
           'convert_string_to_bool', 'ConcatDataframe_InvalidElement', 'concat_list_dataframe']

# %% ../../nbs/utils/convert.ipynb 2
import datetime as dt
from dateutil import parser
import pandas as pd
import re

# %% ../../nbs/utils/convert.ipynb 5
def convert_epoch_millisecond_to_datetime(epoch: int):
    """convert Epoch time with miliseconds to Date time"""
    return dt.datetime.fromtimestamp(epoch / 1000.0) if epoch else None

# %% ../../nbs/utils/convert.ipynb 6
def convert_datetime_to_epoch_millisecond(datetime: dt.datetime):
    """convert DateTime to Epoch time with Miliseconds"""
    return int(datetime.timestamp() * 1000) if datetime else None

# %% ../../nbs/utils/convert.ipynb 9
def convert_string_to_datetime(datestr: str) -> dt.datetime:
    if not datestr:
        return None
    return parser.parse(datestr)

# %% ../../nbs/utils/convert.ipynb 12
def convert_snake_to_pascal(clean_str):
    """converts 'snake_case_str' to 'snakeCaseStr'"""

    clean_str = clean_str.replace("_", " ").title().replace(" ", "")
    return clean_str[0].lower() + clean_str[1:]

# %% ../../nbs/utils/convert.ipynb 15
def convert_str_to_snake_case(text_str, is_only_alphanumeric: bool = False):
    """converts 'snake_case_str' to 'snakeCaseStr'"""

    text_str = text_str.replace(" ", "_").lower()

    if is_only_alphanumeric:
        text_str = re.sub(r"\W+", "", text_str)

    return text_str

# %% ../../nbs/utils/convert.ipynb 17
class InvalidEmail(Exception):
    def __init__(self, email):

        super().__init__(f'invalid email: "{email}" provided')


def test_valid_email(email):
    """tests if provided string is a for valid email"""

    pattern = r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,7}\b"

    # pass the regular expression
    # and the string into the fullmatch() method
    if re.fullmatch(pattern, email):
        return True

    else:
        raise InvalidEmail(email=email)

# %% ../../nbs/utils/convert.ipynb 20
def convert_string_to_bool(v):
    return v.lower() in ("yes", "true", "t", "1")

# %% ../../nbs/utils/convert.ipynb 22
class ConcatDataframe_InvalidElement(Exception):
    def __init__(self, elem):
        message = f"{type(elem)} passed into dataframe"
        super().__init__(message)


def concat_list_dataframe(df_ls: list[pd.DataFrame]) -> pd.DataFrame:
    """take a list of dataframes and collapse into one dataframe"""

    df = None
    for elem in df_ls:
        if not isinstance(elem, pd.DataFrame):
            raise ConcatDataframe_InvalidElement(elem)

        if len(elem.index) == 0:
            pass

        if df is None:
            df = elem

        else:
            df = pd.concat([df, elem], join="inner").reset_index(drop=True)
    return df

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\utils\DictDot.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\utils\DictDot.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/utils/DictDot.ipynb.

# %% auto 0
__all__ = ['DictDot', 'split_str_to_obj']

# %% ../../nbs/utils/DictDot.ipynb 3
from types import SimpleNamespace

# %% ../../nbs/utils/DictDot.ipynb 4
class DictDot(SimpleNamespace):
    """a utility class that converts json into an object that supports data retrieval with dot notation"""

    def __init__(self, dictionary: dict, **kwargs):  # dictionary to convert
        super().__init__(**kwargs)

        for key, value in dictionary.items():
            if isinstance(value, dict):
                self.__setattr__(key, DictDot(value))
            elif isinstance(value, list):
                new_list = []
                for item in value:
                    if isinstance(item, dict):
                        new_list.append(DictDot(item))
                    else:
                        new_list.append(item)
                self.__setattr__(key, new_list)
            else:
                self.__setattr__(key, value)

    def __getattr__(self, item):
        return None

# %% ../../nbs/utils/DictDot.ipynb 7
def split_str_to_obj(piped_str: str, key_ls: list[str]):
    """
    split a pipe separated list into an object with keys defined by the list of keys
    ex. "test_instance|myemail|sample_password", ["domo_instance", "domo_username", "domo_password"] = {"domo_instance" : "test_intance" , "domo_username" : "myemail", "domo_password":"sample_password"}
    """
    str_ls = piped_str.split("|")
    obj = dict([new_obj_key, str_ls[index]] for index, new_obj_key in enumerate(key_ls))

    return DictDot(obj)

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\utils\files.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\utils\files.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/utils/files.ipynb.

# %% auto 0
__all__ = ['upsert_folder', 'change_extension']

# %% ../../nbs/utils/files.ipynb 2
import os
import pathlib

# %% ../../nbs/utils/files.ipynb 3
def upsert_folder(folder_path: str, debug_prn: bool = False):
    folder_path = os.path.dirname(folder_path)

    if debug_prn:
        print(
            {
                "upsert_folder": os.path.abspath(folder_path),
                "is_exist": os.path.exists(folder_path),
            }
        )

    if not os.path.exists(folder_path):
        os.makedirs(folder_path)

# %% ../../nbs/utils/files.ipynb 5
def change_extension(file_path, new_extension):
    path = pathlib.PurePath(file_path)
    new_file_path = path.with_suffix("." + new_extension)
    return str(new_file_path)

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\utils\Image.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\utils\Image.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/utils/Image.ipynb.

# %% auto 0
__all__ = ['domo_default_img', 'isBase64', 'handle_string_to_bytes_and_decode', 'handle_string_to_bytes_and_encode', 'to_bytes',
           'crop_square', 'are_same_image']

# %% ../../nbs/utils/Image.ipynb 2
from PIL.Image import Image

# %% ../../nbs/utils/Image.ipynb 3
from typing import Union
import types
import PIL
import numpy as np

import os
import io
import base64

from nbdev.showdoc import patch_to

# %% ../../nbs/utils/Image.ipynb 4
def isBase64(s):
    try:
        return base64.b64encode(base64.b64decode(s)) == s
    except Exception:
        return False


def handle_string_to_bytes_and_decode(data: Union[str, bytes]):

    if isinstance(data, str):
        data = bytes(data)

    if isBase64(data):
        data = base64.b64decode(data)

    return data


def handle_string_to_bytes_and_encode(data: Union[str, bytes]):

    if isinstance(data, str):
        data = bytes(data)

    if not isBase64(data):
        data = base64.b64encode(data)

    return data

# %% ../../nbs/utils/Image.ipynb 5
def to_bytes(self) -> bytes:
    byte_arr = io.BytesIO()

    if not hasattr(self, "area"):
        self.area = self

    self.area.save(byte_arr, format=self.format)

    self.data = byte_arr.getvalue()

    return self.data


def crop_square(self):

    width, height = self.size  # Get dimensions

    new_edge = min(width, height)

    left = (width - new_edge) / 2
    top = (height - new_edge) / 2
    right = (width + new_edge) / 2
    bottom = (height + new_edge) / 2

    # Crop the center of the image
    self.area = self.crop((left, top, right, bottom))

    self.to_bytes()

    return self.area


@patch_to(Image, cls_method=True)
def from_image_file(cls, image_path: str) -> Image:
    if not os.path.exists(image_path):
        raise FileNotFoundError(image_path)

    with open(image_path, "rb") as file:
        data = file.read()

    data = handle_string_to_bytes_and_decode(data)

    im = PIL.Image.open(io.BytesIO(data))

    im.to_bytes = types.MethodType(to_bytes, im)
    im.crop_square = types.MethodType(crop_square, im)

    return im

# %% ../../nbs/utils/Image.ipynb 8
@patch_to(Image, cls_method=True)
def from_bytestr(cls, data: Union[str, bytes]) -> Image:

    data = handle_string_to_bytes_and_decode(data)

    im = PIL.Image.open(io.BytesIO(data))

    im.to_bytes = types.MethodType(to_bytes, im)
    im.crop_square = types.MethodType(crop_square, im)

    return im

# %% ../../nbs/utils/Image.ipynb 11
default_img_bytes = b'\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x01,\x00\x00\x01,\x08\x06\x00\x00\x00y}\x8eu\x00\x00\x0eUIDATx\x9c\xed\xdd\xe9r\xda\xd8\x16@\xe1-\x81\x84\x18M\x02\xb1\x93T\xbf\xff\xa3\xb9\xc1\x063\nM\xe8\xe8\xfe\xe86\x95\xdc\x0c\x9d86\xe7\xec\xa3\xf5UQvuW%;\x12Z\x80&\x82\xcdf\xd3\x08\x00(\x10\xda\x1e\x00\x00~\x15\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0\x06\xc1\x02\xa0F\xd7\xf6\x00\xd0\xabi\x1a1\xc6\x881F\x9a\xa6\x91\xa6iDD\xc4\x18#""a\xf8\xcf\xeba\x10\x04\x12\x04\x81\x84a(a\x18J\x10\x04\xd6f\x86n\x04\x0b\xbf\xa4\xaek\xc9\xf3\\\xf2<\x97\xaa\xaa\xa4,K\xa9\xaa\xeaE\x7fV\x14E\x12\xc7\xb1DQ$I\x92H\x92$\xd2\xe9t^yb\xf8\x88`\xe1\x87\xb2,\x93\xd3\xe9$Y\x96IQ\x14\xaf\xf6\xe7VU\xf5M\xecz\xbd\x9e\xf4\xfb}\x19\x0c\x06\xd2\xef\xf7_\xed\xef\x82_\x82\xcdf\xd3\xd8\x1e\x02\xee\xa8\xaaJ\x0e\x87\x83\x1c\x8f\xc7\x17\xbf\x83\xfaSQ\x14\xc9h4\x92\xf1x,Q\x14Y\x99\x01n"X\x10\x11\x914Me\xbb\xddJ\x9e\xe7\xb6G\xf9J\x92$2\x9dNe8\x1c\xda\x1e\x05\x0e X-w8\x1cd\xbb\xddJY\x96\xb6G\xf9\xa98\x8ee:\x9d\xcax<\xb6=\n,"X-\x95\xa6\xa9\xac\xd7kk\x1f\xfb^*\x8a"\x99\xcdf\xbc\xe3j)\x82\xd52\xe7\xf3Y\x1e\x1f\x1f\xe5t:\xd9\x1e\xe5\x8f\x0c\x06\x03\xf9\xf0\xe1\x83t\xbb\x1c7j\x13\x82\xd5\x12M\xd3\xc8f\xb3\x91\xedv{9_J\xbb \x08d:\x9d\xca\xbbw\xef8\xb7\xab%\x08V\x0bTU%\xcb\xe5\xf2UOMpI\xaf\xd7\x93\xbb\xbb;\x8e(\xb6\x00\xc1\xf2\\\x9a\xa6\xf2\xf0\xf0p9\xfb\xdcWa\x18\xca\xed\xed-\xfb\xb6<G\xb0<\xb6^\xafe\xbb\xdd\xda\x1e\xe3\xaa\xa6\xd3\xa9\xccf3\xdbc\xe0\x8d\xb0\xc7\xd2CM\xd3\xc8\xc3\xc3\x83\x1c\x8fG\xdb\xa3\\\xddv\xbb\x95\xf3\xf9,\xb7\xb7\xb7\xec\xd7\xf2\x10\xc1\xf2\x8c1F\x16\x8b\x85dYf{\x14k\x8e\xc7\xa3\xd4u-\x1f?~\xbc\\\x80\r?\xb06=b\x8c\x91\xfb\xfb\xfbV\xc7\xeaY\x96er\x7f\x7f\xef\xfd\xbe\xbb\xb6!X\x9ex\x8e\x95\xafG\x02_\xa2(\n\xa2\xe5\x19\x82\xe5\x81\xa6i\xbc>m\xe1O\x14E!\xcb\xe5\xd2\x9bs\xcf\xda\x8e`y\xc0\x873\xd7\xdf\xd2\xe9t\x92\xc7\xc7G\xdbc\xe0\x15\x10,\xe5\x9e\x9e\x9e\xe4p8\xd8\x1e\xc3y\x87\xc3A\x9e\x9e\x9el\x8f\x81?D\xb0\x14\xcb\xf3\\6\x9b\x8d\xed1\xd4\xd8l6\xce\xdd>\x07\xbf\x87`)U\xd7\xb5,\x16\x0b\xdbc\xa8\xb3X,\xa4\xaek\xdbc\xe0\x85\x08\x96R\xcb\xe5\x92\r\xef\x05\xea\xba\x96\xe5ri{\x0c\xbc\x10\xc1Rh\xbf\xdfs\xae\xd5\x1f\xc8\xb2L\xf6\xfb\xbd\xed1\xf0\x02\x04K\x19c\x8c\xac\xd7k\xdbc\xa8\xb7^\xaf9?K!\x82\xa5\xccj\xb5bC{\x05\xc6\x18Y\xadV\xb6\xc7\xc0o"X\x8a\xe4y\xce)\x0c\xaf\xe8p8p\xd4P\x19\x82\xa5\x08\x1f\x05_\x1f\xcbT\x17\x82\xa5\xc4\xf3\xb7.\xe3u\xb1\\u!XJp\x82\xe8\xdba\xd9\xeaA\xb0\x14(\x8a\x82k\x05\xdf\xd0\xe9t\xe2\xc2q%\x08\x96\x02\xbb\xdd\xce\xf6\x08\xdec\x19\xeb@\xb0\x1cg\x8c\x914Mm\x8f\xe1\xbd4M9]D\x01\x82\xe586\xa4\xeb\xe0\x85A\x07\x82\xe58\xce\xbb\xba\x1e\x96\xb5\xfb\x08\x96\xc3\xea\xba\xe6\x9a\xc1+\xca\xb2\x8c\x0b\xca\x1dG\xb0\x1cF\xac\xae\x8fe\xee6\x82\xe506\x9e\xebc\x99\xbb\x8d`9\x8cs\xaf\xae\x8fe\xee6\x82\xe5\xa8\xaa\xaa\xe4|>\xdb\x1e\xa3u\xce\xe7\xb3TUe{\x0c\xfc\x00\xc1r\x14g^\xdb\xc3\xb2w\x17\xc1r\x14\xaf\xf2\xf6\xb0\xec\xddE\xb0\x1c\xc5Fc\x0f\xcb\xde]\x04\xcbQeY\xda\x1e\xa1\xb5X\xf6\xee"X\x8e\xe2U\xde\x1e\x96\xbd\xbb\x08\x96\x83\x9a\xa6\xe1\xfaA\x8b\x8c1\xd24\x8d\xed1\xf0\x1d\x04\xcbA\xc4\xca>\xd6\x81\x9b\x08\x96\x83xu\xb7\x8fu\xe0&\x82\xe5 .\xc0\xb5\x8fu\xe0&\x82\xe5 ^\xdd\xedc\x1d\xb8\x89`9(\x08\x02\xdb#\xb4\x1e\xeb\xc0M\x04\xcbAl,\xf6\xb1\x0e\xdcD\xb0\x1c\x14\x86\xac\x16\xdbX\x07nb\xad8\x88Ww\xfbX\x07n"X\x0e\xeat:\xb6Gh=\xd6\x81\x9b\x08\x96\xa3\xba\xdd\xae\xed\x11Z\x8be\xef.\x82\xe5\xa88\x8em\x8f\xd0Z,{w\x11,G\xb1\xd1\xd8\xc3\xb2w\x17\xc1rT\x14E\xb6Gh-\x96\xbd\xbb\x08\x96\xa3\xd8h\xeca\xd9\xbb\x8b`9*I\x12\x0e\xad[\x10\x04\x81$Ib{\x0c\xfc\x00\xc1r\x14\x1b\x8e\x1d\xbcP\xb8\x8d`9\xac\xdf\xef\xdb\x1e\xa1uX\xe6n#X\x0ec\xe3\xb9>\x96\xb9\xdb\x08\x96\xc3\x92$\xe1$\xc6+\xeav\xbb|\x0cw\x1c\xc1r\xdch4\xb2=Bk\xb0\xac\xddG\xb0\x1c7\x1e\x8fm\x8f\xd0\x1a,k\xf7\x11,\xc7\xc5q\xcc\x99\xd7W\xc0r\xd6\x81`)0\x99Ll\x8f\xe0=\x96\xb1\x0e\x04K\x81\xc9d\xc2\xedN\xdeP\xa7\xd3!XJ\x10,\x05\x82 \x90\xe9tj{\x0coM\xa7SN\x16U\x82`)1\x99L\xb8m\xef\x1b\x08\xc3\x90wW\x8a\xb0\x05(\x11\x86\xa1\xdc\xdc\xdc\xd8\x1e\xc3;777\xbc\x10(\xc2\x9aRd:\x9dr\'\x81W\x14E\x11\x1f\xb5\x95!X\x8a\x84a(\xb3\xd9\xcc\xf6\x18\xde\x98\xcdf\xbc\xbbR\x86\xb5\xa5\xccp8\x94\xe1ph{\x0c\xf5X\x8e:\x11,\x85\xe6\xf39\xef\x0c\xfe@\x18\x862\x9f\xcfm\x8f\x81\x17\xe0Y\xafP\xb7\xdbe\x83\xfb\x03\xf3\xf9\x9c\x8b\xca\x95"XJ\x8d\xc7c\xae}{\x01\x96\x9bn\x04K\xb1\xf9|\xce\xf5o\xbf!\x8ec\xde\x99*G\xb0\x14\x0b\xc3P\xee\xee\xee\xd8\x9f\xf5\x0bXV~`\xed)\x17\xc7\xb1|\xfa\xf4\x89KK~"\x08\x02\xf9\xf4\xe9\x13\xefF=@\xb0<\x90$\x89\xdc\xdd\xdd\xd9\x1e\xc3Ywww\xdcI\xd4\x13\x04\xcb\x13\xc3\xe1Pnoom\x8f\xe1\x9c\xdb\xdb[\xce\xb7\xf2\x08\xc1\xf2\xc8x<&Z_\xb8\xbd\xbd\xe5\x88\xa0g8\x19\xc53\xe3\xf1X:\x9d\x8e,\x97K1\xc6\xd8\x1e\xc7\x8a\xe7\x1d\xec\x83\xc1\xc0\xf6(xe\xbc\xc3\xf2\xd0`0\x90\xcf\x9f?\xb7\xf2\x88X\x18\x86\xf2\xf9\xf3gb\xe5\xa9\xf6=\xa3[\xa2\xd7\xeb\xc9_\x7f\xfd%\xbd^\xcf\xf6(W\xd3\xc6\x7fs\xdb\x04\x9b\xcd\xa6\xb1=\x04\xdeN\xd34\xb2^\xafe\xb7\xdb\xd9\x1e\xe5M\xdd\xdc\xdc\xc8l6\xe3\xf4\x0e\xcf\x11\xac\x96H\xd3T\x1e\x1e\x1e\xbc\xdb\xaf\x15\x86!G\x02[\x84`\xb5\x881F\xd6\xeb\xb5\xec\xf7{\xdb\xa3\xbc\x8a\xc9d\xc2=\xadZ\x86`\xb5P\x9e\xe7\xf2\xf8\xf8(eY\xda\x1e\xe5E\xe28\x96\x0f\x1f>p2h\x0b\x11\xac\x16\xdb\xef\xf7\xb2\xddn\xa5\xaa*\xdb\xa3\xfc\x92\xe7[\x1a\xf3\xa5\x11\xedE\xb0 \xc7\xe3Q\xb6\xdb\xad\x14Ea{\x94\xef\xea\xf5z2\x9dNe4\x1a\xd9\x1e\x05\x96\x11,\\\x9cN\'9\x1c\x0e\x92\xa6\xa94\x8d\xdd\xa7E\x10\x042\x1c\x0ee<\x1esN\x15.\x08\x16\xbea\x8c\x914Me\xbf\xdfK\x9e\xe7W\xfd\xbb\x93$\x91\xc9d"\xc3\xe1\x90\x9d\xe9\xf8\x06\xc1\xc2O\x19c$\xcfs9\x9dN\x92e\xd9\xab\xef\xa8\x8f\xe3X\xfa\xfd\xbe\x0c\x06\x03I\x92\x84H\xe1\xa7\x08\x16~\x8b1F\xaa\xaa\x92\xb2,\xe5|>_~\x1ac.\x8f\xe7\x8f\x93A\x10H\x18\x86\x97G\xb7\xdb\x958\x8e/?\xa3("P\xf8-\\\xfc\x8c\xdf\x12\x86\xa1\xf4z=.\x7f\x81\x15\xbc\xbc\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83`\x01P\x83\xef%\xc4\x0f5M#u]\xcb\xf9|\x96\xba\xae\xa5\xaek1\xc6|\xf5{\xd34b\x8c\x11\x11\xf9\xe6\xe7\xf3\x97\xa4~\xf9\xf3\xf9\xcbU;\x9d\x8et:\x9d\xaf~\xefv\xbb\xd2\xe9t$\x08\x02\x0b\xffZh@\xb0Z\xee\xcboo~~TUu\xf9\xdd\x86n\xb7+\xddnW\xa2(\xba\xfc\xfe\xe5\xb7F\xa3\xbdX\xfb-q>\x9f\xa5(\x8a\xcb\xd7\xcc??\x9e\xbfV\xde%\xcf\xb1\xcc\xf3\xfc\x9b\xff\x17\x04\x81\xc4q|yDQ$\xbd^\x8f\x90\xb5\x04k\xd9CUUI\x9e\xe7R\x96\xa5\xe4y.EQ8\x19\xa6\x97h\x9aF\x8a\xa2\x90\xa2(\xbe\xfa\xefA\x10H\xaf\xd7\x93$I$\x8ecI\x92D\xa2(\xb24%\xde\n\xc1R\xce\x18#Y\x96IQ\x14\x978=\xefCj\x93\xa6i$\xcf\xf3\xaf\xde\x95\x85ax\x89X\xaf\xd7\x93~\xbf\x7f\xd9\x9f\x06\x9d\x82\xcdf\xe3\xc7KoK\xd4u-y\x9eK\x96e\x97@\xe1\xd7=\x07\xac\xdf\xefK\x92$\xd2\xe9tl\x8f\x84\xdf@\xb0\x1c\xd74\x8ddYvy\x10\xa8\xd7\xf5\xfc\xce\xeb\xf9\xc1\x11J\xb7\x11,\x07\xd5u-\xa7\xd3I\xd24\x95\xd3\xe9\xe4\xcd\xfe\'\xd7\x05A \x83\xc1@\x86\xc3\xa1\x0c\x06\x03\xde}9\x88`9\xa2,\xcbK\xa4\xbewt\x0c\xd7\x97$\xc9%^q\x1c\xdb\x1e\x07B\xb0\xac\xaa\xaaJ\x8e\xc7\xa3\x1c\x0e\x07\xa9\xaa\xca\xf68\xf8\x89(\x8ad<\x1e\xcbh4\xe2\xe8\xa3E\x04\xeb\xca\x8c1\x97H\xf1NJ\xa7$I.\xf1\xe2\xa8\xe3u\x11\xac+h\x9aFN\xa7\x93\x1c\x0e\x07\xf6Iy\xe4y\x9f\xd7x<\x96\xc1`\xc0\x0e\xfb+ Xo\xe8|>\xcb~\xbf\x97\xfd~/u]\xdb\x1e\x07o\xa8\xd3\xe9\xc8d2\x91\xc9d\xc2Y\xf7o\x88`\xbd\x81\xa2(d\xb7\xdb\xc9\xf1x\xe4\xddT\xcb\x04A \xa3\xd1Hnnn\xa4\xd7\xeb\xd9\x1e\xc7;\x04\xeb\x15\xa5i*\xdb\xed\x96}S\x10\x91\x7f\xf6uM\xa7S\x19\x0e\x87\xb6G\xf1\x06\xc1z\x05\x87\xc3A6\x9b\rG\xfa\xf0]Q\x14\xc9\xbbw\xefd<\x1e\xdb\x1eE=\x82\xf5\x07\x8e\xc7\xa3<==\x11*\xfc\x92(\x8a\xe4\xfd\xfb\xf72\x1a\x8dl\x8f\xa2\x16\xc1z\x81\xd3\xe9$\xeb\xf5Z\xca\xb2\xb4=\n\x14\x8a\xe3Xf\xb3\x99\x0c\x06\x03\xdb\xa3\xa8C\xb0~C\x9e\xe7\xf2\xf4\xf4$Y\x96\xd9\x1e\x05\x1e\xe8\xf7\xfb\xf2\xfe\xfd{I\x92\xc4\xf6(j\x10\xac_`\x8c\x91\xf5z-\xfb\xfd\xde\xf6(\xf0\xd0d2\x91\xd9l\xc6I\xa8\xbf\x80`\xfd\x874Me\xb5ZY\xbb]0\xda\xa1\xdb\xed\xca|>\xe7\x88\xe2\x7f X?P\xd7\xb5\xacV+9\x1e\x8f\xb6GA\x8b\x8cF#\x99\xcf\xe7\xdc)\xe2\x07\x08\xd6w\x1c\x0e\x07Y\xadV\xad\xbcs\'\xec\x0b\xc3P\xe6\xf39\xa7A|\x07\xd7\x10\xfc\x9f\xd5j%\xbb\xdd\xce\xf6\x18h1c\x8c<<<HQ\x142\x9f\xcfm\x8f\xe3\x14\x82\xf5/c\x8c\xfc\xfd\xf7\xdf\x9c\xa5\x0eg\xecv;)\x8aB>}\xfa\xc4\x0e\xf9\x7f\xf1\x91P\xfe\xb9\xf6o\xb1X\xb0c\x1dN\xeav\xbb\xf2\xf1\xe3G\xaeM\x14\xbe\xaa^\xd24\x95\xfb\xfb{b\x05g\x9d\xcfg\xb9\xbf\xbf\x974Mm\x8fb]\xab\x83\xb5\xdb\xedd\xb1X\xb0s\x1d\xce3\xc6\xc8b\xb1h\xfd\xfe\xd5\xd6\x06k\xb7\xdb\xc9j\xb5\xb2=\x06\xf0[\xda~P\xa8\x95\xc1z>m\x01\xd0h\xb5Z\xc9\xe1p\xb0=\x86\x15\xad\x0bV\x96e\xf2\xf0\xf0`{\x0c\xe0\x8f<<<\xb4\xf2\x9a\xd6V\x05\xab,KY,\x16\xb6\xc7\x00^\xc5b\xb1h\xdd\x1dCZ\x13\xac\xa6id\xb9\\\xb2\x83\x1d\xde0\xc6\xc8r\xb9l\xd5m\xb8[\x13,\xee_\x05\x1f\x95e)\xeb\xf5\xda\xf6\x18W\xd3\x8a`eY\xd6\xea#+\xf0\xdbn\xb7k\xcd\xfe\xacV\x04\x8b#\x82\xf0][\x9e\xe3\xde\x07k\xb7\xdb\xf1Q\x10\xde+\xcb\xb2\x15\x9f"\xbc\x0eV\xd34\xb2\xd9ll\x8f\x01\\\xc5f\xb3\xf1~\x07\xbc\xd7\xc1:\x1e\x8f|\xe32Z\xa3\xaek\xefo8\xe9u\xb0\xda\xf0\x16\x19\xf8\x92\xef\xcfyo\x83U\x96\xa5\x14Ea{\x0c\xe0\xaa\x8a\xa2\xf0z\x9f\xad\xb7\xc1\xe2V\x1ch+\x9f\x9f\xfb\xde\x06\xebt:\xd9\x1e\x01\xb0\xc2\xe7\xe7\xbe\xb7\xc1\xe2\xe3 \xda\xca\xe7\xe7\xbe\x97\xc1\xaa\xeb\xda\xfb\xc3\xbb\xc0\x8f4M\xe3\xed\xd1qo\x83\x05\xb4\x99\xaf\xdb\x80\x97\xc1\x02\xe0\'/\x83\xc5-d\xd0v\xben\x03^\x06\x8b\xfdWh;_\xb7\x01/\x83\x15\x04\x81\xed\x11\x00\xab|\xdd\x06\xbc\x0c\x16\x00?\x11,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x10,\x00j\x04\x9b\xcd\xc6\xbb/03\xc6HY\x96\xb6\xc7\x00\xac\x89\xe3X\xc2\xd0\xbf\xf7#]\xdb\x03\xbc\x850\x0c%I\x12\xdbc\x00xe\xfe%\x18\x80\xb7\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\x08\x16\x005\xfe\x07\xc7\x90\x82NM<\xd04\x00\x00\x00\x00IEND\xaeB`\x82'

# %% ../../nbs/utils/Image.ipynb 12
domo_default_img = Image.from_bytestr(default_img_bytes)


def are_same_image(image1, image2):
    try:
        img_chop = PIL.ImageChops.difference(image1, image2)

        print(np.sum(np.array(img_chop.getdata())))

        if np.sum(np.array(img_chop.getdata())) == 0:
            return True
        return False

    except ValueError as e:
        print(e)
        return False

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\utils\read_creds_from_dotenv.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\utils\read_creds_from_dotenv.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/utils/read_creds_from_dotenv.ipynb.

# %% auto 0
__all__ = ['ReadCreds_EnvFileNotExist', 'read_creds_from_dotenv']

# %% ../../nbs/utils/read_creds_from_dotenv.ipynb 2
import domolibrary.utils.DictDot as utils_dd
from dotenv import load_dotenv
import os

# %% ../../nbs/utils/read_creds_from_dotenv.ipynb 3
class ReadCreds_EnvFileNotExist(Exception):
    def __init__(self, env_path):
        message = f"file not found at -- {env_path}"
        super().__init__(message)


def read_creds_from_dotenv(
    env_path: str = ".env",
    params: list[str] = None,  # list of params you're expecting in the env file,
) -> utils_dd.DictDot:
    """use_prod = false will replace all PROD values with matching TEST values"""

    file_exists = os.path.exists(env_path)

    if not file_exists:
        raise ReadCreds_EnvFileNotExist(env_path)

    load_dotenv(env_path)
    params = params or list(os.environ.keys())

    params_res = {}
    for param in params:
        param = str(param)
        params_res.update({param: os.environ.get(param)})

    return utils_dd.DictDot(params_res)

                </code>
                </div>
            </pre><hr></div><a name='domolibrary\utils\upload_data.py'></a>
<h3><a href="#top" target="_blank">HOME</a></h3>
<h3>Name: domolibrary\utils\upload_data.py</h3>


            <div class = "modulePrint">
            <pre>
                <code class = "language-python">
                    # AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/utils/upload_data.ipynb.

# %% auto 0
__all__ = ['upload_data']

# %% ../../nbs/utils/upload_data.ipynb 2
import httpx

import domolibrary.client.Logger as lc
import domolibrary.client.DomoAuth as dmda
import domolibrary.classes.DomoDataset as dmds
import pandas as pd

# %% ../../nbs/utils/upload_data.ipynb 4
async def loop_upload(
    upload_df: pd.DataFrame,
    consol_ds: dmds.DomoDataset,
    partition_key: str,
    upload_method: str,
    logger: lc.Logger,
    debug_api: bool = False,
    debug_prn: bool = False,
    debug_fn: bool = True,
    max_retry: int = 2,
    is_index: bool = False,
):
    base_msg = (
        f"{partition_key} in {consol_ds.auth.domo_instance}"
        if partition_key
        else f"in {consol_ds.auth.domo_instance}"
    )

    if debug_fn:
        print(
            f"starting upload of {len(upload_df)} rows to {base_msg} with {max_retry} attempts"
        )

    retry_attempt = 1

    res = None

    while retry_attempt <= max_retry and not res:
        try:
            if debug_fn:
                print(f"attempt {retry_attempt}/{max_retry} for {base_msg}")

            res = await consol_ds.upload_data(
                upload_df=upload_df,
                upload_method="REPLACE" if partition_key else upload_method,
                partition_key=partition_key,
                is_index=is_index,
                debug_api=debug_api,
                debug_prn=debug_prn,
            )

        except Exception as e:
            retry_attempt += 1

            message = f"‚ö†Ô∏è upload_data : unexpected error: {e} in {partition_key} during retry_attempt {retry_attempt}/{max_retry}"
            logger.log_warning(message)
            if debug_fn:
                print(message)

    if not res:
        raise Exception(
            f"üí£ failed to upload data {len(upload_df)} rows to {base_msg} - {retry_attempt}/{max_retry} retries reached"
        )

    return res

# %% ../../nbs/utils/upload_data.ipynb 5
async def upload_data(
    # instance where the data_fn function will execute against
    data_fn,  # data function to execute
    instance_auth: dmda.DomoAuth,  # instance to run the data function against
    consol_ds: dmds.DomoDataset,  # dataset where data should be accumulated
    # if partition key supplied, will replace existing partition
    partition_key: str = None,
    upload_method: str = "REPLACE",
    is_index: bool = False,  # index dataset
    debug_prn: bool = False,
    debug_fn: bool = True,
    debug_api: bool = False,
    logger: lc.Logger = None,
    max_retry: int = 2,  # number of times to attempt upload
):
    logger = logger or lc.Logger(app_name="upload_data")

    try:
        message = f"üèÅ starting {instance_auth.domo_instance} - {data_fn.__name__}"
        logger.log_info(message)
        print(message)

        instance_session = httpx.AsyncClient()

        upload_df = await data_fn(instance_auth, instance_session, debug_api=debug_api)

        if upload_df is None or (
            isinstance(upload_df, pd.DataFrame) and len(upload_df.index) == 0
        ):
            message = f"no data to upload for {partition_key}: {consol_ds.id} in {consol_ds.auth.domo_instance}"
            logger.log_info(message)
            print(message)
            return None

        if debug_prn:
            print(upload_df[0:5])

        res = await loop_upload(
            upload_df=upload_df,
            consol_ds=consol_ds,
            partition_key=partition_key,
            upload_method=upload_method,
            debug_api=debug_api,
            debug_prn=debug_prn,
            debug_fn=debug_fn,
            max_retry=max_retry,
            logger=logger,
            is_index=False,
        )

        if res.is_success:
            message = f"üöÄ success upload of {partition_key} to {consol_ds.id} in {consol_ds.auth.domo_instance} in {data_fn.__name__}"
            logger.log_info(message)

        else:
            message = f"üí£ upload_data successful status but failed to upload {partition_key} - {res.status} - {res.response} in {data_fn.__name__}"
            logger.log_error(message)

        print(message)

        return res

    finally:
        if is_index:

            res = await consol_ds.index_dataset(
                debug_api=debug_api, session=instance_session
            )
            if res.is_success:
                message = f"ü•´ successfully indexed {consol_ds.name} in {consol_ds.auth.domo_instance}"
                logger.log_info(message)
            else:
                message = f"üíÄ‚ö†Ô∏è failure to index {consol_ds.name} in {consol_ds.auth.domo_instance}"
                logger.log_error(message)

            print(message)

        await instance_session.aclose()

                </code>
                </div>
            </pre><hr></div></body>
</html>
